{
  "@context": [
    "https://schema.org",
    { "proj": "https://github.com/ssdeanx/ai-sdk-DM/ns#" },
    { "feature": "https://schema.org/hasFeature" }
  ],
  "@type": "Graph",
  "name": "Upstash Memory Adapter Knowledge Graph",
  "description": "Living knowledge graph for the /lib/memory/upstash folder, capturing entities (files, types, features), relationships, onboarding, navigation, and AI agent support. Upstash must handle ALL API logic and data for all entities, not just memory, and all business logic must be routed through Upstash-first APIs with fallback only.",
  "version": "1.0.0",
  "generatedAt": "2025-05-14T00:00:00Z",
  "@graph": [
    {
      "@id": "lib/memory/upstash/agent-state-store.ts",
      "@type": ["CodeFile"],
      "path": "lib/memory/upstash/agent-state-store.ts",
      "exports": ["saveAgentState", "loadAgentState", "listThreadAgentStates", "deleteAgentState", "deleteThreadAgentStates", "createAgentState", "getAllAgentStates", "AgentStateStoreError", "AgentStateSchema", "StoredAgentStateSchema"],
      "features": [
        "Agent state management in Redis",
        "Zod schema validation for agent state objects",
        "Error handling with custom error classes",
        "CRUD for agent state keyed by agent/thread",
        "Integration with upstashLogger for all errors and state changes",
        "Supports fallback to Supabase/LibSQL for agent state if Upstash unavailable"
      ],
      "types": ["AgentState", "StoredAgentState", "AgentStateStoreError"],
      "zodSchemas": ["AgentStateSchema", "StoredAgentStateSchema"],
      "commands": [
        "hset", "hget", "hdel", "hscan", "@upstash/query", "RediSearch (FT.SEARCH)", "fallback: supabase upsert/select/delete"
      ],
      "tasksCompleted": [
        "Initial implementation", "Added Zod validation", "Integrated upstashLogger", "Added fallback logic", "Replaced uuidv4 with generateId", "Documented API routes and relationships"
      ],
      "tasksPending": [
        "Remove all any types (see README)", "Remove all direct console statements, use upstashLogger", "Add @upstash/query support for agent state search if needed", "Add more robust error handling and type safety", "Add tests for agent state operations", "Infer all types from usage and add to types field", "List all exported/imported functions, consts, and methods", "Map all API routes that depend on this file (legacy and new)", "Add/expand reasoning tools and document addUsage for each", "Refactor legacy API routes to use new ai-sdk-ui endpoints", "Ensure test coverage for all CRUD and fallback logic", "Document migration status and code smells", "Link onboarding and troubleshooting docs for new contributors"
      ],
      "status": "incomplete",
      "observations": [
        "Type errors present (see get_errors)",
        "Direct console usage found",
        "No advanced search support yet",
        "Agent state is persisted in Upstash, with fallback to Supabase/LibSQL if unavailable",
        "API routes for agents/threads depend on this module for state management",
        "Directly depends on upstashTypes.ts for type safety and Zod validation.",
        "All agent state CRUD operations are logged via upstashLogger.",
        "Fallback to Supabase/LibSQL is triggered on Upstash errors.",
        "Should be tested with reasoningTools (debuggingapproach, metacognitivemonitoring) for robust error handling.",
        "Semantic search can be used to trace agent state usage across API routes.",
        "Code smells: Any direct console usage or 'any' types should be flagged and refactored.",
        "Integration with memoryStore.ts and index.ts is critical for system-wide agent state consistency.",
        "All changes should be reflected in the knowledge graph and README for traceability.",
        "@upstash/query can be used for advanced agent state search and analytics.",
        "RediSearch integration is possible for full-text and filtered agent state queries.",
        "All agent state changes should be observable via upstashLogger and analytics routes.",
        "Fallback logic must be tested for all CRUD/search paths, with logs for each failure mode.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of agent state flows, fallback triggers, and log analysis.",
        "Observability and analytics are critical for agent state debugging and system health monitoring.",
        "Semantic search can help map agent state usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "tags": [
        "upstash",
        "agent-state",
        "memory",
        "ai-sdk-core",
        "ai-sdk-ui",
        "observability",
        "analytics",
        "fallback",
        "supabase",
        "libsql",
        "zod",
        "tracing",
        "OpenTelemetry",
        "Langfuse",
        "integration",
        "backend",
        "frontend",
        "project:ai-sdk-DM",
        "knowledge-graph",
        "onboarding",
        "tool-logging",
        "state-debugging",
        "context7",
        "documentation",
        "dynamic-docs",
        "integration-tool",
        "search",
        "vector",
        "ratelimit",
        "qstash",
        "redis",
        "logging",
        "metrics",
        "monitoring",
        "troubleshooting",
        "types",
        "functions",
        "const",
        "methods",
        "imports",
        "exports",
        "inferred-types",
        "api-routes",
        "legacy-api",
        "ai-sdk-ui",
        "test-coverage",
        "migration-status"
      ],
      "connections": [
        { "with": "memoryStore.ts", "purpose": "agent state CRUD and fallback integration" },
        { "with": "upstash-logger.ts", "purpose": "logging for all agent state ops" },
        { "with": "supabase-adapter.ts", "purpose": "fallback and compatibility for agent state" },
        { "with": "upstashTypes.ts", "purpose": "type safety and Zod validation for agent state" },
        { "with": "stream-processor.ts", "purpose": "streaming agent state changes for analytics and observability" },
        { "with": "tools.json", "purpose": "agent state analytics and tool execution logging" },
        { "with": "otel-tracing.ts", "purpose": "OpenTelemetry tracing for agent state ops" },
        { "with": "langfuse-integration.ts", "purpose": "Langfuse observability and metrics for agent state" },
        { "with": "README.md", "purpose": "project onboarding and knowledge graph documentation" },
        { "with": "lib/README.md", "purpose": "backend onboarding and architecture" },
        { "with": "onboarding:get-library-docs", "purpose": "fetch up-to-date docs for any package or integration" },
        { "with": "onboarding:resolve-library-id", "purpose": "resolve npm package names for doc lookup" },
        { "with": "onboarding:git_files", "purpose": "view and search project source for onboarding and troubleshooting" },
        { "with": "context7", "purpose": "dynamic documentation and context lookup for any package or API" }
      ],
      "apiRoutes": [
        "/api/ai-sdk/agents",
        "/api/ai-sdk/threads",
        "/api/ai-sdk/dashboard",
        "/api/ai-sdk/system",
        "/api/ai-sdk/apps",
        "/api/ai-sdk/mdx",
        "/api/ai-sdk/settings",
        "/api/ai-sdk/observability",
        "/api/ai-sdk/content",
        "/api/ai-sdk/blog",
        "/api/ai-sdk/auth"
      ],
      "reasoningTools": [
        {
          "name": "debuggingapproach",
          "addUsage": "Use for step-by-step debugging of agent state flows and fallback logic. Document findings in troubleshooting section."
        },
        {
          "name": "metacognitivemonitoring",
          "addUsage": "Apply for monitoring error patterns and log analysis. Integrate with upstashLogger and analytics."
        },
        {
          "name": "codesmells",
          "addUsage": "Run periodically to flag direct console usage, any types, and missing error handling. Document in migration status."
        }
      ],
      "usageNotes": "Use for all agent state persistence. Always validate with Zod. Log all errors. Integrate with OpenTelemetry and Langfuse for observability. Ensure fallback to Supabase/LibSQL is robust. Update knowledge graph and onboarding docs with any changes.",
      "onboarding": "See README.md, lib/README.md, and the documentation graph (see below) for setup, usage, and project context. Ensure fallback logic, observability, and analytics are implemented. Cross-reference all changes in the knowledge graph.",
      "navigation": "Imported by memoryStore.ts, index.ts, and referenced in project onboarding docs.",
      "troubleshooting": "Check for type errors, missing logger usage, and incomplete tracing/observability integration. Validate fallback logic and knowledge graph updates.",
      "graphNotes": "Central node for agent state in Upstash and ai-sdk-DM knowledge graph. Connects to ai-sdk-core, ai-sdk-ui, OpenTelemetry, Langfuse, and project onboarding. For a full list of available documentation, see the documentation graph below.",
      "relationships": [
        { "type": "memory", "target": "memory" },
        { "type": "api-route", "target": "app/api/ai-sdk/agents" },
        { "type": "api-route", "target": "app/api/ai-sdk/threads" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "fallback", "target": "lib/memory/supabase.ts" },
        { "type": "observability", "target": "otel-tracing.ts" },
        { "type": "analytics", "target": "langfuse-integration.ts" },
        { "type": "docs", "target": "README.md" },
        { "type": "docs", "target": "lib/README.md" },
        { "type": "integration", "target": "ai-sdk-core" },
        { "type": "integration", "target": "ai-sdk-ui" },
        { "type": "integration", "target": "OpenTelemetry" },
        { "type": "integration", "target": "Langfuse" }
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Rubber Ducking",
        "Inversion",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/index.ts",
      "@type": ["CodeFile"],
      "path": "lib/memory/upstash/index.ts",
      "exports": [
        "getRedisClient", "getVectorClient", "checkUpstashAvailability", "createRedisThread", "getRedisThreadById", "updateRedisThread", "listRedisThreads", "deleteRedisThread", "createRedisMessage", "getRedisMessageById", "getRedisMessagesByThreadId", "deleteRedisMessage", "upsertEmbeddings", "searchSimilarEmbeddings", "getEmbeddingsByIds", "deleteEmbeddingsByIds", "resetVectorIndex", "getVectorIndexInfo", "logInfo", "logWarn", "logError", "logDebug", "getLogs", "deleteLogs", "clearLogs", "saveAgentState", "loadAgentState", "listThreadAgentStates", "deleteAgentState", "deleteThreadAgentStates", "createAgentState", "getAllAgentStates", "MemoryProcessor", "MemoryProcessorError", "RedisClientError", "VectorClientError", "streamProcessor", "StreamProcessor", "StreamProcessorError", "getData", "getItemById", "createItem", "updateItem", "deleteItem", "vectorSearch", "upsertSupabaseVectors", "VectorDataSchema", "VectorSearchOptionsSchema", "createSupabaseClient"
      ],
      "features": [
        "Barrel export for Upstash memory module",
        "Exports all Upstash memory, vector, logging, and adapter utilities",
        "Centralizes all exports for easy import",
        "Ensures type safety and up-to-date exports"
      ],
      "commands": [
        "hset", "hget", "hdel", "hscan", "@upstash/query", "RediSearch (FT.SEARCH)", "fallback: supabase upsert/select/delete"
      ],
      "tasksCompleted": [
        "Initial barrel export", "Added new exports as features grew"
      ],
      "tasksPending": [
        "Remove/replace all broken exports (see README errors)", "Ensure all exports are up-to-date and type-safe", "Add documentation for new/advanced exports", "Check for missing/broken exports from dependencies (see get_errors)"
      ],
      "consumers": ["lib/memory/memory.ts", "API: /api/memory/*"],
      "dependencies": [
        "agent-state-store.ts", "memory-processor.ts", "memoryStore.ts", "redis-store.ts", "stream-processor.ts", "supabase-adapter-factory.ts", "supabase-adapter.ts", "upstash-logger.ts", "upstashClients.ts", "upstashTypes.ts", "vector-store.ts"
      ],
      "testFiles": ["tests/upstash/index.test.ts"],
      "docs": ["README.md#index.ts"],
      "examples": ["How to import all Upstash memory features"],
      "changelog": ["Initial barrel export", "Added new exports as features grew"],
      "todo": [
        "Remove/replace all broken exports (see README errors)",
        "Ensure all exports are up-to-date and type-safe",
        "Add documentation for new/advanced exports",
        "Check for missing/broken exports from dependencies (see get_errors)"
      ],
      "status": "incomplete",
      "observations": [
        "Central export node for all Upstash memory features",
        "All API routes under app/api/ai-sdk/* import from here for memory/vector/logging/agent state ops",
        "Fallback to Supabase/LibSQL handled via supabase-adapter exports",
        "No direct errors, but may be blocked by missing/broken exports from dependencies. See get_errors."
      ],
      "tags": [
        "upstash",
        "memory",
        "vector",
        "logging",
        "agent-state",
        "integration",
        "backend",
        "frontend",
        "project:ai-sdk-DM",
        "knowledge-graph",
        "onboarding",
        "documentation",
        "dynamic-docs",
        "integration-tool",
        "search",
        "ratelimit",
        "qstash",
        "redis",
        "metrics",
        "monitoring",
        "troubleshooting",
        "types",
        "functions",
        "const",
        "methods",
        "imports",
        "exports",
        "api-routes",
        "legacy-api",
        "ai-sdk-ui",
        "test-coverage",
        "migration-status"
      ],
      "connections": [
        { "with": "agent-state-store.ts", "purpose": "barrel export for agent state operations" },
        { "with": "memory-processor.ts", "purpose": "barrel export for memory processing" },
        { "with": "memoryStore.ts", "purpose": "barrel export for memory CRUD" },
        { "with": "redis-store.ts", "purpose": "barrel export for Redis operations" },
        { "with": "stream-processor.ts", "purpose": "barrel export for streaming operations" },
        { "with": "supabase-adapter.ts", "purpose": "barrel export for Supabase fallback" },
        { "with": "upstash-logger.ts", "purpose": "barrel export for logging utilities" },
        { "with": "upstashClients.ts", "purpose": "barrel export for Upstash clients" },
        { "with": "upstashTypes.ts", "purpose": "barrel export for shared types and schemas" },
        { "with": "vector-store.ts", "purpose": "barrel export for vector operations" },
        { "with": "onboarding:get-library-docs", "purpose": "fetch up-to-date docs for any package or integration" },
        { "with": "onboarding:resolve-library-id", "purpose": "resolve npm package names for doc lookup" },
        { "with": "onboarding:git_files", "purpose": "view and search project source for onboarding and troubleshooting" },
        { "with": "context7", "purpose": "dynamic documentation and context lookup for any package or API" }
      ],
      "onboardingTools": [
        "onboarding:get-library-docs",
        "onboarding:resolve-library-id",
        "onboarding:git_files",
        "context7"
      ],
      "usageNotes": "Use this file to import any Upstash memory feature.",
      "onboarding": "Check README for export list and update policy.",
      "navigation": "Barrel for all Upstash memory files.",
      "troubleshooting": "If an export is missing, check this file and README.",
      "graphNotes": "Central export node.",
      "relationships": [
        { "type": "barrel", "target": "lib/memory/upstash/*" },
        { "type": "api-route", "target": "app/api/ai-sdk/*" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "consumer", "target": "lib/memory/memory.ts" },
        { "type": "consumer", "target": "app/api/ai-sdk/threads" },
        { "type": "consumer", "target": "app/api/ai-sdk/messages" },
        { "type": "consumer", "target": "app/api/ai-sdk/agents" },
        { "type": "consumer", "target": "app/api/ai-sdk/logs" },
        { "type": "consumer", "target": "app/api/ai-sdk/analytics" }
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Occam's Razor",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/redis-store.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/threads" },
        { "type": "api-route", "target": "app/api/ai-sdk/messages" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "fallback", "target": "lib/memory/supabase.ts" },
        { "type": "onboarding:get-library-docs", "purpose": "fetch up-to-date docs for any package or integration" },
        { "type": "onboarding:resolve-library-id", "purpose": "resolve npm package names for doc lookup" },
        { "type": "onboarding:git_files", "purpose": "view and search project source for onboarding and troubleshooting" },
        { "type": "context7", "purpose": "dynamic documentation and context lookup for any package or API" }
      ],
      "connections": [
        { "with": "memoryStore.ts", "purpose": "thread/message CRUD, search, and RediSearch" },
        { "with": "upstash-logger.ts", "purpose": "logging for all thread/message ops" },
        { "with": "supabase-adapter.ts", "purpose": "fallback and compatibility" }
      ],
      "commands": [
        "hset", "hget", "hdel", "hscan", "zadd", "zrem", "zrange", "zrevrange", "RediSearch (FT.SEARCH)", "@upstash/query", "pipeline", "fallback: supabase upsert/select/delete"
      ],
      "tasksCompleted": [
        "Replaced uuidv4 with generateId from 'ai' for all ID generation",
        "Integrated upstashLogger for all error and operation logging",
        "Type-safe CRUD for threads/messages using Zod schemas",
        "Fallback logic to Supabase/LibSQL for all CRUD/search paths",
        "Documented API routes and relationships",
        "Initial @upstash/query client integration"
      ],
      "tasksPending": [
        "Remove all any types (see README and get_errors)",
        "Remove unused @ts-expect-error directives",
        "Use @upstash/query for advanced thread/message search (RediSearch, full-text, filters)",
        "Add more type-safe helpers for RediSearch results",
        "Remove all direct console statements, use upstashLogger",
        "Add tests for thread/message search and RediSearch integration",
        "Expand Zod schemas for all entity types (not just threads/messages)",
        "Document all Redis/RediSearch commands used",
        "Ensure all business logic is routed through Upstash-first APIs"
      ],
      "observations": [
        "Handles thread/message CRUD for all entities, not just memory.",
        "Integrates with upstashLogger for all error and operation logging.",
        "Uses upstashTypes.ts for type safety and Zod validation.",
        "Fallback logic to Supabase/LibSQL must be tested for all CRUD/search paths.",
        "Should leverage reasoningTools (debuggingapproach, sequentialthinking) for troubleshooting complex data flows.",
        "Semantic search can help map thread/message relationships across the codebase.",
        "Code smells: Look for any direct console statements, unused types, or missing error handling.",
        "RediSearch and advanced filtering should be documented and tested for all entity types.",
        "@upstash/query can be used for advanced thread/message search and analytics.",
        "RediSearch integration is possible for full-text and filtered thread/message queries.",
        "All thread/message changes should be observable via upstashLogger and analytics routes.",
        "Fallback logic must be tested for all CRUD/search paths, with logs for each failure mode.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of thread/message flows, fallback triggers, and log analysis.",
        "Observability and analytics are critical for thread/message debugging and system health monitoring.",
        "Semantic search can help map thread/message usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability.",
        "Full Upstash Redis command set available. See: https://context7.com/upstash/docs/llms.txt?folders=redis&tokens=84007 for all supported commands, pipelining, and advanced LLM/RediSearch usage."
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Inversion",
        "Occam's Razor",
        "Mindmaps & Hill Charts"
      ],
      "docs": [
        "README.md#redis-store.ts",
        "https://context7.com/upstash/docs/llms.txt?folders=redis&tokens=84007"
      ]
    },
    {
      "@id": "lib/memory/upstash/vector-store.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/embeddings" },
        { "type": "api-route", "target": "app/api/ai-sdk/vector-search" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "fallback", "target": "lib/memory/supabase.ts" },
        { "type": "onboarding:get-library-docs", "purpose": "fetch up-to-date docs for any package or integration" },
        { "type": "onboarding:resolve-library-id", "purpose": "resolve npm package names for doc lookup" },
        { "type": "onboarding:git_files", "purpose": "view and search project source for onboarding and troubleshooting" },
        { "type": "context7", "purpose": "dynamic documentation and context lookup for any package or API" }
      ],
      "connections": [
        { "with": "memoryStore.ts", "purpose": "embedding storage/search for all entities" },
        { "with": "upstash-logger.ts", "purpose": "logging for vector ops" },
        { "with": "supabase-adapter.ts", "purpose": "fallback and compatibility" },
        { "with": "memory-processor.ts", "purpose": "semantic/streaming search for all entities" }
      ],
      "commands": [
        "upsert", "query", "delete", "info", "reset", "@upstash/query", "RediSearch (FT.SEARCH)", "pipeline", "fallback: supabase upsert/select/delete"
      ],
      "tasksCompleted": [
        "Replaced uuidv4 with generateId from 'ai' for all ID generation",
        "Integrated upstashLogger for all vector operation logging",
        "Type-safe CRUD for embeddings using Zod schemas",
        "Fallback logic to Supabase/LibSQL for all vector operations",
        "Initial @upstash/query client integration"
      ],
      "tasksPending": [
        "Remove all direct console statements, use upstashLogger",
        "Use precise types for metadata, results, and errors",
        "Add @upstash/query integration for hybrid search, advanced filtering",
        "Add more robust error handling and logging",
        "Add tests for hybrid and filtered search",
        "Expand Zod schemas for all entity types (not just embeddings)",
        "Document all Vector/RediSearch commands used",
        "Ensure all business logic is routed through Upstash-first APIs"
      ],
      "observations": [
        "Central node for all vector/embedding CRUD and search.",
        "All vector operations are logged via upstashLogger.",
        "Type safety enforced via upstashTypes.ts and Zod schemas.",
        "Fallback to Supabase/LibSQL for vector operations must be robust and tested.",
        "Should use reasoningTools (scientificmethod, decisionframework) for evaluating search/filtering strategies.",
        "Semantic search is essential for tracing embedding usage and debugging search results.",
        "Code smells: Any use of 'any' types, missing logging, or direct console statements should be flagged.",
        "Integration with memoryStore.ts and supabase-adapter.ts is key for end-to-end vector data flow.",
        "@upstash/query can be used for advanced vector search and analytics.",
        "RediSearch integration is possible for full-text and filtered vector queries.",
        "All vector changes should be observable via upstashLogger and analytics routes.",
        "Fallback logic must be tested for all CRUD/search paths, with logs for each failure mode.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of vector flows, fallback triggers, and log analysis.",
        "Observability and analytics are critical for vector debugging and system health monitoring.",
        "Semantic search can help map vector usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability.",
        "Full Upstash Vector DB command set available. See: https://context7.com/upstash/docs/llms.txt?folders=vector&tokens=40216 for all supported commands, hybrid search, and advanced LLM/vector usage."
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Inversion",
        "Lean Startup",
        "Mindmaps & Hill Charts"
      ],
      "docs": [
        "README.md#vector-store.ts",
        "https://context7.com/upstash/docs/llms.txt?folders=vector&tokens=40216"
      ]
    },
    {
      "@id": "lib/memory/upstash/upstash-logger.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "onboarding:get-library-docs", "purpose": "fetch up-to-date docs for any package or integration" },
        { "type": "onboarding:resolve-library-id", "purpose": "resolve npm package names for doc lookup" },
        { "type": "onboarding:git_files", "purpose": "view and search project source for onboarding and troubleshooting" },
        { "type": "context7", "purpose": "dynamic documentation and context lookup for any package or API" }
      ],
      "connections": [
        { "with": "agent-state-store.ts", "purpose": "logging for agent state ops" },
        { "with": "redis-store.ts", "purpose": "logging for thread/message ops" },
        { "with": "vector-store.ts", "purpose": "logging for vector ops" }
      ],
      "commands": [
        "xadd", "xread", "xrange", "xdel", "@upstash/query", "pipeline"
      ],
      "tasksCompleted": [
        "Replaced uuidv4 with generateId from 'ai' for all log IDs",
        "Integrated upstashLogger for all logging",
        "Type-safe log entry parsing with Zod schemas",
        "Centralized logging for all Upstash modules"
      ],
      "tasksPending": [
        "Replace all any types with precise types (see errors)",
        "Remove unused types/vars (e.g., RedisClient)",
        "Remove all console statements, use upstashLogger only",
        "Ensure all log entry parsing is type-safe",
        "Add advanced log querying (e.g., by level, time range)",
        "Add tests for log streaming and retrieval",
        "Document all Redis Stream commands used"
      ],
      "observations": [
        "All logging for Upstash modules is centralized here.",
        "Type safety and Zod validation are required for all log entries.",
        "Should be integrated with reasoningTools (metacognitivemonitoring, codesmells) for log quality and anomaly detection.",
        "Semantic search can be used to analyze log patterns and trace issues across modules.",
        "Code smells: Any direct console usage or missing log validation should be flagged.",
        "Advanced log querying and streaming should be documented and tested.",
        "@upstash/query can be used for advanced log search and analytics.",
        "All log changes should be observable via analytics routes.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of log flows, triggers, and analysis.",
        "Observability and analytics are critical for log debugging and system health monitoring.",
        "Semantic search can help map log usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "mentalModels": [
        "Feedback Loops",
        "Inversion",
        "Rubber Ducking",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/upstashClients.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/*" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "onboarding:get-library-docs", "purpose": "fetch up-to-date docs for any package or integration" },
        { "type": "onboarding:resolve-library-id", "purpose": "resolve npm package names for doc lookup" },
        { "type": "onboarding:git_files", "purpose": "view and search project source for onboarding and troubleshooting" },
        { "type": "context7", "purpose": "dynamic documentation and context lookup for any package or API" }
      ],
      "connections": [
        { "with": "redis-store.ts", "purpose": "client management for Redis" },
        { "with": "vector-store.ts", "purpose": "client management for VectorDB" },
        { "with": "supabase-adapter.ts", "purpose": "Upstash-first client selection and fallback" }
      ],
      "commands": [
        "Redis.fromEnv", "Index", "Query", "validate config (Zod)", "health checks", "@upstash/query"
      ],
      "tasksCompleted": [
        "Type-safe, robust, singleton clients for Redis, Vector, and Query",
        "Uses Zod schemas for config validation",
        "upstashLogger for all logging",
        "Health checks and availability functions"
      ],
      "tasksPending": [
        "Fix Query config: { url, token } is not valid for QueryConfig (see get_errors)",
        "Add advanced Query client usage examples in docs",
        "Document how to use Query for RediSearch and advanced filtering",
        "Add tests for client initialization and error handling"
      ],
      "observations": [
        "Manages singleton clients for Redis and Vector, used by all Upstash modules.",
        "All client config is validated with Zod schemas from upstashTypes.ts.",
        "Should be tested with reasoningTools (debuggingapproach, metacognitivemonitoring) for connection reliability.",
        "Semantic search can help trace client usage and fallback logic across the codebase.",
        "Code smells: Any missing error handling, unused imports, or direct console statements should be flagged.",
        "Integration with supabase-adapter.ts and fallback logic is critical for reliability.",
        "@upstash/query can be used for advanced client search and analytics.",
        "All client changes should be observable via analytics routes.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of client flows, triggers, and analysis.",
        "Observability and analytics are critical for client debugging and system health monitoring.",
        "Semantic search can help map client usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability.",
        "Type error: Object literal may only specify known properties, and 'url' does not exist in type 'QueryConfig'. See get_errors."
      ],
      "todo": [
        "Fix Query config: { url, token } is not valid for QueryConfig (see get_errors)"
      ],
      "status": "incomplete",
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Circle of Competence",
        "Mindmaps & Hill Charts"
      ]
    }
  ],
  "meta": {
    "source": "auto-generated from README.md, memory.json, and codebase as of 2025-05-14",
    "updateStrategy": "automated extraction and continuous update via CI/CD and AI agent workflows",
    "intendedUse": [
      "Continuous improvement and documentation enforcement"
    ],
    "diamondCore": "A diamond core file is one that is absolutely central to the Upstash memory system's integrity, reliability, and extensibility. Bugs or design flaws here have system-wide impact. These files require the highest level of review, testing, and documentation.",
    "backup": "LibSQL and Supabase are backup/fallback backends. All features must work with Upstash as primary, and degrade gracefully to backup if needed."
  },
  "onboarding": {
    "purpose": "This onboarding is for AI agents (and advanced human contributors). Its goal is to ensure robust, error-free, and continuously improving Upstash memory adapter development. All steps are designed for AI agent reliability, self-improvement, and persistent insight.",
    "audience": "AI agents (Copilot, LLMs, automated CI/CD bots)",
    "corePrinciples": [
      "Type safety and Zod validation are required for all modules.",
      "After every file edit, always use get_errors to check for errors before considering the task complete.",
      "All direct console statements must be replaced with upstashLogger or equivalent.",
      "Every file must have comprehensive tests, docs, and usage examples.",
      "Knowledge graph and README must be updated with every significant change.",
      "Unused imports, types, and variables in diamond core files must be implemented and used if possible, not removed unless absolutely certain they are dead code. Removing them can break critical system behavior.",
      "Use semantic/graph search and mental models for navigation, troubleshooting, and continuous improvement.",
      "Apply mental models (see 'mentalModels' section) to break down, analyze, and solve coding and architectural problems.",
      "Onboarding and troubleshooting should be agent-friendly, with step-by-step guidance and references to code, docs, and graph nodes.",
      "Continuous improvement: treat every error, warning, or TODO as a learning opportunity and update the knowledge graph accordingly.",
      "For diamond core files, always prefer refactoring to implementation over removal. Only remove code if it is provably unused and not referenced anywhere in the system."
    ],
    "steps": [
      "Read the README.md in full, focusing on the Implementation Guide, Feature Table, and Best Practices.",
      "Review the @graph array for a map of all files, features, and relationships.",
      "For each file, check the 'todo', 'status', and 'observations' fields to identify what is needed for production-readiness.",
      "Use the 'mentalModels' section to select the best approach for the current coding or troubleshooting task.",
      "After editing any file, run get_errors and update the knowledge graph and README as needed.",
      "If a file is incomplete, follow the taskList for actionable steps to bring it to production-grade.",
      "If stuck, use mental models like Rubber Ducking, First Principles, or Feedback Loops to analyze and resolve the issue.",
      "Document all lessons learned and improvements in the notepad and changelog sections."
    ],
    "navigation": {
      "crossref": "Use 'relationships' to see which files import, use, or export others.",
      "byFile": "Use the @graph array to locate files, their features, status, and relationships.",
      "byFeature": "Search for features (e.g., vector search, CRUD, logging) in the 'features' fields.",
      "byType": "Find types and Zod schemas in each file and referenced in each file's 'exports'.",
      "byStatus": "Track progress using the 'status' and 'todo' fields for each entity.",
      "insightAccu": [
        "All Upstash modules must reference canonical types and Zod schemas for every entity (users, threads, messages, workflows, models, tools, logs, analytics, etc.) to ensure migration is seamless.",
        "Every API route and business logic layer must validate request/response types using upstashTypes.ts, referencing types/supabase.ts and Drizzle schemas as needed.",
        "Knowledge graph must be updated after every major edit, and all relationships, connections, and observations must be kept in sync with code changes.",
        "Fallback logic and error handling must be type-safe and tested for all entities, not just memory.",
        "Graph should be reviewed before each migration or integration to catch missing types, schemas, or relationships before CI/CD is enabled."
      ],
      "integrationNotes": "Integration must always be guided by the latest accumulated insights in 'insightAccu'. Before any migration or integration, review 'insightAccu' for missing types, schemas, or relationships. Adapt integration plans based on these insights to ensure all Upstash modules, API routes, and business logic are type-safe, robust, and ready for CI/CD."
    },
    "mentalModels": {
      "description": "A curated set of mental models for software development, debugging, and codebase improvement. Use these models to break down complex problems, verify assumptions, and drive continuous improvement. Each model below includes a summary, practical usage, and tips for applying it to the Upstash/Supabase/LibSQL integration context.",
      "models": [
        {
          "name": "Rubber Ducking",
          "summary": "Rubber ducking is the practice of explaining your code, logic, or problem step-by-step to an inanimate object or another person. This process forces you to clarify your thinking, often revealing hidden bugs or misunderstandings.",
          "application": "When stuck or debugging, write out your reasoning in the notepad, as comments, or in the knowledge graph. For Upstash/Supabase/LibSQL integration, use rubber ducking to walk through the data flow between adapters (e.g., supabase-adapter.ts to supabase.ts to memory.ts/db.ts/libsql.ts) and spot mismatches or missing logic.",
          "bestFor": ["Debugging complex bugs", "Explaining code to others", "Onboarding new contributors"],
          "howToUse": "Start by describing the problem or feature as if teaching it to someone new. For integration, narrate how a request flows from the API through supabase-adapter.ts, into supabase.ts, and down to memory.ts/db.ts/libsql.ts. Note any unclear steps or assumptions—these are likely sources of bugs or missing features."
        },
        {
          "name": "First Principles Thinking",
          "summary": "First principles thinking means breaking down a problem into its most basic elements and reasoning up from there, rather than relying on analogy or existing patterns.",
          "application": "Use for architectural decisions, refactoring, or when existing solutions are insufficient. For Upstash/Supabase/LibSQL, break down the requirements for memory, vector, and logging into their core primitives, then design the integration from scratch, ensuring each adapter and backend is used optimally.",
          "bestFor": ["Major refactors", "Designing new features", "Fixing systemic issues"],
          "howToUse": "Start by describing the problem or feature as if teaching it to someone new. For integration, narrate how a request flows from the API through supabase-adapter.ts, into supabase.ts, and down to memory.ts/db.ts/libsql.ts. Note any unclear steps or assumptions—these are likely sources of bugs or missing features."
        },
        {
          "name": "Occam's Razor",
          "summary": "Occam's Razor is the principle that the simplest solution is usually best. Avoid unnecessary complexity, especially in integration code.",
          "application": "When connecting Upstash, Supabase, and LibSQL, prefer the simplest, most direct data flow and fallback logic. Only add complexity if it is justified by requirements.",
          "bestFor": ["Refactoring", "API design", "Performance tuning"],
          "howToUse": "Review integration code for unnecessary indirection or abstraction. Simplify wherever possible, and document why any complexity is required."
        },
        {
          "name": "Mindmaps & Hill Charts",
          "summary": "Mindmaps and hill charts are visual tools for mapping out dependencies, progress, and relationships. They are invaluable for onboarding and integration planning.",
          "application": "Use mindmaps to visualize how supabase-adapter.ts, supabase.ts, memory.ts, db.ts, and libsql.ts connect and interact. Use hill charts to track progress on integration and testing.",
          "bestFor": ["Project planning", "Onboarding", "Dependency analysis"],
          "howToUse": "Draw a diagram showing the flow of data and control between all adapters and backends. Update as the architecture evolves."
        },
        {
          "name": "Parkinson's Law",
          "summary": "Parkinson's Law states that work expands to fill the time available. Set clear deadlines and constraints to keep integration work focused and efficient.",
          "application": "Timebox integration tasks (e.g., connecting supabase-adapter.ts to supabase.ts and memory.ts) to avoid endless refactoring or scope creep.",
          "bestFor": ["Sprint planning", "Bugfixes", "Feature delivery"],
          "howToUse": "Set a deadline for each integration milestone. If a task is taking too long, review for unnecessary complexity or blockers."
        },
        {
          "name": "Lean Startup",
          "summary": "Lean Startup is about building, measuring, and learning quickly. For integrations, ship small, test, and iterate.",
          "application": "For Upstash/Supabase/LibSQL, implement the minimal integration first (e.g., basic CRUD from supabase-adapter.ts to supabase.ts to memory.ts), then add features and fallback logic incrementally.",
          "bestFor": ["Prototyping", "New features", "Continuous delivery"],
          "howToUse": "Start with a working MVP for the integration. Add tests and features in small increments, validating each step."
        }
      ],
      "usageNotes": "For Upstash/Supabase/LibSQL integration, always map out the relationships between supabase-adapter.ts, supabase.ts, memory.ts, db.ts, and libsql.ts. Use the above models to guide design, debugging, and onboarding. Document integration points and lessons learned in the knowledge graph."
    },
    "reasoningTools": {
      "description": "A curated set of advanced reasoning, analysis, and quality tools for dynamic problem-solving, debugging, collaboration, and code health. Each tool provides a systematic approach to breaking down, analyzing, and solving problems, and can be used alongside mental models for continuous improvement.",
      "tools": [
        {
          "name": "sequentialthinking",
          "summary": "A tool for dynamic and reflective problem-solving through thoughts. Each thought can build on, question, or revise previous insights as understanding deepens.",
          "purpose": "Analyze problems through a flexible, evolving thinking process."
        },
        {
          "name": "debuggingapproach",
          "summary": "A tool for applying systematic debugging approaches to solve technical issues. Supports binary search, reverse engineering, divide and conquer, backtracking, cause elimination, and program slicing.",
          "purpose": "Identify and resolve issues using structured debugging methods."
        },
        {
          "name": "collaborativereasoning",
          "summary": "A tool for simulating expert collaboration with diverse perspectives. Helps coordinate multiple viewpoints for complex problems.",
          "purpose": "Enable structured collaborative reasoning and perspective integration."
        },
        {
          "name": "decisionframework",
          "summary": "A tool for structured decision analysis and rational choice. Supports multiple frameworks, probability estimates, and value judgments.",
          "purpose": "Systematically evaluate options, criteria, and outcomes."
        },
        {
          "name": "metacognitivemonitoring",
          "summary": "A tool for systematic self-monitoring of knowledge and reasoning quality. Tracks knowledge boundaries, claim certainty, and reasoning biases.",
          "purpose": "Enable metacognitive assessment across domains and tasks."
        },
        {
          "name": "scientificmethod",
          "summary": "A tool for applying formal scientific reasoning to questions and problems. Guides through hypothesis testing, variable identification, prediction, and evidence evaluation.",
          "purpose": "Enforce structured scientific reasoning and hypothesis testing."
        },
        {
          "name": "structuredargumentation",
          "summary": "A tool for systematic dialectical reasoning and argument analysis. Facilitates creation, critique, and synthesis of competing arguments.",
          "purpose": "Analyze complex questions through formal argumentation structures."
        },
        {
          "name": "visualreasoning",
          "summary": "A tool for visual thinking, problem-solving, and communication. Enables creation and interpretation of diagrams, graphs, and visual representations.",
          "purpose": "Support visual problem-solving and communication."
        },
        {
          "name": "semanticsearch",
          "summary": "A tool for searching and relating concepts, code, and documentation using meaning and context rather than keywords.",
          "purpose": "Enable deep, context-aware search and navigation across the codebase and knowledge graph."
        },
        {
          "name": "codesmells",
          "summary": "A tool for detecting code smells, anti-patterns, and maintainability issues. Integrates with linting and static analysis.",
          "purpose": "Improve code quality and maintainability by identifying problematic patterns."
        }
      ]
    }
  },
  "taskList": {
    "completed": [
      "Created initial upstash.json knowledge graph with entities, features, and relationships."
    ],
    "current": [
      "For each file, remove all 'any' types and replace with precise types or Zod schemas.",
      "Replace all direct console statements with upstashLogger or equivalent.",
      "Ensure every file has comprehensive tests, docs, and usage examples.",
      "Add @upstash/query support for advanced search, streaming, and filtering where relevant.",
      "Update the knowledge graph and README after every significant change.",
      "For each incomplete file, follow the 'todo' and 'observations' fields for actionable next steps.",
      "Apply relevant mental models (see onboarding.mentalModels) to break down and solve each task.",
      "After every edit, run get_errors and update the knowledge graph accordingly.",
      "For diamond core files, always implement unused imports/types/vars if possible, and only remove if absolutely certain they are not needed."
    ],
    "longTerm": [
      "Incorporate new onboarding, semantic search, and mental model techniques as they emerge.",
      "Continuously improve type safety, logging, and test coverage across all modules.",
      "Expand the knowledge graph to include per-function and per-type nodes for even richer context.",
      "Automate knowledge graph updates via CI/CD and agent workflows.",
      "Develop and document custom mental models as the project evolves."
    ],
    "fileSpecific": {
      "agent-state-store.ts": [
        "Remove all any types.",
        "Remove all direct console statements, use upstashLogger.",
        "Add @upstash/query support for agent state search if needed.",
        "Add more robust error handling and type safety.",
        "Add tests for agent state operations."
      ],
      "vector-store.ts": [
        "Remove all direct console statements, use upstashLogger.",
        "Use precise types for metadata, results, and errors.",
        "Add @upstash/query integration for hybrid search, advanced filtering.",
        "Add more robust error handling and logging.",
        "Add tests for hybrid and filtered search."
      ],
      "upstash-logger.ts": [
        "Replace all any types with precise types.",
        "Remove unused types/vars.",
        "Remove all console statements, use upstashLogger only.",
        "Ensure all log entry parsing is type-safe.",
        "Add advanced log querying (e.g., by level, time range).",
        "Add tests for log streaming and retrieval."
      ],
      "redis-store.ts": [
        "Remove all any types.",
        "Remove unused @ts-expect-error.",
        "Use @upstash/query for advanced thread/message search (RediSearch, full-text, filters).",
        "Add more type-safe helpers for RediSearch results.",
        "Remove all direct console statements, use upstashLogger.",
        "Add tests for thread/message search and RediSearch integration."
      ],
      "supabase-adapter.ts": [
        "Fix: Property 'sql' does not exist on type 'Query' (update to use correct @upstash/query API).",
        "Remove unused importsv (Query), implement uuidv4.",
        "Add create/update/delete item support for full Supabase compatibility.",
        "Add more advanced query support (RediSearch, full-text, filters).",
        "Add more robust error handling and type safety.",
        "Add tests for all CRUD and query operations."
      ],
      "supabase-adapter-factory.ts": [
        "Remove all any types.",
        "implement all unused imports/vars.",
        "Add @upstash/query support for advanced table/vector operations.",
        "Add more robust error handling and type safety.",
        "Add tests for all factory-generated clients."
      ],
      "stream-processor.ts": [
        "Remove all any types.",
        "Remove all direct console statements, use upstashLogger.",
        "Remove unused imports/vars.",
        "Add @upstash/query support for streaming queries.",
        "Add more robust error handling and type safety.",
        "Add tests for streaming and batch processing."
      ],
      "memoryStore.ts": [
        "Remove all any types.",
        "Remove all direct console statements, use upstashLogger.",
        "Add @upstash/query support for advanced memory/thread/message search.",
        "Add more robust error handling and type safety.",
        "Add tests for memory operations and advanced search."
      ],
      "memory-processor.ts": [
        "Add @upstash/query support for streaming/semantic search if needed.",
        "Add tests for memory processing."
      ],
      "index.ts": [
        "Remove/replace all broken exports (see errors: missing exports from supabase-adapter).",
        "Ensure all exports are up-to-date and type-safe.",
        "Add documentation for new/advanced exports."
      ]
    },
    "completingAllFiles": [
      "For each file, ensure all 'any' types are replaced, all logging is via upstashLogger, and all unused imports/types/vars are either implemented or justified for removal.",
      "Every file must have up-to-date tests, documentation, and usage examples.",
      "All advanced search, streaming, and filtering features should use @upstash/query where possible.",
      "Knowledge graph and README must be updated after every significant change.",
      "Apply the most relevant mental models (see below) to each file's refactor, bugfix, or feature implementation."
    ]
  }
}
