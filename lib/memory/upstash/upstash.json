{
  "@context": [
    "https://schema.org",
    { "proj": "https://github.com/ssdeanx/ai-sdk-DM/ns#" },
    { "feature": "https://schema.org/hasFeature" }
  ],
  "@type": "Graph",
  "name": "Upstash Memory Adapter Knowledge Graph",
  "description": "Living knowledge graph for the /lib/memory/upstash folder, capturing entities (files, types, features), relationships, onboarding, navigation, and AI agent support. Upstash must handle ALL API logic and data for all entities, not just memory, and all business logic must be routed through Upstash-first APIs with fallback only.",
  "version": "1.0.0",
  "generatedAt": "2025-05-14T00:00:00Z",
  "@graph": [
    {
      "@id": "lib/memory/upstash/agent-state-store.ts",
      "@type": ["CodeFile"],
      "path": "lib/memory/upstash/agent-state-store.ts",
      "exports": ["saveAgentState", "loadAgentState", "listThreadAgentStates", "deleteAgentState", "deleteThreadAgentStates", "createAgentState", "getAllAgentStates", "AgentStateStoreError", "AgentStateSchema", "StoredAgentStateSchema"],
      "features": [
        "Agent state management in Redis",
        "Zod schema validation for agent state objects",
        "Error handling with custom error classes",
        "CRUD for agent state keyed by agent/thread",
        "Integration with upstashLogger for all errors and state changes",
        "Supports fallback to Supabase/LibSQL for agent state if Upstash unavailable"
      ],
      "types": ["AgentState", "StoredAgentState", "AgentStateStoreError"],
      "zodSchemas": ["AgentStateSchema", "StoredAgentStateSchema"],
      "consumers": ["memoryStore.ts", "index.ts", "API: /api/agent-state/*"],
      "dependencies": ["upstashClients.ts", "upstash-logger.ts", "upstashTypes.ts"],
      "testFiles": ["tests/upstash/agent-state-store.test.ts"],
      "docs": ["README.md#agent-state-store.ts"],
      "examples": ["How to save/load agent state for a thread"],
      "changelog": ["Initial implementation", "Added Zod validation", "Integrated upstashLogger", "Added fallback logic"],
      "todo": [
        "Remove all any types (see README)",
        "Remove all direct console statements, use upstashLogger",
        "Add @upstash/query support for agent state search if needed",
        "Add more robust error handling and type safety",
        "Add tests for agent state operations"
      ],
      "status": "incomplete",
      "observations": [
        "Type errors present (see get_errors)",
        "Direct console usage found",
        "No advanced search support yet",
        "Agent state is persisted in Upstash, with fallback to Supabase/LibSQL if unavailable",
        "API routes for agents/threads depend on this module for state management",
        "Directly depends on upstashTypes.ts for type safety and Zod validation.",
        "All agent state CRUD operations are logged via upstashLogger.",
        "Fallback to Supabase/LibSQL is triggered on Upstash errors.",
        "Should be tested with reasoningTools (debuggingapproach, metacognitivemonitoring) for robust error handling.",
        "Semantic search can be used to trace agent state usage across API routes.",
        "Code smells: Any direct console usage or 'any' types should be flagged and refactored.",
        "Integration with memoryStore.ts and index.ts is critical for system-wide agent state consistency.",
        "All changes should be reflected in the knowledge graph and README for traceability.",
        "@upstash/query can be used for advanced agent state search and analytics.",
        "RediSearch integration is possible for full-text and filtered agent state queries.",
        "All agent state changes should be observable via upstashLogger and analytics routes.",
        "Fallback logic must be tested for all CRUD/search paths, with logs for each failure mode.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of agent state flows, fallback triggers, and log analysis.",
        "Observability and analytics are critical for agent state debugging and system health monitoring.",
        "Semantic search can help map agent state usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "connections": [
        { "with": "memoryStore.ts", "purpose": "agent state CRUD and fallback integration" },
        { "with": "upstash-logger.ts", "purpose": "logging for all agent state ops" },
        { "with": "supabase-adapter.ts", "purpose": "fallback and compatibility for agent state" },
        { "with": "upstashTypes.ts", "purpose": "type safety and Zod validation for agent state" },
        { "with": "stream-processor.ts", "purpose": "streaming agent state changes for analytics and observability" },
        { "with": "tools.json", "purpose": "agent state analytics and tool execution logging" }
      ],
      "usageNotes": "Use for all agent state persistence. Always validate with Zod. Log all errors.",
      "onboarding": "See README.md for setup and usage. Ensure fallback logic is robust.",
      "navigation": "Imported by memoryStore.ts and index.ts.",
      "troubleshooting": "Check for type errors and missing logger usage.",
      "graphNotes": "Central node for agent state in Upstash graph.",
      "relationships": [
        { "type": "memory", "target": "memory" },
        { "type": "api-route", "target": "app/api/ai-sdk/agents" },
        { "type": "api-route", "target": "app/api/ai-sdk/threads" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "fallback", "target": "lib/memory/supabase.ts" }
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Rubber Ducking",
        "Inversion",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/index.ts",
      "@type": ["CodeFile"],
      "path": "lib/memory/upstash/index.ts",
      "exports": [
        "getRedisClient", "getVectorClient", "checkUpstashAvailability", "createRedisThread", "getRedisThreadById", "updateRedisThread", "listRedisThreads", "deleteRedisThread", "createRedisMessage", "getRedisMessageById", "getRedisMessagesByThreadId", "deleteRedisMessage", "upsertEmbeddings", "searchSimilarEmbeddings", "getEmbeddingsByIds", "deleteEmbeddingsByIds", "resetVectorIndex", "getVectorIndexInfo", "logInfo", "logWarn", "logError", "logDebug", "getLogs", "deleteLogs", "clearLogs", "saveAgentState", "loadAgentState", "listThreadAgentStates", "deleteAgentState", "deleteThreadAgentStates", "createAgentState", "getAllAgentStates", "MemoryProcessor", "MemoryProcessorError", "RedisClientError", "VectorClientError", "streamProcessor", "StreamProcessor", "StreamProcessorError", "getData", "getItemById", "createItem", "updateItem", "deleteItem", "vectorSearch", "upsertSupabaseVectors", "VectorDataSchema", "VectorSearchOptionsSchema", "createSupabaseClient"
      ],
      "features": [
        "Barrel export for Upstash memory module",
        "Exports all Upstash memory, vector, logging, and adapter utilities",
        "Centralizes all exports for easy import",
        "Ensures type safety and up-to-date exports"
      ],
      "consumers": ["lib/memory/memory.ts", "API: /api/memory/*"],
      "dependencies": [
        "agent-state-store.ts", "memory-processor.ts", "memoryStore.ts", "redis-store.ts", "stream-processor.ts", "supabase-adapter-factory.ts", "supabase-adapter.ts", "upstash-logger.ts", "upstashClients.ts", "upstashTypes.ts", "vector-store.ts"
      ],
      "testFiles": ["tests/upstash/index.test.ts"],
      "docs": ["README.md#index.ts"],
      "examples": ["How to import all Upstash memory features"],
      "changelog": ["Initial barrel export", "Added new exports as features grew"],
      "todo": [
        "Remove/replace all broken exports (see README errors)",
        "Ensure all exports are up-to-date and type-safe",
        "Add documentation for new/advanced exports"
      ],
      "status": "incomplete",
      "observations": [
        "Central export node for all Upstash memory features",
        "All API routes under app/api/ai-sdk/* import from here for memory/vector/logging/agent state ops",
        "Fallback to Supabase/LibSQL handled via supabase-adapter exports"
      ],
      "connections": [
        { "with": "agent-state-store.ts", "purpose": "barrel export for agent state operations" },
        { "with": "memory-processor.ts", "purpose": "barrel export for memory processing" },
        { "with": "memoryStore.ts", "purpose": "barrel export for memory CRUD" },
        { "with": "redis-store.ts", "purpose": "barrel export for Redis operations" },
        { "with": "stream-processor.ts", "purpose": "barrel export for streaming operations" },
        { "with": "supabase-adapter.ts", "purpose": "barrel export for Supabase fallback" },
        { "with": "upstash-logger.ts", "purpose": "barrel export for logging utilities" },
        { "with": "upstashClients.ts", "purpose": "barrel export for Upstash clients" },
        { "with": "upstashTypes.ts", "purpose": "barrel export for shared types and schemas" },
        { "with": "vector-store.ts", "purpose": "barrel export for vector operations" }
      ],
      "usageNotes": "Use this file to import any Upstash memory feature.",
      "onboarding": "Check README for export list and update policy.",
      "navigation": "Barrel for all Upstash memory files.",
      "troubleshooting": "If an export is missing, check this file and README.",
      "graphNotes": "Central export node.",
      "relationships": [
        { "type": "barrel", "target": "lib/memory/upstash/*" },
        { "type": "api-route", "target": "app/api/ai-sdk/*" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "consumer", "target": "lib/memory/memory.ts" },
        { "type": "consumer", "target": "app/api/ai-sdk/threads" },
        { "type": "consumer", "target": "app/api/ai-sdk/messages" },
        { "type": "consumer", "target": "app/api/ai-sdk/agents" },
        { "type": "consumer", "target": "app/api/ai-sdk/logs" },
        { "type": "consumer", "target": "app/api/ai-sdk/analytics" }
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Occam's Razor",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/redis-store.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/threads" },
        { "type": "api-route", "target": "app/api/ai-sdk/messages" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "fallback", "target": "lib/memory/supabase.ts" }
      ],
      "connections": [
        { "with": "memoryStore.ts", "purpose": "thread/message CRUD, search, and RediSearch" },
        { "with": "upstash-logger.ts", "purpose": "logging for all thread/message ops" },
        { "with": "supabase-adapter.ts", "purpose": "fallback and compatibility" }
      ],
      "observations": [
        "Handles thread/message CRUD for all entities, not just memory.",
        "Integrates with upstashLogger for all error and operation logging.",
        "Uses upstashTypes.ts for type safety and Zod validation.",
        "Fallback logic to Supabase/LibSQL must be tested for all CRUD/search paths.",
        "Should leverage reasoningTools (debuggingapproach, sequentialthinking) for troubleshooting complex data flows.",
        "Semantic search can help map thread/message relationships across the codebase.",
        "Code smells: Look for any direct console statements, unused types, or missing error handling.",
        "RediSearch and advanced filtering should be documented and tested for all entity types.",
        "@upstash/query can be used for advanced thread/message search and analytics.",
        "RediSearch integration is possible for full-text and filtered thread/message queries.",
        "All thread/message changes should be observable via upstashLogger and analytics routes.",
        "Fallback logic must be tested for all CRUD/search paths, with logs for each failure mode.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of thread/message flows, fallback triggers, and log analysis.",
        "Observability and analytics are critical for thread/message debugging and system health monitoring.",
        "Semantic search can help map thread/message usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Inversion",
        "Occam's Razor",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/vector-store.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/embeddings" },
        { "type": "api-route", "target": "app/api/ai-sdk/vector-search" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "fallback", "target": "lib/memory/supabase.ts" }
      ],
      "connections": [
        { "with": "memoryStore.ts", "purpose": "embedding storage/search for all entities" },
        { "with": "upstash-logger.ts", "purpose": "logging for vector ops" },
        { "with": "supabase-adapter.ts", "purpose": "fallback and compatibility" },
        { "with": "memory-processor.ts", "purpose": "semantic/streaming search for all entities" }
      ],
      "observations": [
        "Central node for all vector/embedding CRUD and search.",
        "All vector operations are logged via upstashLogger.",
        "Type safety enforced via upstashTypes.ts and Zod schemas.",
        "Fallback to Supabase/LibSQL for vector operations must be robust and tested.",
        "Should use reasoningTools (scientificmethod, decisionframework) for evaluating search/filtering strategies.",
        "Semantic search is essential for tracing embedding usage and debugging search results.",
        "Code smells: Any use of 'any' types, missing logging, or direct console statements should be flagged.",
        "Integration with memoryStore.ts and supabase-adapter.ts is key for end-to-end vector data flow.",
        "@upstash/query can be used for advanced vector search and analytics.",
        "RediSearch integration is possible for full-text and filtered vector queries.",
        "All vector changes should be observable via upstashLogger and analytics routes.",
        "Fallback logic must be tested for all CRUD/search paths, with logs for each failure mode.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of vector flows, fallback triggers, and log analysis.",
        "Observability and analytics are critical for vector debugging and system health monitoring.",
        "Semantic search can help map vector usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Inversion",
        "Lean Startup",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/upstash-logger.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" }
      ],
      "connections": [
        { "with": "agent-state-store.ts", "purpose": "logging for agent state ops" },
        { "with": "redis-store.ts", "purpose": "logging for thread/message ops" },
        { "with": "vector-store.ts", "purpose": "logging for vector ops" }
      ],
      "observations": [
        "All logging for Upstash modules is centralized here.",
        "Type safety and Zod validation are required for all log entries.",
        "Should be integrated with reasoningTools (metacognitivemonitoring, codesmells) for log quality and anomaly detection.",
        "Semantic search can be used to analyze log patterns and trace issues across modules.",
        "Code smells: Any direct console usage or missing log validation should be flagged.",
        "Advanced log querying and streaming should be documented and tested.",
        "@upstash/query can be used for advanced log search and analytics.",
        "All log changes should be observable via analytics routes.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of log flows, triggers, and analysis.",
        "Observability and analytics are critical for log debugging and system health monitoring.",
        "Semantic search can help map log usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "mentalModels": [
        "Feedback Loops",
        "Inversion",
        "Rubber Ducking",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/upstashClients.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/*" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" }
      ],
      "connections": [
        { "with": "redis-store.ts", "purpose": "client management for Redis" },
        { "with": "vector-store.ts", "purpose": "client management for VectorDB" },
        { "with": "supabase-adapter.ts", "purpose": "Upstash-first client selection and fallback" }
      ],
      "observations": [
        "Manages singleton clients for Redis and Vector, used by all Upstash modules.",
        "All client config is validated with Zod schemas from upstashTypes.ts.",
        "Should be tested with reasoningTools (debuggingapproach, metacognitivemonitoring) for connection reliability.",
        "Semantic search can help trace client usage and fallback logic across the codebase.",
        "Code smells: Any missing error handling, unused imports, or direct console statements should be flagged.",
        "Integration with supabase-adapter.ts and fallback logic is critical for reliability.",
        "@upstash/query can be used for advanced client search and analytics.",
        "All client changes should be observable via analytics routes.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of client flows, triggers, and analysis.",
        "Observability and analytics are critical for client debugging and system health monitoring.",
        "Semantic search can help map client usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Circle of Competence",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/upstashTypes.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/*" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "used-by", "target": "lib/memory/upstash/agent-state-store.ts" },
        { "type": "used-by", "target": "lib/memory/upstash/redis-store.ts" },
        { "type": "used-by", "target": "lib/memory/upstash/vector-store.ts" },
        { "type": "used-by", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "used-by", "target": "lib/memory/upstash/upstashClients.ts" }
      ],
      "connections": [
        { "with": "supabase-adapter.ts", "purpose": "type safety for fallback and all API routes" },
        { "with": "all API routes", "purpose": "request/response validation for all entities" }
      ],
      "observations": [
        "Canonical source for all shared types and Zod schemas for all entities.",
        "All API routes validate request/response types using these types/schemas.",
        "Must be expanded to cover all entities and business logic for full migration.",
        "Should be reviewed with reasoningTools (sequentialthinking, metacognitivemonitoring) for type coverage and gaps.",
        "Semantic search can be used to find all usages and dependencies on these types.",
        "Code smells: Any unused or duplicate types, or use of 'any', should be flagged and refactored.",
        "All changes must be reflected in the knowledge graph and README.",
        "@upstash/query can be used for advanced type search and analytics.",
        "All type changes should be observable via analytics routes.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of type flows, triggers, and analysis.",
        "Observability and analytics are critical for type debugging and system health monitoring.",
        "Semantic search can help map type usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Rubber Ducking",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/memoryStore.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/threads" },
        { "type": "api-route", "target": "app/api/ai-sdk/messages" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/redis-store.ts" },
        { "type": "uses", "target": "lib/memory/upstash/vector-store.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "fallback", "target": "lib/memory/supabase.ts" }
      ],
      "connections": [
        { "with": "index.ts", "purpose": "barrel export for all memory ops" },
        { "with": "app/api/ai-sdk/threads", "purpose": "thread CRUD for all entities" },
        { "with": "app/api/ai-sdk/messages", "purpose": "message CRUD for all entities" }
      ],
      "observations": [
        "Handles all memory CRUD for all entities, not just memory.",
        "Integrates with redis-store.ts and vector-store.ts for data operations.",
        "Fallback to Supabase/LibSQL must be robust and tested for all CRUD/search paths.",
        "Should use reasoningTools (debuggingapproach, decisionframework) for troubleshooting and migration planning.",
        "Semantic search can help map memory relationships and usage across the codebase.",
        "Code smells: Any direct console usage, missing error handling, or unused types should be flagged.",
        "Integration with index.ts and API routes is critical for system-wide memory consistency.",
        "@upstash/query can be used for advanced memory search and analytics.",
        "RediSearch integration is possible for full-text and filtered memory queries.",
        "All memory changes should be observable via upstashLogger and analytics routes.",
        "Fallback logic must be tested for all CRUD/search paths, with logs for each failure mode.",
        "Use reasoningTools (debuggingapproach, metacognitivemonitoring, codesmells) for troubleshooting and migration planning.",
        "Onboarding should include walkthroughs of memory flows, fallback triggers, and log analysis.",
        "Observability and analytics are critical for memory debugging and system health monitoring.",
        "Semantic search can help map memory usage and dependencies across the codebase.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Inversion",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/memory/upstash/stream-processor.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/streams" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" }
      ],
      "connections": [
        { "with": "index.ts", "purpose": "barrel export for streaming ops for all entities" }
      ],
      "observations": [
        "Provides streaming and batch processing utilities for all entities.",
        "Integrates with upstashClients.ts for Redis/Vector access.",
        "Should be tested with reasoningTools (sequentialthinking, scientificmethod) for performance and reliability.",
        "Semantic search can be used to trace streaming usage and performance bottlenecks.",
        "Code smells: Any missing error handling, direct console usage, or untested edge cases should be flagged.",
        "Integration with index.ts and API routes is important for streaming consistency.",
        "@upstash/query can be used for advanced streaming search and analytics.",
        "All streaming changes should be observable via analytics routes.",
        { "type": "fallback", "target": "lib/memory/supabase.ts" }
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Inversion",
        "Circle of Competence"
      ]
    },
    {
      "@id": "lib/memory/upstash/supabase-adapter-factory.ts",
      "relationships": [
        { "type": "api-route", "target": "app/api/ai-sdk/*" },
        { "type": "api-route", "target": "app/api/ai-sdk/dashboard" },
        { "type": "api-route", "target": "app/api/ai-sdk/system" },
        { "type": "api-route", "target": "app/api/ai-sdk/apps" },
        { "type": "api-route", "target": "app/api/ai-sdk/mdx" },
        { "type": "api-route", "target": "app/api/ai-sdk/settings" },
        { "type": "api-route", "target": "app/api/ai-sdk/observability" },
        { "type": "api-route", "target": "app/api/ai-sdk/content" },
        { "type": "api-route", "target": "app/api/ai-sdk/blog" },
        { "type": "api-route", "target": "app/api/ai-sdk/auth" },
        { "type": "api-route", "target": "app/api/ai-sdk/logs" },
        { "type": "api-route", "target": "app/api/ai-sdk/analytics" },
        { "type": "api-route", "target": "app/api/ai-sdk/users" },
        { "type": "api-route", "target": "app/api/ai-sdk/workflows" },
        { "type": "api-route", "target": "app/api/ai-sdk/models" },
        { "type": "api-route", "target": "app/api/ai-sdk/tools" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "fallback", "target": "lib/memory/supabase.ts" }
      ],
      "connections": [
        { "with": "supabase-adapter.ts", "purpose": "factory for fallback clients for all entities" }
      ],
      "observations": [
        "Factory for Supabase-compatible clients, used as fallback in all API routes and entities.",
        "Should be tested with reasoningTools (debuggingapproach, decisionframework) for client instantiation and fallback logic.",
        "Semantic search can help trace client creation and usage across modules.",
        "Code smells: Any missing error handling, unused imports, or direct console usage should be flagged.",
        "Integration with supabase-adapter.ts is essential for fallback reliability."
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Circle of Competence",
        "Mindmaps & Hill Charts"
      ]
    },
    {
      "@id": "lib/middleware.ts",
      "@type": ["CodeFile"],
      "path": "lib/middleware.ts",
      "exports": [
        "RequestMiddleware", "ResponseMiddleware", "createMiddleware", "createCachingMiddleware", "createLoggingMiddleware", "createReasoningMiddleware", "createSimulationMiddleware", "createDefaultSettingsMiddleware", "createMiddlewareFromOptions", "createContextInjectionMiddleware", "createContentFilteringMiddleware", "createErrorHandlingMiddleware", "createRequestResponseMiddlewareFromOptions", "createCompleteMiddleware"
      ],
      "features": [
        "Composable and type-safe middleware factories for AI SDK and API routes",
        "Caching, logging, reasoning extraction, simulation, default settings, context injection, content filtering, error handling",
        "LRU cache for response caching, stream simulation for cached results",
        "Request/response middleware for context injection, filtering, and error handling",
        "Integration-ready for Upstash-backed API and memory routes"
      ],
      "types": ["RequestMiddleware", "ResponseMiddleware", "LanguageModelV1Middleware"],
      "consumers": [
        "lib/ai-sdk-integration.ts", "lib/ai-sdk-tracing.ts", "lib/ai.ts", "lib/ai-integration.ts", "lib/tracing.ts", "lib/langfuse-integration.ts"
      ],
      "dependencies": ["zod", "LRUCache", "ReadableStream", "TransformStream"],
      "testFiles": [],
      "docs": ["https://ai-sdk.dev/cookbook/next/caching-middleware", "README.md#middleware.ts"],
      "examples": ["How to add caching/logging/reasoning middleware to an API route"],
      "changelog": ["Initial implementation", "Added caching, logging, and reasoning extraction middleware", "Added request/response middleware for context injection and error handling"],
      "todo": [
        "Add Upstash-backed cache provider for distributed caching",
        "Integrate upstashLogger for all error and operation logging",
        "Add tests for all middleware types and edge cases",
        "Document Upstash integration patterns for caching and logging"
      ],
      "status": "incomplete",
      "observations": [
        "Middleware enables composable, type-safe enhancements for all AI SDK and API routes.",
        "Caching middleware can be extended to use Upstash as a distributed cache for multi-instance deployments.",
        "All logging should use upstashLogger for observability and analytics.",
        "Reasoning extraction and simulation middleware can be used for advanced debugging and LLM evaluation.",
        "Request/response middleware can inject context, filter content, and handle errors for all API routes.",
        "Integration with Upstash memory and logging modules is recommended for production deployments.",
        "Should be reviewed with reasoningTools (sequentialthinking, debuggingapproach, codesmells) for middleware coverage and gaps.",
        "Onboarding should include examples of Upstash-backed caching and logging middleware.",
        "All changes must be reflected in the knowledge graph and README for traceability."
      ],
      "connections": [
        { "with": "upstash-logger.ts", "purpose": "logging for all middleware errors and operations" },
        { "with": "upstashClients.ts", "purpose": "potential Upstash cache client integration" },
        { "with": "upstashTypes.ts", "purpose": "type safety for middleware options and cache entries" }
      ],
      "usageNotes": "Use to compose caching, logging, and reasoning middleware for all AI SDK and API routes. Prefer Upstash for distributed cache/logging in production.",
      "onboarding": "See README.md and ai-sdk.dev/cookbook/next/caching-middleware for usage and integration patterns.",
      "navigation": "Imported by all core AI SDK and tracing modules.",
      "troubleshooting": "Check for missing Upstash integration and logger usage.",
      "graphNotes": "Central node for middleware composition in Upstash/AI SDK graph.",
      "relationships": [
        { "type": "uses", "target": "lib/memory/upstash/upstash-logger.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashClients.ts" },
        { "type": "uses", "target": "lib/memory/upstash/upstashTypes.ts" },
        { "type": "api-route", "target": "app/api/ai-sdk/*" }
      ],
      "mentalModels": [
        "First Principles Thinking",
        "Feedback Loops",
        "Sequential Thinking",
        "Rubber Ducking"
      ]
    },
    {
      "@id": "onboarding:get-library-docs",
      "@type": ["OnboardingTool", "DocumentationTool"],
      "name": "get-library-docs",
      "description": "Fetches up-to-date documentation for a library or npm package using a Context7-compatible library ID. Use after resolving the library ID with resolve-library-id. Supports topic-focused queries (e.g., 'connection', 'query', 'vector search').",
      "usage": "1. Use resolve-library-id to get the Context7-compatible ID for a package (e.g., @upstash/redis). 2. Use get-library-docs with the resolved ID and an optional topic to fetch the latest docs. 3. Integrate official usage, setup, and advanced patterns into your Upstash modules.",
      "examples": [
        "resolve-library-id: '@upstash/redis' => 'upstash/redis'",
        "get-library-docs: { context7CompatibleLibraryID: 'upstash/redis', topic: 'connection' }"
      ],
      "bestPractices": "Always use get-library-docs before implementing or updating Upstash features to ensure you follow the latest best practices and avoid deprecated patterns.",
      "related": ["resolve-library-id"]
    },
    {
      "@id": "onboarding:resolve-library-id",
      "@type": ["OnboardingTool", "DocumentationTool"],
      "name": "resolve-library-id",
      "description": "Resolves a general npm package name into a Context7-compatible library ID required for get-library-docs. Always use this before fetching docs for a new package.",
      "usage": "Call resolve-library-id with the npm package name (e.g., '@upstash/redis'). Use the returned ID with get-library-docs.",
      "examples": [
        "resolve-library-id: '@upstash/redis' => 'upstash/redis'"
      ],
      "bestPractices": "Always resolve the library ID before fetching docs to ensure you get the correct and most up-to-date documentation.",
      "related": ["get-library-docs"]
    },
    {
      "@id": "onboarding:git_files",
      "@type": ["OnboardingTool", "RepositoryTool"],
      "name": "git_files",
      "description": "Fetches the content of specific files from a GitHub repository. Use this to retrieve code, configuration, or documentation from any repo you have access to.",
      "usage": "Call git_files with owner (e.g., 'ssdeanx'), repo name, and file paths. Optionally specify a branch.",
      "examples": [
        "git_files: { owner: 'ssdeanx', repo: 'ai-sdk-DM', file_paths: ['README.md'] }"
      ],
      "bestPractices": "Use git_files to pull in reference implementations, configuration, or docs from your own or public repos for onboarding, migration, or troubleshooting.",
      "related": ["git_summary", "git_tree"]
    },
    {
      "@id": "onboarding:git_summary",
      "@type": ["OnboardingTool", "RepositoryTool"],
      "name": "git_summary",
      "description": "Gets a summary of a GitHub repository, including files, token count, and README summary. Use this to quickly understand the structure and purpose of a repo.",
      "usage": "Call git_summary with owner (e.g., 'ssdeanx') and repo name. Optionally specify a branch.",
      "examples": [
        "git_summary: { owner: 'ssdeanx', repo: 'ai-sdk-DM' }"
      ],
      "bestPractices": "Use git_summary for onboarding, code review, or when planning integrations/migrations.",
      "related": ["git_files", "git_tree"]
    },
    {
      "@id": "onboarding:git_tree",
      "@type": ["OnboardingTool", "RepositoryTool"],
      "name": "git_tree",
      "description": "Gets the tree structure of a GitHub repository. Use this to map out the file/folder structure for onboarding, migration, or code search.",
      "usage": "Call git_tree with owner (e.g., 'ssdeanx') and repo name. Optionally specify a branch.",
      "examples": [
        "git_tree: { owner: 'ssdeanx', repo: 'ai-sdk-DM' }"
      ],
      "bestPractices": "Use git_tree to visualize repo structure and plan code navigation or migration.",
      "related": ["git_files", "git_summary"]
    },
    {
      "@id": "onboarding:tool-list",
      "@type": ["OnboardingTool", "Reference"],
      "name": "Available Tools for Upstash Integration and Project Automation",
      "description": "A list of tool IDs available for documentation management, code analysis, project context, and terminal interaction. Use these tools for onboarding, automation, and troubleshooting in the Upstash memory adapter and related modules.",
      "tools": [
        "add_documentation",
        "update_documentation",
        "think",
        "open_project",
        "read_context",
        "get_chunk_count",
        "set_profile",
        "get_profile_context",
        "generate_outline",
        "search_documentation",
        "list_documentation",
        "get_library_docs",
        "resolve_library_id",
        "write_to_terminal",
        "read_terminal_output",
        "send_control_character"
      ],
      "usageNotes": "Use these tool IDs in automation, onboarding, and troubleshooting workflows. For codebase analysis, use read_context and get_chunk_count. For documentation, use add_documentation, update_documentation, search_documentation, and list_documentation. For terminal automation, use write_to_terminal, read_terminal_output, and send_control_character.",
      "examples": [
        "search_documentation: { query: 'upstash vector search' }",
        "add_documentation: { name: 'Upstash VectorDB', url: 'https://upstash.com/docs/vector' }",
        "read_context: { path: 'lib/memory/upstash/', fileTypes: 'ts', recursive: true }"
      ],
      "bestPractices": "Reference this list when building new onboarding flows, troubleshooting, or automating project tasks. Update this list as new tools become available."
    }
  ],
  "meta": {
    "source": "auto-generated from README.md, memory.json, and codebase as of 2025-05-14",
    "updateStrategy": "automated extraction and continuous update via CI/CD and AI agent workflows",
    "intendedUse": [
      "Continuous improvement and documentation enforcement"
    ],
    "diamondCore": "A diamond core file is one that is absolutely central to the Upstash memory system's integrity, reliability, and extensibility. Bugs or design flaws here have system-wide impact. These files require the highest level of review, testing, and documentation.",
    "backup": "LibSQL and Supabase are backup/fallback backends. All features must work with Upstash as primary, and degrade gracefully to backup if needed."
  },
  "onboarding": {
    "purpose": "This onboarding is for AI agents (and advanced human contributors). Its goal is to ensure robust, error-free, and continuously improving Upstash memory adapter development. All steps are designed for AI agent reliability, self-improvement, and persistent insight.",
    "audience": "AI agents (Copilot, LLMs, automated CI/CD bots)",
    "corePrinciples": [
      "Type safety and Zod validation are required for all modules.",
      "After every file edit, always use get_errors to check for errors before considering the task complete.",
      "All direct console statements must be replaced with upstashLogger or equivalent.",
      "Every file must have comprehensive tests, docs, and usage examples.",
      "Knowledge graph and README must be updated with every significant change.",
      "Unused imports, types, and variables in diamond core files must be implemented and used if possible, not removed unless absolutely certain they are dead code. Removing them can break critical system behavior.",
      "Use semantic/graph search and mental models for navigation, troubleshooting, and continuous improvement.",
      "Apply mental models (see 'mentalModels' section) to break down, analyze, and solve coding and architectural problems.",
      "Onboarding and troubleshooting should be agent-friendly, with step-by-step guidance and references to code, docs, and graph nodes.",
      "Continuous improvement: treat every error, warning, or TODO as a learning opportunity and update the knowledge graph accordingly.",
      "For diamond core files, always prefer refactoring to implementation over removal. Only remove code if it is provably unused and not referenced anywhere in the system."
    ],
    "steps": [
      "Read the README.md in full, focusing on the Implementation Guide, Feature Table, and Best Practices.",
      "Review the @graph array for a map of all files, features, and relationships.",
      "For each file, check the 'todo', 'status', and 'observations' fields to identify what is needed for production-readiness.",
      "Use the 'mentalModels' section to select the best approach for the current coding or troubleshooting task.",
      "After editing any file, run get_errors and update the knowledge graph and README as needed.",
      "If a file is incomplete, follow the taskList for actionable steps to bring it to production-grade.",
      "If stuck, use mental models like Rubber Ducking, First Principles, or Feedback Loops to analyze and resolve the issue.",
      "Document all lessons learned and improvements in the notepad and changelog sections."
    ],
    "navigation": {
      "crossref": "Use 'relationships' to see which files import, use, or export others.",
      "byFile": "Use the @graph array to locate files, their features, status, and relationships.",
      "byFeature": "Search for features (e.g., vector search, CRUD, logging) in the 'features' fields.",
      "byType": "Find types and Zod schemas in each file and referenced in each file's 'exports'.",
      "byStatus": "Track progress using the 'status' and 'todo' fields for each entity.",
      "insightAccu": [
        "All Upstash modules must reference canonical types and Zod schemas for every entity (users, threads, messages, workflows, models, tools, logs, analytics, etc.) to ensure migration is seamless.",
        "Every API route and business logic layer must validate request/response types using upstashTypes.ts, referencing types/supabase.ts and Drizzle schemas as needed.",
        "Knowledge graph must be updated after every major edit, and all relationships, connections, and observations must be kept in sync with code changes.",
        "Fallback logic and error handling must be type-safe and tested for all entities, not just memory.",
        "Graph should be reviewed before each migration or integration to catch missing types, schemas, or relationships before CI/CD is enabled."
      ],
      "integrationNotes": "Integration must always be guided by the latest accumulated insights in 'insightAccu'. Before any migration or integration, review 'insightAccu' for missing types, schemas, or relationships. Adapt integration plans based on these insights to ensure all Upstash modules, API routes, and business logic are type-safe, robust, and ready for CI/CD."
    },
    "mentalModels": {
      "description": "A curated set of mental models for software development, debugging, and codebase improvement. Use these models to break down complex problems, verify assumptions, and drive continuous improvement. Each model below includes a summary, practical usage, and tips for applying it to the Upstash/Supabase/LibSQL integration context.",
      "models": [
        {
          "name": "Rubber Ducking",
          "summary": "Rubber ducking is the practice of explaining your code, logic, or problem step-by-step to an inanimate object or another person. This process forces you to clarify your thinking, often revealing hidden bugs or misunderstandings.",
          "application": "When stuck or debugging, write out your reasoning in the notepad, as comments, or in the knowledge graph. For Upstash/Supabase/LibSQL integration, use rubber ducking to walk through the data flow between adapters (e.g., supabase-adapter.ts to supabase.ts to memory.ts/db.ts/libsql.ts) and spot mismatches or missing logic.",
          "bestFor": ["Debugging complex bugs", "Explaining code to others", "Onboarding new contributors"],
          "howToUse": "Start by describing the problem or feature as if teaching it to someone new. For integration, narrate how a request flows from the API through supabase-adapter.ts, into supabase.ts, and down to memory.ts/db.ts/libsql.ts. Note any unclear steps or assumptionsthese are likely sources of bugs or missing features."
        },
        {
          "name": "First Principles Thinking",
          "summary": "First principles thinking means breaking down a problem into its most basic elements and reasoning up from there, rather than relying on analogy or existing patterns.",
          "application": "Use for architectural decisions, refactoring, or when existing solutions are insufficient. For Upstash/Supabase/LibSQL, break down the requirements for memory, vector, and logging into their core primitives, then design the integration from scratch, ensuring each adapter and backend is used optimally.",
          "bestFor": ["Major refactors", "Designing new features", "Fixing systemic issues"],
          "howToUse": "Start by describing the problem or feature as if teaching it to someone new. For integration, narrate how a request flows from the API through supabase-adapter.ts, into supabase.ts, and down to memory.ts/db.ts/libsql.ts. Note any unclear steps or assumptionsthese are likely sources of bugs or missing features."
        },
        {
          "name": "Occam's Razor",
          "summary": "Occam's Razor is the principle that the simplest solution is usually best. Avoid unnecessary complexity, especially in integration code.",
          "application": "When connecting Upstash, Supabase, and LibSQL, prefer the simplest, most direct data flow and fallback logic. Only add complexity if it is justified by requirements.",
          "bestFor": ["Refactoring", "API design", "Performance tuning"],
          "howToUse": "Review integration code for unnecessary indirection or abstraction. Simplify wherever possible, and document why any complexity is required."
        },
        {
          "name": "Mindmaps & Hill Charts",
          "summary": "Mindmaps and hill charts are visual tools for mapping out dependencies, progress, and relationships. They are invaluable for onboarding and integration planning.",
          "application": "Use mindmaps to visualize how supabase-adapter.ts, supabase.ts, memory.ts, db.ts, and libsql.ts connect and interact. Use hill charts to track progress on integration and testing.",
          "bestFor": ["Project planning", "Onboarding", "Dependency analysis"],
          "howToUse": "Draw a diagram showing the flow of data and control between all adapters and backends. Update as the architecture evolves."
        },
        {
          "name": "Parkinson's Law",
          "summary": "Parkinson's Law states that work expands to fill the time available. Set clear deadlines and constraints to keep integration work focused and efficient.",
          "application": "Timebox integration tasks (e.g., connecting supabase-adapter.ts to supabase.ts and memory.ts) to avoid endless refactoring or scope creep.",
          "bestFor": ["Sprint planning", "Bugfixes", "Feature delivery"],
          "howToUse": "Set a deadline for each integration milestone. If a task is taking too long, review for unnecessary complexity or blockers."
        },
        {
          "name": "Lean Startup",
          "summary": "Lean Startup is about building, measuring, and learning quickly. For integrations, ship small, test, and iterate.",
          "application": "For Upstash/Supabase/LibSQL, implement the minimal integration first (e.g., basic CRUD from supabase-adapter.ts to supabase.ts to memory.ts), then add features and fallback logic incrementally.",
          "bestFor": ["Prototyping", "New features", "Continuous delivery"],
          "howToUse": "Start with a working MVP for the integration. Add tests and features in small increments, validating each step."
        }
      ],
      "usageNotes": "For Upstash/Supabase/LibSQL integration, always map out the relationships between supabase-adapter.ts, supabase.ts, memory.ts, db.ts, and libsql.ts. Use the above models to guide design, debugging, and onboarding. Document integration points and lessons learned in the knowledge graph."
    },
    "reasoningTools": {
      "description": "A curated set of advanced reasoning, analysis, and quality tools for dynamic problem-solving, debugging, collaboration, and code health. Each tool provides a systematic approach to breaking down, analyzing, and solving problems, and can be used alongside mental models for continuous improvement.",
      "tools": [
        {
          "name": "sequentialthinking",
          "summary": "A tool for dynamic and reflective problem-solving through thoughts. Each thought can build on, question, or revise previous insights as understanding deepens.",
          "purpose": "Analyze problems through a flexible, evolving thinking process."
        },
        {
          "name": "debuggingapproach",
          "summary": "A tool for applying systematic debugging approaches to solve technical issues. Supports binary search, reverse engineering, divide and conquer, backtracking, cause elimination, and program slicing.",
          "purpose": "Identify and resolve issues using structured debugging methods."
        },
        {
          "name": "collaborativereasoning",
          "summary": "A tool for simulating expert collaboration with diverse perspectives. Helps coordinate multiple viewpoints for complex problems.",
          "purpose": "Enable structured collaborative reasoning and perspective integration."
        },
        {
          "name": "decisionframework",
          "summary": "A tool for structured decision analysis and rational choice. Supports multiple frameworks, probability estimates, and value judgments.",
          "purpose": "Systematically evaluate options, criteria, and outcomes."
        },
        {
          "name": "metacognitivemonitoring",
          "summary": "A tool for systematic self-monitoring of knowledge and reasoning quality. Tracks knowledge boundaries, claim certainty, and reasoning biases.",
          "purpose": "Enable metacognitive assessment across domains and tasks."
        },
        {
          "name": "scientificmethod",
          "summary": "A tool for applying formal scientific reasoning to questions and problems. Guides through hypothesis testing, variable identification, prediction, and evidence evaluation.",
          "purpose": "Enforce structured scientific reasoning and hypothesis testing."
        },
        {
          "name": "structuredargumentation",
          "summary": "A tool for systematic dialectical reasoning and argument analysis. Facilitates creation, critique, and synthesis of competing arguments.",
          "purpose": "Analyze complex questions through formal argumentation structures."
        },
        {
          "name": "visualreasoning",
          "summary": "A tool for visual thinking, problem-solving, and communication. Enables creation and interpretation of diagrams, graphs, and visual representations.",
          "purpose": "Support visual problem-solving and communication."
        },
        {
          "name": "semanticsearch",
          "summary": "A tool for searching and relating concepts, code, and documentation using meaning and context rather than keywords.",
          "purpose": "Enable deep, context-aware search and navigation across the codebase and knowledge graph."
        },
        {
          "name": "codesmells",
          "summary": "A tool for detecting code smells, anti-patterns, and maintainability issues. Integrates with linting and static analysis.",
          "purpose": "Improve code quality and maintainability by identifying problematic patterns."
        }
      ]
    }
  },
  "taskList": {
    "completed": [
      "Created initial upstash.json knowledge graph with entities, features, and relationships."
    ],
    "current": [
      "For each file, remove all 'any' types and replace with precise types or Zod schemas.",
      "Replace all direct console statements with upstashLogger or equivalent.",
      "Ensure every file has comprehensive tests, docs, and usage examples.",
      "Add @upstash/query support for advanced search, streaming, and filtering where relevant.",
      "Update the knowledge graph and README after every significant change.",
      "For each incomplete file, follow the 'todo' and 'observations' fields for actionable next steps.",
      "Apply relevant mental models (see onboarding.mentalModels) to break down and solve each task.",
      "After every edit, run get_errors and update the knowledge graph accordingly.",
      "For diamond core files, always implement unused imports/types/vars if possible, and only remove if absolutely certain they are not needed."
    ],
    "longTerm": [
      "Incorporate new onboarding, semantic search, and mental model techniques as they emerge.",
      "Continuously improve type safety, logging, and test coverage across all modules.",
      "Expand the knowledge graph to include per-function and per-type nodes for even richer context.",
      "Automate knowledge graph updates via CI/CD and agent workflows.",
      "Develop and document custom mental models as the project evolves."
    ],
    "fileSpecific": {
      "agent-state-store.ts": [
        "Remove all any types.",
        "Replace all direct console statements with upstashLogger.",
        "Add @upstash/query support for agent state search if needed.",
        "Add more robust error handling and type safety.",
        "Add tests for agent state operations."
      ],
      "vector-store.ts": [
        "Remove all direct console statements, use upstashLogger.",
        "Use precise types for metadata, results, and errors.",
        "Add @upstash/query integration for hybrid search, advanced filtering.",
        "Add more robust error handling and logging.",
        "Add tests for hybrid and filtered search."
      ],
      "upstash-logger.ts": [
        "Replace all any types with precise types.",
        "Remove unused types/vars.",
        "Remove all console statements, use upstashLogger only.",
        "Ensure all log entry parsing is type-safe.",
        "Add advanced log querying (e.g., by level, time range).",
        "Add tests for log streaming and retrieval."
      ],
      "redis-store.ts": [
        "Remove all any types.",
        "Remove unused @ts-expect-error.",
        "Use @upstash/query for advanced thread/message search (RediSearch, full-text, filters).",
        "Add more type-safe helpers for RediSearch results.",
        "Remove all direct console statements, use upstashLogger.",
        "Add tests for thread/message search and RediSearch integration."
      ],
      "supabase-adapter.ts": [
        "Fix: Property 'sql' does not exist on type 'Query' (update to use correct @upstash/query API).",
        "Remove unused importsv (Query), implement uuidv4.",
        "Add create/update/delete item support for full Supabase compatibility.",
        "Add more advanced query support (RediSearch, full-text, filters).",
        "Add more robust error handling and type safety.",
        "Add tests for all CRUD and query operations."
      ],
      "supabase-adapter-factory.ts": [
        "Remove all any types.",
        "implement all unused imports/vars.",
        "Add @upstash/query support for advanced table/vector operations.",
        "Add more robust error handling and type safety.",
        "Add tests for all factory-generated clients."
      ],
      "stream-processor.ts": [
        "Remove all any types.",
        "Remove all direct console statements, use upstashLogger.",
        "Remove unused imports/vars.",
        "Add @upstash/query support for streaming queries.",
        "Add more robust error handling and type safety.",
        "Add tests for streaming and batch processing."
      ],
      "memoryStore.ts": [
        "Remove all any types.",
        "Remove all direct console statements, use upstashLogger.",
        "Add @upstash/query support for advanced memory/thread/message search.",
        "Add more robust error handling and type safety.",
        "Add tests for memory operations and advanced search."
      ],
      "memory-processor.ts": [
        "Add @upstash/query support for streaming/semantic search if needed.",
        "Add tests for memory processing."
      ],
      "index.ts": [
        "Remove/replace all broken exports (see errors: missing exports from supabase-adapter).",
        "Ensure all exports are up-to-date and type-safe.",
        "Add documentation for new/advanced exports."
      ]
    },
    "completingAllFiles": [
      "For each file, ensure all 'any' types are replaced, all logging is via upstashLogger, and all unused imports/types/vars are either implemented or justified for removal.",
      "Every file must have up-to-date tests, documentation, and usage examples.",
      "All advanced search, streaming, and filtering features should use @upstash/query where possible.",
      "Knowledge graph and README must be updated after every significant change.",
      "Apply the most relevant mental models (see below) to each file's refactor, bugfix, or feature implementation."
    ]
  }
}
