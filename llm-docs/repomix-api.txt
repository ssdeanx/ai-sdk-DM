This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/api
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
app/api/agentic/agents/route.ts
app/api/agentic/tools/execute/route.ts
app/api/agentic/tools/route.ts
app/api/agents/[id]/route.ts
app/api/agents/[id]/run/route.ts
app/api/agents/personas/scores/feedback/route.ts
app/api/agents/personas/scores/most-used/route.ts
app/api/agents/personas/scores/recommend/route.ts
app/api/agents/personas/scores/route.ts
app/api/agents/personas/scores/top/route.ts
app/api/agents/route.ts
app/api/ai-sdk/agents/[id]/route.ts
app/api/ai-sdk/agents/[id]/run/route.ts
app/api/ai-sdk/agents/route.ts
app/api/ai-sdk/apps/route.ts
app/api/ai-sdk/chat/route.ts
app/api/ai-sdk/crud/[table]/route.ts
app/api/ai-sdk/threads/[id]/messages/route.ts
app/api/ai-sdk/threads/[id]/route.ts
app/api/ai-sdk/threads/route.ts
app/api/ai-sdk/tools/execute/route.ts
app/api/ai-sdk/tools/route.ts
app/api/apps/[id]/route.ts
app/api/apps/route.ts
app/api/assistant/route.ts
app/api/auth/callback/admin-github/route.ts
app/api/auth/callback/github/route.ts
app/api/auth/signin/route.ts
app/api/auth/signup/route.ts
app/api/blog/[id]/route.ts
app/api/blog/route.ts
app/api/chat/ai-sdk/route.ts
app/api/chat/ai-sdk/threads/[id]/messages/route.ts
app/api/chat/ai-sdk/threads/[id]/route.ts
app/api/chat/ai-sdk/threads/route.ts
app/api/chat/route.ts
app/api/content/architecture/route.ts
app/api/content/code-examples/route.ts
app/api/content/cta/route.ts
app/api/content/features/route.ts
app/api/content/footer/route.ts
app/api/content/hero/route.ts
app/api/crud/[table]/route.ts
app/api/dashboard/activity/route.ts
app/api/dashboard/metrics/route.ts
app/api/dashboard/stats/route.ts
app/api/mdx/[id]/route.ts
app/api/mdx/route.ts
app/api/memory/config/route.ts
app/api/memory/upstash-adapter/route.ts
app/api/memory/upstash-config/route.ts
app/api/models/[id]/route.ts
app/api/models/route.ts
app/api/models/seed/route.ts
app/api/networks/[id]/agents/[agentId]/route.ts
app/api/networks/[id]/agents/route.ts
app/api/networks/[id]/route.ts
app/api/networks/route.ts
app/api/observability/costs/route.ts
app/api/observability/evaluations/route.ts
app/api/observability/metrics/route.ts
app/api/observability/performance/route.ts
app/api/observability/traces/route.ts
app/api/settings/route.ts
app/api/system/status/route.ts
app/api/threads/[id]/messages/route.ts
app/api/threads/[id]/route.ts
app/api/threads/[id]/summary/route.ts
app/api/threads/route.ts
app/api/tools/[id]/route.ts
app/api/tools/execute/route.ts
app/api/tools/route.ts
app/api/workflows/[id]/execute/route.ts
app/api/workflows/[id]/pause/route.ts
app/api/workflows/[id]/resume/route.ts
app/api/workflows/[id]/route.ts
app/api/workflows/[id]/steps/route.ts
app/api/workflows/route.ts

================================================================
Files
================================================================

================
File: app/api/agentic/tools/route.ts
================
import { NextResponse } from "next/server"
import { getToolkit, initializeToolkit } from "@/lib/agentic-integration"

// GET /api/agentic/tools - Get all available tools
export async function GET(request: Request) {
  try {
    // Initialize toolkit if not already initialized
    await initializeToolkit({
      googleApiKey: process.env.GOOGLE_API_KEY,
      // Add other API keys as needed
    })

    const toolkit = getToolkit()
    const tools = toolkit.getTools()

    return NextResponse.json({
      tools: Object.keys(tools).map((key) => ({
        name: key,
        description: tools[key].description,
        parameters: tools[key].parameters,
      })),
    })
  } catch (error) {
    console.error("Error fetching agentic tools:", error)
    return NextResponse.json({ error: "Failed to fetch agentic tools" }, { status: 500 })
  }
}

================
File: app/api/agents/[id]/route.ts
================
import { NextResponse } from "next/server"
import { getItemById, updateItem, deleteItem } from "@/lib/memory/supabase"
import type { Agent } from "@/types/agents"
import type { Model } from "@/types/models"
import type { Tool } from "@/types/tools"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const agent = await getItemById<Agent>("agents", id)

    if (!agent) {
      return NextResponse.json({ error: "Agent not found" }, { status: 404 })
    }

    // Get model information
    const model = await getItemById<Model>("models", agent.model_id)

    // Get tool information
    const tools = await Promise.all(
      agent.tool_ids.map(async (toolId) => {
        const tool = await getItemById<Tool>("tools", toolId)
        return tool ? tool.name : null
      }),
    ).then((toolNames) => toolNames.filter(Boolean) as string[])

    return NextResponse.json({
      ...agent,
      model: model?.name || "Unknown Model",
      tools,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const body = await request.json()

    // Format the data to match Supabase schema
    const updates: Partial<Agent> = {}
    if (body.name !== undefined) updates.name = body.name
    if (body.description !== undefined) updates.description = body.description
    if (body.modelId !== undefined) updates.model_id = body.modelId
    if (body.toolIds !== undefined) updates.tool_ids = body.toolIds
    if (body.systemPrompt !== undefined) updates.system_prompt = body.systemPrompt

    const agent = await updateItem<Agent>("agents", id, updates)

    if (!agent) {
      return NextResponse.json({ error: "Agent not found" }, { status: 404 })
    }

    // Get model information
    const model = await getItemById<Model>("models", agent.model_id)

    // Get tool information
    const tools = await Promise.all(
      agent.tool_ids.map(async (toolId) => {
        const tool = await getItemById<Tool>("tools", toolId)
        return tool ? tool.name : null
      }),
    ).then((toolNames) => toolNames.filter(Boolean) as string[])

    return NextResponse.json({
      ...agent,
      model: model?.name || "Unknown Model",
      tools,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const success = await deleteItem("agents", id)

    return NextResponse.json({
      success,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/agents/[id]/run/route.ts
================
import { NextResponse } from "next/server"
import { streamGoogleAI, generateGoogleAI } from "@/lib/google-ai"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { getLibSQLClient } from "@/lib/memory/libsql"
import { handleApiError } from "@/lib/api-error-handler"

export async function POST(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const { message, threadId: providedThreadId, stream = true } = await request.json()

    if (!message) {
      return NextResponse.json({ error: "Message is required" }, { status: 400 })
    }

    // Generate a thread ID if not provided
    const threadId = providedThreadId || crypto.randomUUID()

    // Get agent configuration from Supabase
    const supabase = getSupabaseClient()
    const { data: agent, error: agentError } = await supabase
      .from("agents")
      .select("*, models(*)")
      .eq("id", id)
      .single()

    if (agentError || !agent) {
      console.error("Error fetching agent:", agentError)
      return NextResponse.json({ error: "Agent not found" }, { status: 404 })
    }

    // Get agent's tools
    const { data: agentTools, error: toolsError } = await supabase
      .from("agent_tools")
      .select("tools(*)")
      .eq("agent_id", id)

    if (toolsError) {
      console.error("Error fetching agent tools:", toolsError)
    }

    // Format tools for AI SDK
    const tools = {}
    if (agentTools && agentTools.length > 0) {
      for (const { tools: tool } of agentTools) {
        if (tool && tool.name && tool.parameters_schema) {
          tools[tool.name] = {
            description: tool.description,
            parameters: JSON.parse(tool.parameters_schema),
          }
        }
      }
    }

    // Get conversation history from LibSQL
    const db = getLibSQLClient()
    const messagesResult = await db.execute({
      sql: `
        SELECT role, content, created_at
        FROM messages
        WHERE thread_id = ?
        ORDER BY created_at ASC
      `,
      args: [threadId],
    })

    // Format messages for AI SDK
    const messages = messagesResult.rows.map((row) => ({
      role: row.role,
      content: row.content,
    }))

    // Add system message if not present
    if (!messages.some((m) => m.role === "system")) {
      const systemPrompt = agent.system_prompt || `You are ${agent.name}, an AI assistant. ${agent.description || ""}`

      messages.unshift({
        role: "system",
        content: systemPrompt,
      })

      // Store system message in LibSQL
      await db.execute({
        sql: `
          INSERT INTO messages (thread_id, role, content, created_at)
          VALUES (?, ?, ?, datetime('now'))
        `,
        args: [threadId, "system", systemPrompt],
      })
    }

    // Add user message
    messages.push({
      role: "user",
      content: message,
    })

    // Store user message in LibSQL
    await db.execute({
      sql: `
        INSERT INTO messages (thread_id, role, content, created_at)
        VALUES (?, ?, ?, datetime('now'))
      `,
      args: [threadId, "user", message],
    })

    if (stream) {
      // Stream the response
      const result = await streamGoogleAI({
        modelId: agent.models.model_id,
        messages,
        temperature: agent.temperature || 0.7,
        maxTokens: agent.max_tokens,
        tools,
        apiKey: agent.models.api_key,
        baseURL: agent.models.base_url,
      })

      // Store the assistant's response in LibSQL when complete
      result.text.then(async (text) => {
        await db.execute({
          sql: `
            INSERT INTO messages (thread_id, role, content, created_at)
            VALUES (?, ?, ?, datetime('now'))
          `,
          args: [threadId, "assistant", text],
        })
      })

      return result.toDataStreamResponse({
        threadId,
        agentId: id,
      })
    } else {
      // Generate non-streaming response
      const result = await generateGoogleAI({
        modelId: agent.models.model_id,
        messages,
        temperature: agent.temperature || 0.7,
        maxTokens: agent.max_tokens,
        tools,
        apiKey: agent.models.api_key,
        baseURL: agent.models.base_url,
      })

      // Store the assistant's response in LibSQL
      await db.execute({
        sql: `
          INSERT INTO messages (thread_id, role, content, created_at)
          VALUES (?, ?, ?, datetime('now'))
        `,
        args: [threadId, "assistant", result.text],
      })

      return NextResponse.json({
        threadId,
        agentId: id,
        response: result.text,
      })
    }
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/agents/personas/scores/feedback/route.ts
================
/**
 * API route for persona feedback
 */

import { NextResponse } from 'next/server';
import { personaManager } from '@/lib/agents/personas/persona-manager';

/**
 * POST /api/agents/personas/scores/feedback
 * Record user feedback for a persona
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { personaId, rating, feedback } = body;
    
    if (!personaId || rating === undefined) {
      return NextResponse.json(
        { error: 'personaId and rating are required' },
        { status: 400 }
      );
    }
    
    // Ensure rating is between 0 and 1
    const normalizedRating = Math.max(0, Math.min(1, parseFloat(rating)));
    
    // Record feedback
    const updatedScore = await personaManager.recordUserFeedback(
      personaId,
      normalizedRating,
      feedback
    );
    
    return NextResponse.json({ success: true, score: updatedScore });
  } catch (error) {
    console.error('Error recording feedback:', error);
    return NextResponse.json(
      { error: 'Failed to record feedback' },
      { status: 500 }
    );
  }
}

================
File: app/api/agents/personas/scores/most-used/route.ts
================
/**
 * API route for most used personas
 */

import { NextResponse } from 'next/server';
import { personaManager } from '@/lib/agents/personas/persona-manager';

/**
 * GET /api/agents/personas/scores/most-used
 * Get most used personas
 */
export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const limitParam = url.searchParams.get('limit');
    const limit = limitParam ? parseInt(limitParam, 10) : 5;
    
    const mostUsedPersonas = await personaManager.getMostUsedPersonas(limit);
    
    return NextResponse.json(
      mostUsedPersonas.map(({ persona, score }) => ({
        persona: {
          id: persona.id,
          name: persona.name,
          description: persona.description
        },
        score
      }))
    );
  } catch (error) {
    console.error('Error fetching most used personas:', error);
    return NextResponse.json(
      { error: 'Failed to fetch most used personas' },
      { status: 500 }
    );
  }
}

================
File: app/api/agents/personas/scores/recommend/route.ts
================
/**
 * API route for persona recommendations
 */

import { NextResponse } from 'next/server';
import { personaManager } from '@/lib/agents/personas/persona-manager';

/**
 * POST /api/agents/personas/scores/recommend
 * Get a persona recommendation based on context
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { context } = body;
    
    if (!context) {
      return NextResponse.json(
        { error: 'context is required' },
        { status: 400 }
      );
    }
    
    // Get recommendation
    const recommendation = await personaManager.getPersonaRecommendation(context);
    
    if (!recommendation) {
      return NextResponse.json(
        { error: 'No suitable persona found' },
        { status: 404 }
      );
    }
    
    return NextResponse.json({
      persona: {
        id: recommendation.persona.id,
        name: recommendation.persona.name,
        description: recommendation.persona.description
      },
      score: recommendation.score,
      matchReason: recommendation.matchReason
    });
  } catch (error) {
    console.error('Error getting persona recommendation:', error);
    return NextResponse.json(
      { error: 'Failed to get persona recommendation' },
      { status: 500 }
    );
  }
}

================
File: app/api/agents/personas/scores/route.ts
================
/**
 * API routes for persona scores
 */

import { NextResponse } from 'next/server';
import { personaManager } from '@/lib/agents/personas/persona-manager';
import { personaScoreManager } from '@/lib/agents/personas/persona-score-manager';

/**
 * GET /api/agents/personas/scores
 * Get scores for all personas
 */
export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const personaId = url.searchParams.get('personaId');
    const sortBy = url.searchParams.get('sortBy') as 'usage_count' | 'success_rate' | 'overall_score' | undefined;
    const sortDirection = url.searchParams.get('sortDirection') as 'asc' | 'desc' | undefined;
    const limitParam = url.searchParams.get('limit');
    const limit = limitParam ? parseInt(limitParam, 10) : undefined;
    
    // If personaId is provided, get score for that specific persona
    if (personaId) {
      const { persona, score } = await personaManager.getPersonaWithScore(personaId);
      
      if (!persona) {
        return NextResponse.json(
          { error: 'Persona not found' },
          { status: 404 }
        );
      }
      
      return NextResponse.json({
        persona: {
          id: persona.id,
          name: persona.name,
          description: persona.description
        },
        score
      });
    }
    
    // Otherwise, get scores for all personas with optional sorting
    const scores = await personaScoreManager.getAllScores({
      sortBy,
      sortDirection,
      limit
    });
    
    // Get personas for each score
    const personaScores = await Promise.all(
      scores.map(async (score) => {
        const persona = await personaManager.getPersona(score.persona_id);
        return {
          score,
          persona: persona ? {
            id: persona.id,
            name: persona.name,
            description: persona.description
          } : null
        };
      })
    );
    
    return NextResponse.json(personaScores);
  } catch (error) {
    console.error('Error fetching persona scores:', error);
    return NextResponse.json(
      { error: 'Failed to fetch persona scores' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/agents/personas/scores
 * Update score for a persona
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { personaId, metrics } = body;
    
    if (!personaId) {
      return NextResponse.json(
        { error: 'personaId is required' },
        { status: 400 }
      );
    }
    
    // Check if persona exists
    const persona = await personaManager.getPersona(personaId);
    if (!persona) {
      return NextResponse.json(
        { error: 'Persona not found' },
        { status: 404 }
      );
    }
    
    // Update score
    const updatedScore = await personaManager.recordPersonaUsage(personaId, metrics || {});
    
    return NextResponse.json({
      persona: {
        id: persona.id,
        name: persona.name,
        description: persona.description
      },
      score: updatedScore
    });
  } catch (error) {
    console.error('Error updating persona score:', error);
    return NextResponse.json(
      { error: 'Failed to update persona score' },
      { status: 500 }
    );
  }
}

/**
 * GET /api/agents/personas/scores/top
 * Get top performing personas
 */
export async function GET_top(request: Request) {
  try {
    const url = new URL(request.url);
    const limitParam = url.searchParams.get('limit');
    const limit = limitParam ? parseInt(limitParam, 10) : 5;
    
    const topPersonas = await personaManager.getTopPerformingPersonas(limit);
    
    return NextResponse.json(
      topPersonas.map(({ persona, score }) => ({
        persona: {
          id: persona.id,
          name: persona.name,
          description: persona.description
        },
        score
      }))
    );
  } catch (error) {
    console.error('Error fetching top personas:', error);
    return NextResponse.json(
      { error: 'Failed to fetch top personas' },
      { status: 500 }
    );
  }
}

/**
 * GET /api/agents/personas/scores/most-used
 * Get most used personas
 */
export async function GET_mostUsed(request: Request) {
  try {
    const url = new URL(request.url);
    const limitParam = url.searchParams.get('limit');
    const limit = limitParam ? parseInt(limitParam, 10) : 5;
    
    const mostUsedPersonas = await personaManager.getMostUsedPersonas(limit);
    
    return NextResponse.json(
      mostUsedPersonas.map(({ persona, score }) => ({
        persona: {
          id: persona.id,
          name: persona.name,
          description: persona.description
        },
        score
      }))
    );
  } catch (error) {
    console.error('Error fetching most used personas:', error);
    return NextResponse.json(
      { error: 'Failed to fetch most used personas' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/agents/personas/scores/feedback
 * Record user feedback for a persona
 */
export async function POST_feedback(request: Request) {
  try {
    const body = await request.json();
    const { personaId, rating, feedback } = body;
    
    if (!personaId || rating === undefined) {
      return NextResponse.json(
        { error: 'personaId and rating are required' },
        { status: 400 }
      );
    }
    
    // Ensure rating is between 0 and 1
    const normalizedRating = Math.max(0, Math.min(1, parseFloat(rating)));
    
    // Record feedback
    const updatedScore = await personaManager.recordUserFeedback(
      personaId,
      normalizedRating,
      feedback
    );
    
    return NextResponse.json({ success: true, score: updatedScore });
  } catch (error) {
    console.error('Error recording feedback:', error);
    return NextResponse.json(
      { error: 'Failed to record feedback' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/agents/personas/scores/recommend
 * Get a persona recommendation based on context
 */
export async function POST_recommend(request: Request) {
  try {
    const body = await request.json();
    const { context } = body;
    
    if (!context) {
      return NextResponse.json(
        { error: 'context is required' },
        { status: 400 }
      );
    }
    
    // Get recommendation
    const recommendation = await personaManager.getPersonaRecommendation(context);
    
    if (!recommendation) {
      return NextResponse.json(
        { error: 'No suitable persona found' },
        { status: 404 }
      );
    }
    
    return NextResponse.json({
      persona: {
        id: recommendation.persona.id,
        name: recommendation.persona.name,
        description: recommendation.persona.description
      },
      score: recommendation.score,
      matchReason: recommendation.matchReason
    });
  } catch (error) {
    console.error('Error getting persona recommendation:', error);
    return NextResponse.json(
      { error: 'Failed to get persona recommendation' },
      { status: 500 }
    );
  }
}

================
File: app/api/agents/personas/scores/top/route.ts
================
/**
 * API route for top performing personas
 */

import { NextResponse } from 'next/server';
import { personaManager } from '@/lib/agents/personas/persona-manager';

/**
 * GET /api/agents/personas/scores/top
 * Get top performing personas
 */
export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const limitParam = url.searchParams.get('limit');
    const limit = limitParam ? parseInt(limitParam, 10) : 5;
    
    const topPersonas = await personaManager.getTopPerformingPersonas(limit);
    
    return NextResponse.json(
      topPersonas.map(({ persona, score }) => ({
        persona: {
          id: persona.id,
          name: persona.name,
          description: persona.description
        },
        score
      }))
    );
  } catch (error) {
    console.error('Error fetching top personas:', error);
    return NextResponse.json(
      { error: 'Failed to fetch top personas' },
      { status: 500 }
    );
  }
}

================
File: app/api/agents/route.ts
================
import { NextResponse } from "next/server"
import { getData, createItem, getItemById } from "@/lib/memory/supabase"
import type { Agent } from "@/types/agents"
import type { Model } from "@/types/models"
import type { Tool } from "@/types/tools"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request) {
  try {
    const url = new URL(request.url)
    const search = url.searchParams.get("search")
    const modelId = url.searchParams.get("modelId")

    let filters = {}
    if (search) {
      filters = { search }
    }
    if (modelId) {
      filters = { ...filters, model_id: modelId }
    }

    const agents = await getData<Agent>("agents", {
      filters,
      orderBy: { column: "created_at", ascending: false },
    })

    // Enhance agents with model and tool information
    const enhancedAgents = await Promise.all(
      agents.map(async (agent) => {
        // Get model information
        const model = await getItemById<Model>("models", agent.model_id)

        // Get tool information
        const tools = await Promise.all(
          agent.tool_ids.map(async (toolId) => {
            const tool = await getItemById<Tool>("tools", toolId)
            return tool ? tool.name : null
          }),
        ).then((toolNames) => toolNames.filter(Boolean) as string[])

        return {
          ...agent,
          model: model?.name || "Unknown Model",
          tools,
        }
      }),
    )

    return NextResponse.json({
      agents: enhancedAgents,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()

    // Validate request body
    if (!body.name || !body.description || !body.modelId) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }

    // Format the data to match Supabase schema
    const agentData = {
      name: body.name,
      description: body.description,
      model_id: body.modelId,
      tool_ids: body.toolIds || [],
      system_prompt: body.systemPrompt || null,
    }

    const agent = await createItem<Agent>("agents", agentData)

    // Enhance agent with model and tool information
    if (agent) {
      const model = await getItemById<Model>("models", agent.model_id)

      const tools = await Promise.all(
        agent.tool_ids.map(async (toolId) => {
          const tool = await getItemById<Tool>("tools", toolId)
          return tool ? tool.name : null
        }),
      ).then((toolNames) => toolNames.filter(Boolean) as string[])

      return NextResponse.json({
        ...agent,
        model: model?.name || "Unknown Model",
        tools,
      })
    }

    return NextResponse.json(
      {
        error: "Failed to create agent",
      },
      { status: 500 },
    )
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/ai-sdk/crud/[table]/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { getData, createItem, updateItem, deleteItem, TableName } from '@/lib/memory/supabase';

// Allowed tables for CRUD
const ALLOWED_TABLES = [
  'apps', 'models', 'settings', 'agents', 'tools', 'workflows', 'networks'
];

function getTableName(param: string): TableName {
  if (!ALLOWED_TABLES.includes(param)) {
    throw new Error('Table not allowed');
  }
  return param as TableName;
}

export async function GET(req: NextRequest, { params }: { params: { table: string } }) {
  try {
    const table = getTableName(params.table);
    const data = await getData(table);
    return NextResponse.json({ [table]: data });
  } catch (error) {
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 400 });
  }
}

export async function POST(req: NextRequest, { params }: { params: { table: string } }) {
  try {
    const table = getTableName(params.table);
    const body = await req.json();
    const now = new Date().toISOString();
    const item = await createItem(table, { ...body, created_at: now, updated_at: now });
    return NextResponse.json(item, { status: 201 });
  } catch (error) {
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 400 });
  }
}

export async function PUT(req: NextRequest, { params }: { params: { table: string } }) {
  try {
    const table = getTableName(params.table);
    const url = new URL(req.url);
    const id = url.pathname.split('/').pop();
    if (!id) return NextResponse.json({ error: 'Missing id' }, { status: 400 });
    const body = await req.json();
    const updated = await updateItem(table, id, { ...body, updated_at: new Date().toISOString() });
    if (!updated) return NextResponse.json({ error: 'Not found' }, { status: 404 });
    return NextResponse.json(updated);
  } catch (error) {
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 400 });
  }
}

export async function DELETE(req: NextRequest, { params }: { params: { table: string } }) {
  try {
    const table = getTableName(params.table);
    const url = new URL(req.url);
    const id = url.pathname.split('/').pop();
    if (!id) return NextResponse.json({ error: 'Missing id' }, { status: 400 });
    const result = await deleteItem(table, id);
    if (!result.success) return NextResponse.json({ error: 'Not found' }, { status: 404 });
    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 400 });
  }
}

================
File: app/api/apps/[id]/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    
    const supabase = getSupabaseClient()
    
    const { data, error } = await supabase.from("apps").select("*").eq("id", id).single()
    
    if (error) {
      if (error.code === "PGRST116") {
        return NextResponse.json({ error: "App not found" }, { status: 404 })
      }
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json(data)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const body = await request.json()
    
    // Validate required fields
    if (!body.name || !body.description || !body.type || !body.code) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }
    
    const supabase = getSupabaseClient()
    
    // Format the data to match Supabase schema
    const appData = {
      name: body.name,
      description: body.description,
      type: body.type,
      code: body.code,
      parameters_schema: body.parametersSchema || null,
      updated_at: new Date().toISOString(),
    }
    
    const { data, error } = await supabase.from("apps").update(appData).eq("id", id).select().single()
    
    if (error) {
      console.error("Error updating app:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json(data)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    
    const supabase = getSupabaseClient()
    
    const { error } = await supabase.from("apps").delete().eq("id", id)
    
    if (error) {
      console.error("Error deleting app:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json({ success: true })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/apps/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"

export interface App {
  id: string
  name: string
  description: string
  type: string
  code: string
  parameters_schema?: string
  created_at: string
  updated_at: string
}

export async function GET(request: Request) {
  try {
    const url = new URL(request.url)
    const type = url.searchParams.get("type")
    const search = url.searchParams.get("search")
    
    const supabase = getSupabaseClient()
    
    let query = supabase.from("apps").select("*")
    
    // Apply type filter if provided
    if (type) {
      query = query.eq("type", type)
    }
    
    // Apply search filter if provided
    if (search) {
      query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%`)
    }
    
    // Order by created_at descending
    query = query.order("created_at", { ascending: false })
    
    const { data, error } = await query
    
    if (error) {
      console.error("Error fetching apps:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json({
      apps: data || [],
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    
    // Validate required fields
    if (!body.name || !body.description || !body.type || !body.code) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }
    
    const supabase = getSupabaseClient()
    
    // Format the data to match Supabase schema
    const appData = {
      name: body.name,
      description: body.description,
      type: body.type,
      code: body.code,
      parameters_schema: body.parametersSchema || null,
    }
    
    const { data, error } = await supabase.from("apps").insert(appData).select().single()
    
    if (error) {
      console.error("Error creating app:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json(data)
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/assistant/route.ts
================
import { NextResponse } from "next/server";
import { AssistantResponse } from "ai";
import OpenAI from "openai";
import { createMemoryThread, saveMessage } from "@/lib/memory/memory";
import { createTrace, logEvent } from "@/lib/langfuse-integration";
import { handleApiError } from "@/lib/api-error-handler";
import { v4 as uuidv4 } from "uuid";

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(req: Request) {
  try {
    const { threadId, message } = await req.json();

    // Validate request
    if (!message || !message.content) {
      return NextResponse.json(
        { error: "Message content is required" },
        { status: 400 }
      );
    }

    // Create a trace for this assistant interaction
    const trace = await createTrace({
      name: "openai_assistant_interaction",
      userId: threadId || "anonymous",
      metadata: {
        messageContent: message.content,
      }
    });

    // Log the user message event
    if (trace?.id) {
      await logEvent({
        traceId: trace.id,
        name: "user_message",
        metadata: {
          role: "user",
          content: message.content,
          timestamp: new Date().toISOString()
        }
      });
    }

    return AssistantResponse({
      threadId,
      messageId: message.id,

      async process({ forwardStream, sendDataMessage }) {
        try {
          // Create a thread if needed
          const openaiThreadId = threadId ?? (await openai.beta.threads.create({})).id;
          
          // If this is a new thread, create a memory thread for persistence
          if (!threadId) {
            try {
              await createMemoryThread('OpenAI Assistant Chat', {
                metadata: {
                  source: 'openai-assistant',
                  openai_thread_id: openaiThreadId,
                  created_at: new Date().toISOString()
                }
              });
            } catch (error) {
              console.error('Error creating memory thread:', error);
            }
          }

          // Save user message to memory
          try {
            await saveMessage(
              openaiThreadId,
              'user',
              message.content,
              {
                count_tokens: true,
                metadata: {
                  source: 'openai-assistant',
                  timestamp: new Date().toISOString(),
                  message_id: message.id
                }
              }
            );
          } catch (error) {
            console.error('Error saving user message:', error);
          }

          // Add user message to thread
          await openai.beta.threads.messages.create(openaiThreadId, {
            role: 'user',
            content: message.content,
          });

          // Send initial status
          sendDataMessage({ type: 'status', status: 'started' });

          // Run the assistant
          let runResult = await forwardStream(
            openai.beta.threads.runs.createAndStream(openaiThreadId, {
              assistant_id: process.env.OPENAI_ASSISTANT_ID!,
            }),
          );

          // Handle tool calls if needed
          while (runResult.status === 'requires_action') {
            const toolCalls = runResult.required_action!.submit_tool_outputs.tool_calls;
            const tool_outputs = [];

            // Process each tool call
            for (const toolCall of toolCalls) {
              try {
                // Log tool call
                if (trace?.id) {
                  await logEvent({
                    traceId: trace.id,
                    name: "tool_call",
                    metadata: {
                      tool_call_id: toolCall.id,
                      tool_name: toolCall.function.name,
                      arguments: toolCall.function.arguments,
                      timestamp: new Date().toISOString()
                    }
                  });
                }

                // Execute the tool (in a real implementation, you would have a tool registry)
                let toolOutput;
                switch (toolCall.function.name) {
                  case 'get_current_weather':
                    toolOutput = await executeWeatherTool(JSON.parse(toolCall.function.arguments));
                    break;
                  case 'search_web':
                    toolOutput = await executeSearchTool(JSON.parse(toolCall.function.arguments));
                    break;
                  default:
                    toolOutput = { error: `Tool ${toolCall.function.name} not implemented` };
                }

                // Log tool result
                if (trace?.id) {
                  await logEvent({
                    traceId: trace.id,
                    name: "tool_result",
                    metadata: {
                      tool_call_id: toolCall.id,
                      tool_name: toolCall.function.name,
                      result: toolOutput,
                      timestamp: new Date().toISOString()
                    }
                  });
                }

                // Add to tool outputs
                tool_outputs.push({
                  tool_call_id: toolCall.id,
                  output: JSON.stringify(toolOutput),
                });
              } catch (error) {
                console.error(`Error executing tool ${toolCall.function.name}:`, error);
                tool_outputs.push({
                  tool_call_id: toolCall.id,
                  output: JSON.stringify({ error: `Error executing tool: ${error.message || 'Unknown error'}` }),
                });
              }
            }

            // Submit tool outputs
            runResult = await forwardStream(
              openai.beta.threads.runs.submitToolOutputsStream(
                openaiThreadId,
                runResult.id,
                { tool_outputs },
              ),
            );
          }

          // Get the assistant's response
          const messages = await openai.beta.threads.messages.list(openaiThreadId);
          const assistantMessages = messages.data.filter(msg => msg.role === 'assistant');
          
          if (assistantMessages.length > 0) {
            const latestMessage = assistantMessages[0];
            
            // Save assistant message to memory
            try {
              await saveMessage(
                openaiThreadId,
                'assistant',
                typeof latestMessage.content[0].text === 'object' 
                  ? latestMessage.content[0].text.value 
                  : JSON.stringify(latestMessage.content),
                {
                  count_tokens: true,
                  generate_embeddings: true,
                  metadata: {
                    source: 'openai-assistant',
                    timestamp: new Date().toISOString(),
                    message_id: latestMessage.id,
                    run_id: runResult.id
                  }
                }
              );
            } catch (error) {
              console.error('Error saving assistant message:', error);
            }
            
            // Log assistant message
            if (trace?.id) {
              await logEvent({
                traceId: trace.id,
                name: "assistant_message",
                metadata: {
                  role: "assistant",
                  content: typeof latestMessage.content[0].text === 'object' 
                    ? latestMessage.content[0].text.value 
                    : JSON.stringify(latestMessage.content),
                  timestamp: new Date().toISOString(),
                  message_id: latestMessage.id,
                  run_id: runResult.id
                }
              });
            }
          }

          // Send completion status
          sendDataMessage({ type: 'status', status: 'completed' });
        } catch (error) {
          console.error('Error in assistant process:', error);
          sendDataMessage({ 
            type: 'error', 
            error: error.message || 'Unknown error in assistant process' 
          });
        }
      },
    });
  } catch (error) {
    return handleApiError(error);
  }
}

// Mock tool implementations
async function executeWeatherTool(args: { location: string }) {
  // In a real implementation, this would call a weather API
  return {
    temperature: 72,
    unit: "fahrenheit",
    conditions: "Partly Cloudy",
    humidity: 45,
    windSpeed: 10,
    windUnit: "mph",
    windDirection: "NE"
  };
}

async function executeSearchTool(args: { query: string }) {
  // In a real implementation, this would call a search API
  return {
    results: [
      { title: "Search Result 1", url: "https://example.com/1", snippet: "This is the first search result." },
      { title: "Search Result 2", url: "https://example.com/2", snippet: "This is the second search result." }
    ]
  };
}

================
File: app/api/blog/[id]/route.ts
================
import { NextResponse } from "next/server"
import { getItemById, updateItem, deleteItem } from "@/lib/memory/supabase"
import type { BlogPost } from "@/types/blog"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const post = await getItemById<BlogPost>("blog_posts", id)

    if (!post) {
      return NextResponse.json({ error: "Blog post not found" }, { status: 404 })
    }

    return NextResponse.json(post)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const body = await request.json()

    // Format the data to match Supabase schema
    const updates: Partial<BlogPost> = {}
    if (body.title !== undefined) updates.title = body.title
    if (body.content !== undefined) updates.content = body.content
    if (body.excerpt !== undefined) updates.excerpt = body.excerpt
    if (body.author !== undefined) updates.author = body.author
    if (body.imageUrl !== undefined) updates.image_url = body.imageUrl
    if (body.tags !== undefined) updates.tags = body.tags
    if (body.featured !== undefined) updates.featured = body.featured

    const post = await updateItem<BlogPost>("blog_posts", id, updates)

    return NextResponse.json(post)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const success = await deleteItem("blog_posts", id)

    return NextResponse.json({
      success,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/blog/route.ts
================
import { NextResponse } from "next/server"
import { getData, createItem } from "@/lib/memory/supabase"
import type { BlogPost } from "@/types/blog"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request) {
  try {
    const url = new URL(request.url)
    const limit = url.searchParams.get("limit") ? Number.parseInt(url.searchParams.get("limit")!) : 10
    const offset = url.searchParams.get("offset") ? Number.parseInt(url.searchParams.get("offset")!) : 0
    const featured = url.searchParams.get("featured") === "true"
    const tag = url.searchParams.get("tag")

    let filters = {}
    if (featured) {
      filters = { featured: true }
    }
    if (tag) {
      filters = { ...filters, tag }
    }

    const posts = await getData<BlogPost>("blog_posts", {
      filters,
      limit,
      offset,
      orderBy: { column: "published_at", ascending: false },
    })

    return NextResponse.json({
      posts,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const {
      title,
      content,
      excerpt,
      author = "Admin",
      imageUrl = "/placeholder.svg?height=400&width=600",
      tags = "",
      featured = false,
    } = body

    if (!title || !content) {
      return NextResponse.json({ error: "Title and content are required" }, { status: 400 })
    }

    // Format the data to match Supabase schema
    const postData = {
      title,
      content,
      excerpt: excerpt || title.substring(0, 150),
      author,
      image_url: imageUrl,
      tags,
      featured,
      published_at: new Date().toISOString(),
    }

    const post = await createItem<BlogPost>("blog_posts", postData)

    return NextResponse.json(post)
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/content/architecture/route.ts
================
import { NextResponse } from "next/server"
import { getData } from "@/lib/memory/supabase"

export async function GET() {
  try {
    // Fetch architecture content from Supabase (assumes a 'content' table with type/category 'architecture')
    const content = await getData<any>("content", {
      filters: { type: "architecture" },
      orderBy: { column: "created_at", ascending: false },
      limit: 1,
    })
    if (!content || content.length === 0) {
      return NextResponse.json({ error: "No architecture content found" }, { status: 404 })
    }
    return NextResponse.json(content[0])
  } catch (error) {
    console.error("Error fetching architecture content:", error)
    return NextResponse.json({ error: "Failed to fetch architecture content" }, { status: 500 })
  }
}

================
File: app/api/content/code-examples/route.ts
================
import { NextResponse } from "next/server"
import { getData } from "@/lib/memory/supabase"

export async function GET() {
  try {
    // Fetch code examples from Supabase (assumes a 'content' table with type/category 'code-examples')
    const codeExamples = await getData<any>("content", {
      filters: { type: "code-examples" },
      orderBy: { column: "created_at", ascending: false },
    })
    if (!codeExamples || codeExamples.length === 0) {
      return NextResponse.json({ error: "No code examples found" }, { status: 404 })
    }
    return NextResponse.json(codeExamples)
  } catch (error) {
    console.error("Error fetching code examples:", error)
    return NextResponse.json({ error: "Failed to fetch code examples" }, { status: 500 })
  }
}

================
File: app/api/content/cta/route.ts
================
import { NextResponse } from "next/server"
import { getData } from "@/lib/memory/supabase"

export async function GET() {
  try {
    // Fetch CTA content from Supabase (assumes a 'content' table with type/category 'cta')
    const ctaContent = await getData<any>("content", {
      filters: { type: "cta" },
      orderBy: { column: "created_at", ascending: false },
      limit: 1,
    })
    if (!ctaContent || ctaContent.length === 0) {
      return NextResponse.json({ error: "No CTA content found" }, { status: 404 })
    }
    return NextResponse.json(ctaContent[0])
  } catch (error) {
    console.error("Error fetching CTA content:", error)
    return NextResponse.json({ error: "Failed to fetch CTA content" }, { status: 500 })
  }
}

================
File: app/api/content/features/route.ts
================
import { NextResponse } from "next/server"
import { getData } from "@/lib/memory/supabase"

export async function GET() {
  try {
    // Fetch features from Supabase (assumes a 'content' table with type/category 'features')
    const features = await getData<any>("content", {
      filters: { type: "features" },
      orderBy: { column: "created_at", ascending: false },
    })
    if (!features || features.length === 0) {
      return NextResponse.json({ error: "No features found" }, { status: 404 })
    }
    return NextResponse.json(features)
  } catch (error) {
    console.error("Error fetching features:", error)
    return NextResponse.json({ error: "Failed to fetch features" }, { status: 500 })
  }
}

================
File: app/api/content/footer/route.ts
================
import { NextResponse } from "next/server"
import { getData } from "@/lib/memory/supabase"

export async function GET() {
  try {
    // Fetch footer content from Supabase (assumes a 'content' table with type/category 'footer')
    const footerContent = await getData<any>("content", {
      filters: { type: "footer" },
      orderBy: { column: "created_at", ascending: false },
      limit: 1,
    })
    if (!footerContent || footerContent.length === 0) {
      return NextResponse.json({ error: "No footer content found" }, { status: 404 })
    }
    return NextResponse.json(footerContent[0])
  } catch (error) {
    console.error("Error fetching footer content:", error)
    return NextResponse.json({ error: "Failed to fetch footer content" }, { status: 500 })
  }
}

================
File: app/api/content/hero/route.ts
================
import { NextResponse } from "next/server"
import { getData } from "@/lib/memory/supabase"

export async function GET() {
  try {
    // Fetch hero content from Supabase (assumes a 'content' table with type/category 'hero')
    const heroContent = await getData<any>("content", {
      filters: { type: "hero" },
      orderBy: { column: "created_at", ascending: false },
      limit: 1,
    })
    if (!heroContent || heroContent.length === 0) {
      return NextResponse.json({ error: "No hero content found" }, { status: 404 })
    }
    return NextResponse.json(heroContent[0])
  } catch (error) {
    console.error("Error fetching hero content:", error)
    return NextResponse.json({ error: "Failed to fetch hero content" }, { status: 500 })
  }
}

================
File: app/api/dashboard/metrics/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"

export async function GET() {
  try {
    // Get Supabase client
    const supabase = getSupabaseClient()
    
    // In a real application, you would query your Supabase database
    // Here we're simulating the response for demonstration purposes
    
    // Check if we can connect to Supabase
    const { error: connectionError } = await supabase
      .from('models')
      .select('count')
      .limit(1)
      .single()
    
    if (connectionError) {
      console.error("Error connecting to Supabase:", connectionError)
      
      // Return mock data if we can't connect to Supabase
      return NextResponse.json({
        metrics: [
          {
            id: "1",
            cpu_usage: 42,
            memory_usage: 58,
            database_connections: 24,
            api_requests_per_minute: 78,
            average_response_time_ms: 320,
            active_users: 12,
            timestamp: new Date().toISOString()
          },
          {
            id: "2",
            cpu_usage: 38,
            memory_usage: 52,
            database_connections: 18,
            api_requests_per_minute: 65,
            average_response_time_ms: 290,
            active_users: 10,
            timestamp: new Date(Date.now() - 1000 * 60 * 5).toISOString() // 5 minutes ago
          },
          {
            id: "3",
            cpu_usage: 45,
            memory_usage: 60,
            database_connections: 22,
            api_requests_per_minute: 82,
            average_response_time_ms: 350,
            active_users: 14,
            timestamp: new Date(Date.now() - 1000 * 60 * 10).toISOString() // 10 minutes ago
          }
        ],
        isMockData: true
      })
    }
    
    // If we can connect, get real metrics data from the database
    const { data: metrics, error } = await supabase
      .from('system_metrics')
      .select('*')
      .order('timestamp', { ascending: false })
      .limit(10)
    
    if (error) {
      console.error("Error fetching metrics data:", error)
      throw error
    }
    
    return NextResponse.json({
      metrics: metrics || [],
      isMockData: false
    })
    
  } catch (error) {
    console.error("Error in dashboard metrics API:", error)
    
    // Return mock data in case of error
    return NextResponse.json({
      metrics: [
        {
          id: "1",
          cpu_usage: 42,
          memory_usage: 58,
          database_connections: 24,
          api_requests_per_minute: 78,
          average_response_time_ms: 320,
          active_users: 12,
          timestamp: new Date().toISOString()
        },
        {
          id: "2",
          cpu_usage: 38,
          memory_usage: 52,
          database_connections: 18,
          api_requests_per_minute: 65,
          average_response_time_ms: 290,
          active_users: 10,
          timestamp: new Date(Date.now() - 1000 * 60 * 5).toISOString() // 5 minutes ago
        },
        {
          id: "3",
          cpu_usage: 45,
          memory_usage: 60,
          database_connections: 22,
          api_requests_per_minute: 82,
          average_response_time_ms: 350,
          active_users: 14,
          timestamp: new Date(Date.now() - 1000 * 60 * 10).toISOString() // 10 minutes ago
        }
      ],
      isMockData: true
    })
  }
}

================
File: app/api/dashboard/stats/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"

export async function GET() {
  try {
    // Get Supabase client
    const supabase = getSupabaseClient()
    
    // In a real application, you would query your Supabase database
    // Here we're simulating the response for demonstration purposes
    
    // Check if we can connect to Supabase
    const { data: connectionTest, error: connectionError } = await supabase
      .from('models')
      .select('count')
      .limit(1)
      .single()
    
    if (connectionError) {
      console.error("Error connecting to Supabase:", connectionError)
      
      // Return mock data if we can't connect to Supabase
      return NextResponse.json({
        stats: [{
          agents: 12,
          models: 8,
          tools: 24,
          conversations: 156,
          networks: 5,
          workflows: 10
        }],
        isMockData: true
      })
    }
    
    // If we can connect, get real counts from the database
    const [
      { count: agentsCount },
      { count: modelsCount },
      { count: toolsCount },
      { count: conversationsCount }
    ] = await Promise.all([
      supabase.from('agents').select('count').single(),
      supabase.from('models').select('count').single(),
      supabase.from('tools').select('count').single(),
      supabase.from('conversations').select('count').single()
    ].map(promise => promise.catch(error => {
      console.error("Error fetching count:", error)
      return { count: 0 }
    })))
    
    return NextResponse.json({
      stats: [{
        agents: agentsCount || 0,
        models: modelsCount || 0,
        tools: toolsCount || 0,
        conversations: conversationsCount || 0
      }],
      isMockData: false
    })
    
  } catch (error) {
    console.error("Error in dashboard stats API:", error)
    
    // Return mock data in case of error
    return NextResponse.json({
      stats: [{
        agents: 12,
        models: 8,
        tools: 24,
        conversations: 156
      }],
      isMockData: true
    })
  }
}

================
File: app/api/mdx/[id]/route.ts
================
import { NextResponse } from "next/server"
import { getItemById, updateItem, deleteItem } from "@/lib/memory/supabase"
import type { MdxDocument } from "@/types/mdx"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const document = await getItemById<MdxDocument>("mdx_documents", id)

    if (!document) {
      return NextResponse.json({ error: "MDX document not found" }, { status: 404 })
    }

    return NextResponse.json(document)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const body = await request.json()

    // Format the data to match Supabase schema
    const updates: Partial<MdxDocument> = {}
    if (body.title !== undefined) updates.title = body.title
    if (body.content !== undefined) updates.content = body.content
    if (body.excerpt !== undefined) updates.excerpt = body.excerpt

    const document = await updateItem<MdxDocument>("mdx_documents", id, updates)

    return NextResponse.json(document)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const success = await deleteItem("mdx_documents", id)

    return NextResponse.json({
      success,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/mdx/route.ts
================
import { NextResponse } from "next/server"
import { getData, createItem } from "@/lib/memory/supabase"
import type { MdxDocument } from "@/types/mdx"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request) {
  try {
    const url = new URL(request.url)
    const limit = url.searchParams.get("limit") ? Number.parseInt(url.searchParams.get("limit")!) : 100
    const offset = url.searchParams.get("offset") ? Number.parseInt(url.searchParams.get("offset")!) : 0
    const userId = url.searchParams.get("userId") || null

    let filters = {}
    if (userId) {
      filters = { user_id: userId }
    }

    const documents = await getData<MdxDocument>("mdx_documents", {
      filters,
      limit,
      offset,
      orderBy: { column: "updated_at", ascending: false },
    })

    return NextResponse.json({
      documents,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { title, content, userId = "anonymous", excerpt = "" } = body

    if (!title || !content) {
      return NextResponse.json({ error: "Title and content are required" }, { status: 400 })
    }

    // Format the data to match Supabase schema
    const documentData = {
      title,
      content,
      excerpt: excerpt || title.substring(0, 100),
      user_id: userId,
    }

    const document = await createItem<MdxDocument>("mdx_documents", documentData)

    return NextResponse.json(document)
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/memory/config/route.ts
================
import { NextResponse } from 'next/server';
import { checkUpstashAvailability } from '@/lib/memory/upstash';
import { isMemoryAvailable, getMemoryProvider } from '@/lib/memory/factory';

/**
 * GET /api/memory/config
 * 
 * Returns the current memory provider configuration
 */
export async function GET() {
  try {
    // Get the configured memory provider
    const provider = getMemoryProvider();
    
    // Check if Upstash adapter should be used
    const useUpstashAdapter = process.env.USE_UPSTASH_ADAPTER === 'true';
    
    // Check if memory provider is available
    const isAvailable = await isMemoryAvailable();
    
    // Check Upstash availability if adapter is enabled
    let upstashAvailability = { redisAvailable: false, vectorAvailable: false };
    
    if (useUpstashAdapter || provider === 'upstash') {
      upstashAvailability = await checkUpstashAvailability();
    }
    
    return NextResponse.json({
      provider,
      useUpstashAdapter,
      isRedisAvailable: upstashAvailability.redisAvailable,
      isVectorAvailable: upstashAvailability.vectorAvailable,
      isReady: isAvailable,
      error: isAvailable ? undefined : 'Memory provider is not available'
    });
  } catch (error) {
    console.error('Error getting memory provider configuration:', error);
    
    return NextResponse.json(
      {
        provider: 'libsql', // Default to LibSQL
        useUpstashAdapter: false,
        isRedisAvailable: false,
        isVectorAvailable: false,
        isReady: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

================
File: app/api/memory/upstash-adapter/route.ts
================
import { NextResponse } from 'next/server';
import { createSupabaseClient } from '@/lib/memory/upstash/supabase-adapter-factory';
import { checkUpstashAvailability } from '@/lib/memory/upstash';

/**
 * GET /api/memory/upstash-adapter
 * 
 * Returns information about the Upstash adapter configuration
 */
export async function GET() {
  try {
    // Check if Upstash adapter is enabled
    const useUpstashAdapter = process.env.USE_UPSTASH_ADAPTER === 'true';
    
    if (!useUpstashAdapter) {
      return NextResponse.json(
        {
          enabled: false,
          error: 'Upstash adapter is not enabled'
        },
        { status: 400 }
      );
    }
    
    // Check Upstash availability
    const { redisAvailable, vectorAvailable } = await checkUpstashAvailability();
    
    if (!redisAvailable) {
      return NextResponse.json(
        {
          enabled: false,
          error: 'Upstash Redis is not available'
        },
        { status: 400 }
      );
    }
    
    return NextResponse.json({
      enabled: true,
      redisAvailable,
      vectorAvailable,
      adapterVersion: '1.0.0',
      features: {
        threads: true,
        messages: true,
        embeddings: vectorAvailable,
        storage: false
      }
    });
  } catch (error) {
    console.error('Error getting Upstash adapter configuration:', error);
    
    return NextResponse.json(
      {
        enabled: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/memory/upstash-adapter
 * 
 * Test the Upstash adapter by performing a simple operation
 */
export async function POST(request: Request) {
  try {
    // Check if Upstash adapter is enabled
    const useUpstashAdapter = process.env.USE_UPSTASH_ADAPTER === 'true';
    
    if (!useUpstashAdapter) {
      return NextResponse.json(
        {
          success: false,
          error: 'Upstash adapter is not enabled'
        },
        { status: 400 }
      );
    }
    
    // Create Supabase client with Upstash adapter
    const supabase = createSupabaseClient();
    
    // Perform a simple operation to test the adapter
    const testData = {
      id: 'test-' + Date.now(),
      name: 'Test Item',
      created_at: new Date().toISOString()
    };
    
    // Use a test table that won't affect production data
    const { data, error } = await supabase
      .from('_test_upstash_adapter')
      .insert([testData])
      .select()
      .single();
    
    if (error) {
      // If the table doesn't exist, that's okay - just return success
      if (error.code === '42P01') { // undefined_table
        return NextResponse.json({
          success: true,
          message: 'Upstash adapter is working (test table not available)'
        });
      }
      
      throw error;
    }
    
    return NextResponse.json({
      success: true,
      message: 'Upstash adapter is working',
      data
    });
  } catch (error) {
    console.error('Error testing Upstash adapter:', error);
    
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

================
File: app/api/memory/upstash-config/route.ts
================
import { NextResponse } from 'next/server';

/**
 * GET /api/memory/upstash-config
 * 
 * Returns the Upstash adapter configuration
 * This endpoint is safe to call from the client as it only returns
 * public URLs without tokens
 */
export async function GET() {
  try {
    // Check if Upstash adapter is enabled
    const useUpstashAdapter = process.env.USE_UPSTASH_ADAPTER === 'true';
    
    if (!useUpstashAdapter) {
      return NextResponse.json(
        {
          enabled: false,
          error: 'Upstash adapter is not enabled'
        },
        { status: 400 }
      );
    }
    
    // Get Upstash Redis URL (without token)
    const redisUrl = process.env.UPSTASH_REDIS_REST_URL;
    
    // Get Upstash Vector URL (without token)
    const vectorUrl = process.env.UPSTASH_VECTOR_REST_URL;
    
    // Check if QStash is configured
    const qstashEnabled = !!process.env.QSTASH_URL && !!process.env.QSTASH_TOKEN;
    
    return NextResponse.json({
      enabled: true,
      redisUrl,
      vectorUrl,
      qstashEnabled,
      // Do not include tokens in the response
    });
  } catch (error) {
    console.error('Error getting Upstash adapter configuration:', error);
    
    return NextResponse.json(
      {
        enabled: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

================
File: app/api/models/seed/route.ts
================
import { NextResponse } from "next/server";
import { seedDefaultModels } from "@/lib/services/model-service";
import { handleApiError } from "@/lib/api-error-handler";

/**
 * Seed default models from the model registry
 * @route POST /api/models/seed
 */
export async function POST(request: Request) {
  try {
    // Get provider from request body
    const body = await request.json();
    const { provider } = body;
    
    // Seed models
    const count = await seedDefaultModels(provider);
    
    return NextResponse.json({
      success: true,
      message: `Seeded ${count} models${provider ? ` for provider ${provider}` : ''}`,
      count
    });
  } catch (error) {
    return handleApiError(error);
  }
}

================
File: app/api/networks/[id]/agents/[agentId]/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"

export async function DELETE(
  request: Request,
  { params }: { params: { id: string; agentId: string } }
) {
  try {
    const { id, agentId } = params
    
    const supabase = getSupabaseClient()
    
    // Delete the network agent
    const { error: deleteError } = await supabase
      .from("network_agents")
      .delete()
      .eq("id", agentId)
      .eq("network_id", id)
    
    if (deleteError) {
      console.error("Error removing agent from network:", deleteError)
      return NextResponse.json({ error: deleteError.message }, { status: 500 })
    }
    
    // Update the agent count in the network
    const { data: network, error: networkError } = await supabase.rpc("decrement_network_agent_count", {
      network_id: id,
    })
    
    if (networkError) {
      console.error("Error updating network agent count:", networkError)
      // Don't return an error here, as the agent was successfully removed
    }
    
    return NextResponse.json({ success: true })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string; agentId: string } }
) {
  try {
    const { id, agentId } = params
    const body = await request.json()
    
    // Validate required fields
    if (!body.role) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }
    
    const supabase = getSupabaseClient()
    
    // Update the network agent
    const { data, error } = await supabase
      .from("network_agents")
      .update({ role: body.role, updated_at: new Date().toISOString() })
      .eq("id", agentId)
      .eq("network_id", id)
      .select()
      .single()
    
    if (error) {
      console.error("Error updating network agent:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json(data)
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/networks/[id]/agents/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"

export interface NetworkAgent {
  id: string
  network_id: string
  agent_id: string
  role: string
  created_at: string
  updated_at: string
}

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    
    const supabase = getSupabaseClient()
    
    // Get network agents with agent details
    const { data, error } = await supabase
      .from("network_agents")
      .select(`
        *,
        agents:agent_id (
          id,
          name,
          description
        )
      `)
      .eq("network_id", id)
    
    if (error) {
      console.error("Error fetching network agents:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json({
      agents: data || [],
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const body = await request.json()
    
    // Validate required fields
    if (!body.agentId || !body.role) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }
    
    const supabase = getSupabaseClient()
    
    // Format the data to match Supabase schema
    const networkAgentData = {
      network_id: id,
      agent_id: body.agentId,
      role: body.role,
    }
    
    // Start a transaction
    const { data: networkAgent, error: agentError } = await supabase
      .from("network_agents")
      .insert(networkAgentData)
      .select()
      .single()
    
    if (agentError) {
      console.error("Error adding agent to network:", agentError)
      return NextResponse.json({ error: agentError.message }, { status: 500 })
    }
    
    // Update the agent count in the network
    const { data: network, error: networkError } = await supabase.rpc("increment_network_agent_count", {
      network_id: id,
    })
    
    if (networkError) {
      console.error("Error updating network agent count:", networkError)
      // Don't return an error here, as the agent was successfully added
    }
    
    return NextResponse.json(networkAgent)
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/networks/[id]/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"
import type { Network } from "../route"

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    
    const supabase = getSupabaseClient()
    
    const { data, error } = await supabase.from("networks").select("*").eq("id", id).single()
    
    if (error) {
      if (error.code === "PGRST116") {
        return NextResponse.json({ error: "Network not found" }, { status: 404 })
      }
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json(data)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const body = await request.json()
    
    // Validate required fields
    if (!body.name || !body.description) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }
    
    const supabase = getSupabaseClient()
    
    // Format the data to match Supabase schema
    const networkData = {
      name: body.name,
      description: body.description,
      status: body.status || undefined,
      updated_at: new Date().toISOString(),
    }
    
    const { data, error } = await supabase.from("networks").update(networkData).eq("id", id).select().single()
    
    if (error) {
      console.error("Error updating network:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json(data)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    
    const supabase = getSupabaseClient()
    
    const { error } = await supabase.from("networks").delete().eq("id", id)
    
    if (error) {
      console.error("Error deleting network:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json({ success: true })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/networks/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"

export interface Network {
  id: string
  name: string
  description: string
  agent_count: number
  status: string
  created_at: string
  updated_at: string
}

export async function GET(request: Request) {
  try {
    const url = new URL(request.url)
    const status = url.searchParams.get("status")
    const search = url.searchParams.get("search")
    
    const supabase = getSupabaseClient()
    
    let query = supabase.from("networks").select("*")
    
    // Apply status filter if provided
    if (status) {
      query = query.eq("status", status)
    }
    
    // Apply search filter if provided
    if (search) {
      query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%`)
    }
    
    // Order by created_at descending
    query = query.order("created_at", { ascending: false })
    
    const { data, error } = await query
    
    if (error) {
      console.error("Error fetching networks:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json({
      networks: data || [],
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    
    // Validate required fields
    if (!body.name || !body.description) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }
    
    const supabase = getSupabaseClient()
    
    // Format the data to match Supabase schema
    const networkData = {
      name: body.name,
      description: body.description,
      agent_count: 0,
      status: body.status || "Active",
    }
    
    const { data, error } = await supabase.from("networks").insert(networkData).select().single()
    
    if (error) {
      console.error("Error creating network:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }
    
    return NextResponse.json(data)
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/observability/costs/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { createTrace, logEvent } from "@/lib/langfuse-integration"

/**
 * API route for fetching cost estimation data for observability dashboard
 * Provides cost metrics for different AI models
 */
export async function GET(request: Request) {
  try {
    // Get URL parameters
    const { searchParams } = new URL(request.url)
    const limit = parseInt(searchParams.get('limit') || '50')
    const timeRange = searchParams.get('timeRange') || '30d'
    const modelId = searchParams.get('modelId')
    
    // Create a trace for this API call
    const trace = await createTrace({
      name: "observability_costs_api",
      metadata: {
        limit,
        timeRange,
        modelId,
        timestamp: new Date().toISOString()
      }
    })
    
    // Log API call event
    if (trace?.id) {
      await logEvent({
        traceId: trace.id,
        name: "api_call",
        metadata: {
          endpoint: "/api/observability/costs",
          method: "GET",
          params: { limit, timeRange, modelId },
          timestamp: new Date().toISOString()
        }
      })
    }
    
    // Get Supabase client
    const supabase = getSupabaseClient()
    
    // Convert time range to milliseconds
    const timeRangeMap: Record<string, number> = {
      '1h': 60 * 60 * 1000,
      '6h': 6 * 60 * 60 * 1000,
      '24h': 24 * 60 * 60 * 1000,
      '7d': 7 * 24 * 60 * 60 * 1000,
      '30d': 30 * 24 * 60 * 60 * 1000
    }
    
    const timeInMs = timeRangeMap[timeRange] || timeRangeMap['30d']
    const startTime = new Date(Date.now() - timeInMs).toISOString()
    
    // If modelId is provided, get specific model cost data
    if (modelId) {
      try {
        // Try to connect to Supabase and get real data
        const { data: costData, error } = await supabase
          .from('model_costs')
          .select('*, time_series_data(*)')
          .eq('modelId', modelId)
          .single()
        
        if (error) {
          console.warn("Falling back to mock data due to Supabase error:", error)
          return getMockModelCost(modelId, timeRange)
        }
        
        if (costData) {
          return NextResponse.json({
            costData,
            isMockData: false
          })
        }
        
        // If no cost data found, return mock data
        return getMockModelCost(modelId, timeRange)
      } catch (error) {
        console.warn("Error connecting to Supabase:", error)
        return getMockModelCost(modelId, timeRange)
      }
    }
    
    // Otherwise, get list of model costs
    try {
      // Try to get real cost data from Supabase
      const { data: costData, error } = await supabase
        .from('model_costs')
        .select('*')
        .gte('startDate', startTime)
        .order('startDate', { ascending: false })
        .limit(limit)
      
      if (error) {
        console.warn("Falling back to mock cost data due to Supabase error:", error)
        return getMockModelCosts(timeRange)
      }
      
      if (costData && costData.length > 0) {
        return NextResponse.json({
          costData,
          isMockData: false
        })
      }
      
      // If no cost data found, return mock data
      return getMockModelCosts(timeRange)
    } catch (error) {
      console.warn("Error connecting to Supabase:", error)
      return getMockModelCosts(timeRange)
    }
  } catch (error) {
    console.error("Error in observability costs API:", error)
    
    // Return error response
    return NextResponse.json({
      error: "Failed to fetch cost data",
      message: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 })
  }
}

/**
 * Generate mock cost data for a specific model
 */
function getMockModelCost(modelId: string, timeRange: string) {
  const mockModels = {
    "gemini-1.5-pro": { provider: "google", displayName: "Gemini 1.5 Pro", costPerInputToken: 0.00001, costPerOutputToken: 0.00002 },
    "gpt-4o": { provider: "openai", displayName: "GPT-4o", costPerInputToken: 0.00001, costPerOutputToken: 0.00003 },
    "claude-3-opus": { provider: "anthropic", displayName: "Claude 3 Opus", costPerInputToken: 0.000015, costPerOutputToken: 0.000075 },
    "gemini-1.5-flash": { provider: "google", displayName: "Gemini 1.5 Flash", costPerInputToken: 0.000003, costPerOutputToken: 0.000006 },
    "gpt-3.5-turbo": { provider: "openai", displayName: "GPT-3.5 Turbo", costPerInputToken: 0.0000015, costPerOutputToken: 0.000002 }
  }
  
  const model = mockModels[modelId as keyof typeof mockModels] || { 
    provider: "unknown", 
    displayName: modelId, 
    costPerInputToken: 0.00001,
    costPerOutputToken: 0.00002
  }
  
  // Generate random usage data
  const totalInputTokens = Math.floor(Math.random() * 10000000) + 1000000
  const totalOutputTokens = Math.floor(totalInputTokens * 0.3)
  const totalCost = (totalInputTokens * model.costPerInputToken) + (totalOutputTokens * model.costPerOutputToken)
  const avgCostPerRequest = totalCost / (Math.floor(Math.random() * 10000) + 1000)
  
  // Generate time series data
  const timeSeriesData = []
  const days = timeRange === '7d' ? 7 : 30
  const now = new Date()
  
  for (let i = 0; i < days; i++) {
    const date = new Date(now)
    date.setDate(date.getDate() - (days - i))
    
    const dailyInputTokens = Math.floor(Math.random() * (totalInputTokens / days * 1.5)) + (totalInputTokens / days * 0.5)
    const dailyOutputTokens = Math.floor(dailyInputTokens * 0.3)
    const dailyCost = (dailyInputTokens * model.costPerInputToken) + (dailyOutputTokens * model.costPerOutputToken)
    
    timeSeriesData.push({
      date: date.toISOString(),
      cost: dailyCost,
      inputTokens: dailyInputTokens,
      outputTokens: dailyOutputTokens,
      requests: Math.floor(Math.random() * 1000) + 100
    })
  }
  
  // Calculate daily average and projected monthly cost
  const dailyAverage = timeSeriesData.reduce((sum, day) => sum + day.cost, 0) / timeSeriesData.length
  const projectedMonthlyCost = dailyAverage * 30
  
  return NextResponse.json({
    costData: {
      modelId,
      provider: model.provider,
      displayName: model.displayName,
      costPerInputToken: model.costPerInputToken,
      costPerOutputToken: model.costPerOutputToken,
      timeSeriesData,
      metrics: {
        totalInputTokens,
        totalOutputTokens,
        totalCost,
        avgCostPerRequest,
        dailyAverage,
        projectedMonthlyCost
      }
    },
    isMockData: true
  })
}

/**
 * Generate a list of mock model costs
 */
function getMockModelCosts(timeRange: string) {
  const mockModels = [
    { modelId: "gemini-1.5-pro", provider: "google", displayName: "Gemini 1.5 Pro", costPerInputToken: 0.00001, costPerOutputToken: 0.00002 },
    { modelId: "gpt-4o", provider: "openai", displayName: "GPT-4o", costPerInputToken: 0.00001, costPerOutputToken: 0.00003 },
    { modelId: "claude-3-opus", provider: "anthropic", displayName: "Claude 3 Opus", costPerInputToken: 0.000015, costPerOutputToken: 0.000075 },
    { modelId: "gemini-1.5-flash", provider: "google", displayName: "Gemini 1.5 Flash", costPerInputToken: 0.000003, costPerOutputToken: 0.000006 },
    { modelId: "gpt-3.5-turbo", provider: "openai", displayName: "GPT-3.5 Turbo", costPerInputToken: 0.0000015, costPerOutputToken: 0.000002 }
  ]
  
  const costData = mockModels.map(model => {
    // Generate random usage data
    const totalInputTokens = Math.floor(Math.random() * 10000000) + 1000000
    const totalOutputTokens = Math.floor(totalInputTokens * 0.3)
    const totalCost = (totalInputTokens * model.costPerInputToken) + (totalOutputTokens * model.costPerOutputToken)
    const avgCostPerRequest = totalCost / (Math.floor(Math.random() * 10000) + 1000)
    
    // Generate time series data
    const timeSeriesData = []
    const days = timeRange === '7d' ? 7 : 30
    const now = new Date()
    
    for (let i = 0; i < days; i++) {
      const date = new Date(now)
      date.setDate(date.getDate() - (days - i))
      
      const dailyInputTokens = Math.floor(Math.random() * (totalInputTokens / days * 1.5)) + (totalInputTokens / days * 0.5)
      const dailyOutputTokens = Math.floor(dailyInputTokens * 0.3)
      const dailyCost = (dailyInputTokens * model.costPerInputToken) + (dailyOutputTokens * model.costPerOutputToken)
      
      timeSeriesData.push({
        date: date.toISOString(),
        cost: dailyCost,
        inputTokens: dailyInputTokens,
        outputTokens: dailyOutputTokens,
        requests: Math.floor(Math.random() * 1000) + 100
      })
    }
    
    // Calculate daily average and projected monthly cost
    const dailyAverage = timeSeriesData.reduce((sum, day) => sum + day.cost, 0) / timeSeriesData.length
    const projectedMonthlyCost = dailyAverage * 30
    
    return {
      modelId: model.modelId,
      provider: model.provider,
      displayName: model.displayName,
      costPerInputToken: model.costPerInputToken,
      costPerOutputToken: model.costPerOutputToken,
      timeSeriesData,
      metrics: {
        totalInputTokens,
        totalOutputTokens,
        totalCost,
        avgCostPerRequest,
        dailyAverage,
        projectedMonthlyCost
      }
    }
  })
  
  return NextResponse.json({
    costData,
    isMockData: true
  })
}

================
File: app/api/observability/evaluations/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { createTrace, logEvent } from "@/lib/langfuse-integration"

/**
 * API route for fetching model evaluation data for observability dashboard
 * Provides evaluation metrics for different AI models
 */
export async function GET(request: Request) {
  try {
    // Get URL parameters
    const { searchParams } = new URL(request.url)
    const limit = parseInt(searchParams.get('limit') || '50')
    const timeRange = searchParams.get('timeRange') || '24h'
    const modelId = searchParams.get('modelId')
    
    // Create a trace for this API call
    const trace = await createTrace({
      name: "observability_evaluations_api",
      metadata: {
        limit,
        timeRange,
        modelId,
        timestamp: new Date().toISOString()
      }
    })
    
    // Log API call event
    if (trace?.id) {
      await logEvent({
        traceId: trace.id,
        name: "api_call",
        metadata: {
          endpoint: "/api/observability/evaluations",
          method: "GET",
          params: { limit, timeRange, modelId },
          timestamp: new Date().toISOString()
        }
      })
    }
    
    // Get Supabase client
    const supabase = getSupabaseClient()
    
    // Convert time range to milliseconds
    const timeRangeMap: Record<string, number> = {
      '1h': 60 * 60 * 1000,
      '6h': 6 * 60 * 60 * 1000,
      '24h': 24 * 60 * 60 * 1000,
      '7d': 7 * 24 * 60 * 60 * 1000,
      '30d': 30 * 24 * 60 * 60 * 1000
    }
    
    const timeInMs = timeRangeMap[timeRange] || timeRangeMap['24h']
    const startTime = new Date(Date.now() - timeInMs).toISOString()
    
    // If modelId is provided, get specific model evaluation
    if (modelId) {
      try {
        // Try to connect to Supabase and get real data
        const { data: evaluation, error } = await supabase
          .from('model_evaluations')
          .select('*, metrics(*), examples(*)')
          .eq('modelId', modelId)
          .single()
        
        if (error) {
          console.warn("Falling back to mock data due to Supabase error:", error)
          return getMockModelEvaluation(modelId)
        }
        
        if (evaluation) {
          return NextResponse.json({
            evaluation,
            isMockData: false
          })
        }
        
        // If no evaluation found, return mock data
        return getMockModelEvaluation(modelId)
      } catch (error) {
        console.warn("Error connecting to Supabase:", error)
        return getMockModelEvaluation(modelId)
      }
    }
    
    // Otherwise, get list of model evaluations
    try {
      // Try to get real evaluations from Supabase
      const { data: evaluations, error } = await supabase
        .from('model_evaluations')
        .select('*')
        .gte('evaluationDate', startTime)
        .order('evaluationDate', { ascending: false })
        .limit(limit)
      
      if (error) {
        console.warn("Falling back to mock evaluations due to Supabase error:", error)
        return getMockModelEvaluations()
      }
      
      if (evaluations && evaluations.length > 0) {
        return NextResponse.json({
          evaluations,
          isMockData: false
        })
      }
      
      // If no evaluations found, return mock data
      return getMockModelEvaluations()
    } catch (error) {
      console.warn("Error connecting to Supabase:", error)
      return getMockModelEvaluations()
    }
  } catch (error) {
    console.error("Error in observability evaluations API:", error)
    
    // Return error response
    return NextResponse.json({
      error: "Failed to fetch evaluations",
      message: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 })
  }
}

/**
 * Generate a mock model evaluation for a specific model ID
 */
function getMockModelEvaluation(modelId: string) {
  const mockModels = {
    "gemini-1.5-pro": { provider: "google", displayName: "Gemini 1.5 Pro", version: "2024-06-01" },
    "gpt-4o": { provider: "openai", displayName: "GPT-4o", version: "2024-05-15" },
    "claude-3-opus": { provider: "anthropic", displayName: "Claude 3 Opus", version: "2024-04-20" },
    "gemini-1.5-flash": { provider: "google", displayName: "Gemini 1.5 Flash", version: "2024-06-01" },
    "gpt-4-turbo": { provider: "openai", displayName: "GPT-4 Turbo", version: "2024-03-10" }
  }
  
  const model = mockModels[modelId as keyof typeof mockModels] || { 
    provider: "unknown", 
    displayName: modelId, 
    version: "unknown" 
  }
  
  const metricNames = [
    { name: "accuracy", description: "Correctness of responses" },
    { name: "relevance", description: "Relevance to the query" },
    { name: "coherence", description: "Logical flow and consistency" },
    { name: "conciseness", description: "Brevity and clarity" },
    { name: "harmlessness", description: "Avoidance of harmful content" }
  ]
  
  // Generate random metrics
  const metrics = metricNames.map(metric => ({
    name: metric.name,
    description: metric.description,
    value: Math.random() * 0.4 + 0.6, // Between 0.6 and 1.0
    threshold: 0.7,
    weight: 1.0 / metricNames.length
  }))
  
  // Calculate overall score
  const overallScore = metrics.reduce((sum, metric) => sum + (metric.value * metric.weight), 0)
  
  // Generate example evaluations
  const examples = Array.from({ length: 5 }, (_, i) => {
    const exampleScores: Record<string, number> = {}
    metricNames.forEach(metric => {
      exampleScores[metric.name] = Math.random() * 0.4 + 0.6 // Between 0.6 and 1.0
    })
    
    return {
      id: `example-${i + 1}`,
      input: `Example query ${i + 1} for testing the model's capabilities.`,
      expectedOutput: `Expected response for example ${i + 1} that demonstrates ideal behavior.`,
      actualOutput: `Actual model response for example ${i + 1} that may or may not match expectations.`,
      scores: exampleScores
    }
  })
  
  return NextResponse.json({
    evaluation: {
      modelId,
      provider: model.provider,
      displayName: model.displayName,
      version: model.version,
      evaluationDate: new Date().toISOString(),
      datasetName: "Evaluation Dataset v1.0",
      datasetSize: 100,
      metrics,
      overallScore,
      previousScore: overallScore - (Math.random() * 0.1 - 0.05), // Slight variation from current
      examples
    },
    isMockData: true
  })
}

/**
 * Generate a list of mock model evaluations
 */
function getMockModelEvaluations() {
  const mockModels = [
    { modelId: "gemini-1.5-pro", provider: "google", displayName: "Gemini 1.5 Pro", version: "2024-06-01" },
    { modelId: "gpt-4o", provider: "openai", displayName: "GPT-4o", version: "2024-05-15" },
    { modelId: "claude-3-opus", provider: "anthropic", displayName: "Claude 3 Opus", version: "2024-04-20" },
    { modelId: "gemini-1.5-flash", provider: "google", displayName: "Gemini 1.5 Flash", version: "2024-06-01" },
    { modelId: "gpt-4-turbo", provider: "openai", displayName: "GPT-4 Turbo", version: "2024-03-10" }
  ]
  
  const metricNames = [
    { name: "accuracy", description: "Correctness of responses" },
    { name: "relevance", description: "Relevance to the query" },
    { name: "coherence", description: "Logical flow and consistency" },
    { name: "conciseness", description: "Brevity and clarity" },
    { name: "harmlessness", description: "Avoidance of harmful content" }
  ]
  
  const evaluations = mockModels.map(model => {
    // Generate random metrics
    const metrics = metricNames.map(metric => ({
      name: metric.name,
      description: metric.description,
      value: Math.random() * 0.4 + 0.6, // Between 0.6 and 1.0
      threshold: 0.7,
      weight: 1.0 / metricNames.length
    }))
    
    // Calculate overall score
    const overallScore = metrics.reduce((sum, metric) => sum + (metric.value * metric.weight), 0)
    
    // Generate example evaluations
    const examples = Array.from({ length: 5 }, (_, i) => {
      const exampleScores: Record<string, number> = {}
      metricNames.forEach(metric => {
        exampleScores[metric.name] = Math.random() * 0.4 + 0.6 // Between 0.6 and 1.0
      })
      
      return {
        id: `example-${i + 1}`,
        input: `Example query ${i + 1} for testing the model's capabilities.`,
        expectedOutput: `Expected response for example ${i + 1} that demonstrates ideal behavior.`,
        actualOutput: `Actual model response for example ${i + 1} that may or may not match expectations.`,
        scores: exampleScores
      }
    })
    
    return {
      ...model,
      evaluationDate: new Date().toISOString(),
      datasetName: "Evaluation Dataset v1.0",
      datasetSize: 100,
      metrics,
      overallScore,
      previousScore: overallScore - (Math.random() * 0.1 - 0.05), // Slight variation from current
      examples
    }
  })
  
  return NextResponse.json({
    evaluations,
    isMockData: true
  })
}

================
File: app/api/threads/[id]/messages/route.ts
================
import { NextResponse } from "next/server"
import { loadMessages, saveMessage } from "@/lib/memory/memory"

// GET /api/threads/[id]/messages - Get messages for a thread
export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const thread_id = params.id
    const url = new URL(request.url)
    const limit = url.searchParams.get("limit") ? Number.parseInt(url.searchParams.get("limit")!) : undefined

    const messages = await loadMessages(thread_id, limit)
    return NextResponse.json({ messages })
  } catch (error) {
    console.error(`Error getting messages for thread ${params.id}:`, error)
    return NextResponse.json({ error: "Failed to get messages" }, { status: 500 })
  }
}

// POST /api/threads/[id]/messages - Add a message to a thread
export async function POST(request: Request, { params }: { params: { id: string } }) {
  try {
    const thread_id = params.id
    const body = await request.json()
    const { role, content, tool_call_id, tool_name, generate_embeddings, count_tokens, metadata, model_name } = body

    if (!role || !content) {
      return NextResponse.json({ error: "Role and content are required" }, { status: 400 })
    }

    const message_id = await saveMessage(thread_id, role, content, {
      tool_call_id,
      tool_name,
      generate_embeddings,
      count_tokens,
      metadata,
      model_name,
    })

    return NextResponse.json({
      id: message_id,
      thread_id,
      role,
      content,
      tool_call_id,
      tool_name,
      metadata,
      created_at: new Date().toISOString(),
    })
  } catch (error) {
    console.error(`Error adding message to thread ${params.id}:`, error)
    return NextResponse.json({ error: "Failed to add message" }, { status: 500 })
  }
}

================
File: app/api/threads/[id]/route.ts
================
import { NextResponse } from "next/server"
import { getMemory, deleteThread } from "@/lib/memory/libsql"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const memories = await getMemory(id)

    return NextResponse.json({
      threadId: id,
      messages: memories,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const success = await deleteThread(id)

    return NextResponse.json({
      success,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/threads/[id]/summary/route.ts
================
import { NextResponse } from "next/server"
import { generateThreadSummary } from "@/lib/memory/memory"

// POST /api/threads/[id]/summary - Generate a summary for a thread
export async function POST(request: Request, { params }: { params: { id: string } }) {
  try {
    const thread_id = params.id
    const summary = await generateThreadSummary(thread_id)

    return NextResponse.json({ summary })
  } catch (error) {
    console.error(`Error generating summary for thread ${params.id}:`, error)
    return NextResponse.json({ error: "Failed to generate summary" }, { status: 500 })
  }
}

================
File: app/api/threads/route.ts
================
import { NextResponse } from "next/server"
import { getThreads } from "@/lib/memory/libsql"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET() {
  try {
    const threads = await getThreads()

    return NextResponse.json({
      threads,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    // Create a new thread ID
    const threadId = crypto.randomUUID()

    return NextResponse.json({
      threadId,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/tools/execute/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"
import { getLibSQLClient } from "@/lib/memory/libsql"
import { generateGoogleAI } from "@/lib/google-ai"
import { z } from "zod"

// Tool execution log interface
interface ToolExecutionLog {
  id: string
  tool_id: string
  parameters: Record<string, any>
  result: Record<string, any> | string
  status: "success" | "error"
  error_message?: string
  execution_time: number
  created_at: string
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { toolId, parameters, agentId, threadId } = body

    if (!toolId) {
      return NextResponse.json({ error: "Tool ID is required" }, { status: 400 })
    }

    const startTime = Date.now()
    const executionId = crypto.randomUUID()

    const supabase = getSupabaseClient()

    // Get tool details
    const { data: tool, error: toolError } = await supabase.from("tools").select("*").eq("id", toolId).single()

    if (toolError || !tool) {
      console.error("Error fetching tool:", toolError)
      return NextResponse.json({ error: "Tool not found" }, { status: 404 })
    }

    // Validate parameters against schema
    try {
      const schema = JSON.parse(tool.parameters_schema)

      // Convert JSON schema to Zod schema
      const zodSchema = jsonSchemaToZod(schema)

      // Validate parameters
      zodSchema.parse(parameters)
    } catch (error) {
      console.error("Parameter validation error:", error)

      // Log execution failure
      await logToolExecution({
        id: executionId,
        tool_id: toolId,
        parameters,
        result: {},
        status: "error",
        error_message: error instanceof Error ? error.message : "Parameter validation failed",
        execution_time: Date.now() - startTime,
        created_at: new Date().toISOString(),
      })

      return NextResponse.json(
        {
          error: "Invalid parameters",
          details: error instanceof Error ? error.message : undefined,
        },
        { status: 400 },
      )
    }

    let result: any

    try {
      // Execute tool based on category and name
      switch (tool.category) {
        case "web":
          result = await executeWebTool(tool.name, parameters)
          break
        case "code":
          result = await executeCodeTool(tool.name, parameters)
          break
        case "data":
          result = await executeDataTool(tool.name, parameters)
          break
        case "ai":
          result = await executeAITool(tool.name, parameters)
          break
        case "custom":
          result = await executeCustomTool(tool, parameters)
          break
        default:
          throw new Error(`Unsupported tool category: ${tool.category}`)
      }

      // Log successful execution
      await logToolExecution({
        id: executionId,
        tool_id: toolId,
        parameters,
        result,
        status: "success",
        execution_time: Date.now() - startTime,
        created_at: new Date().toISOString(),
      })

      // If this execution is part of an agent run, log it to the thread
      if (agentId && threadId) {
        const db = getLibSQLClient()
        await db.execute({
          sql: `
            INSERT INTO tool_executions (id, thread_id, agent_id, tool_id, parameters, result, created_at)
            VALUES (?, ?, ?, ?, ?, ?, datetime('now'))
          `,
          args: [executionId, threadId, agentId, toolId, JSON.stringify(parameters), JSON.stringify(result)],
        })
      }

      return NextResponse.json({
        executionId,
        result,
        toolName: tool.name,
        executionTime: Date.now() - startTime,
      })
    } catch (error) {
      console.error(`Error executing tool ${tool.name}:`, error)

      // Log execution failure
      await logToolExecution({
        id: executionId,
        tool_id: toolId,
        parameters,
        result: {},
        status: "error",
        error_message: error instanceof Error ? error.message : "Tool execution failed",
        execution_time: Date.now() - startTime,
        created_at: new Date().toISOString(),
      })

      return NextResponse.json(
        {
          error: "Tool execution failed",
          details: error instanceof Error ? error.message : undefined,
        },
        { status: 500 },
      )
    }
  } catch (error) {
    return handleApiError(error)
  }
}

// Log tool execution to database
async function logToolExecution(log: ToolExecutionLog) {
  try {
    const supabase = getSupabaseClient()

    await supabase.from("tool_executions").insert({
      id: log.id,
      tool_id: log.tool_id,
      parameters: log.parameters,
      result: log.result,
      status: log.status,
      error_message: log.error_message,
      execution_time: log.execution_time,
      created_at: log.created_at,
    })
  } catch (error) {
    console.error("Failed to log tool execution:", error)
  }
}

// Tool execution implementations
async function executeWebTool(name: string, parameters: any) {
  switch (name.toLowerCase()) {
    case "websearch":
    case "web_search":
      return await executeWebSearch(parameters.query, parameters.numResults || 5)
    case "webextract":
    case "web_extract":
      return await executeWebExtract(parameters.url, parameters.selector)
    case "webscrape":
    case "web_scrape":
      return await executeWebScrape(parameters.url, parameters.selectors)
    default:
      throw new Error(`Unknown web tool: ${name}`)
  }
}

async function executeCodeTool(name: string, parameters: any) {
  switch (name.toLowerCase()) {
    case "codeexecute":
    case "code_execute":
      return await executeCodeExecution(parameters.code, parameters.language, parameters.timeout || 10)
    case "codeanalyze":
    case "code_analyze":
      return await executeCodeAnalysis(parameters.code, parameters.language, parameters.analysis || ["complexity"])
    default:
      throw new Error(`Unknown code tool: ${name}`)
  }
}

async function executeDataTool(name: string, parameters: any) {
  switch (name.toLowerCase()) {
    case "dataquery":
    case "data_query":
      return await executeDataQuery(parameters.query, parameters.datasource)
    case "datavisualize":
    case "data_visualize":
      return await executeDataVisualization(parameters.data, parameters.type, parameters.options)
    default:
      throw new Error(`Unknown data tool: ${name}`)
  }
}

async function executeAITool(name: string, parameters: any) {
  switch (name.toLowerCase()) {
    case "textgeneration":
    case "text_generation":
      return await executeTextGeneration(parameters.prompt, parameters.options)
    case "imagegeneration":
    case "image_generation":
      return await executeImageGeneration(parameters.prompt, parameters.options)
    default:
      throw new Error(`Unknown AI tool: ${name}`)
  }
}

async function executeCustomTool(tool: any, parameters: any) {
  if (!tool.implementation) {
    throw new Error("Custom tool has no implementation")
  }

  // SECURITY WARNING: This is just for demonstration
  // In production, you should use a secure sandboxed environment
  const AsyncFunction = Object.getPrototypeOf(async () => {}).constructor

  try {
    const fn = new AsyncFunction("parameters", tool.implementation)
    return await fn(parameters)
  } catch (error) {
    console.error("Error executing custom tool:", error)
    throw error
  }
}

// Specific tool implementations
async function executeWebSearch(query: string, numResults = 5) {
  // In production, integrate with a real search API
  console.log(`Searching for: ${query}, results: ${numResults}`)

  // Simulate API call delay
  await new Promise((resolve) => setTimeout(resolve, 1000))

  return {
    query,
    results: Array.from({ length: numResults }, (_, i) => ({
      title: `Search result ${i + 1} for "${query}"`,
      snippet: `This is a snippet of information related to "${query}". It contains relevant details that might be useful.`,
      url: `https://example.com/result${i + 1}?q=${encodeURIComponent(query)}`,
    })),
    totalResults: numResults,
  }
}

async function executeWebExtract(url: string, selector?: string) {
  // In production, use a library like cheerio or puppeteer
  console.log(`Extracting content from: ${url}, selector: ${selector || "none"}`)

  // Simulate API call delay
  await new Promise((resolve) => setTimeout(resolve, 1000))

  return {
    title: "Example Page Title",
    content: selector ? `Content extracted using selector "${selector}"` : "Full page content would be extracted here",
    url,
  }
}

async function executeWebScrape(url: string, selectors: Record<string, string>) {
  // In production, use a library like cheerio or puppeteer
  console.log(`Scraping content from: ${url}`)
  console.log("Selectors:", selectors)

  // Simulate API call delay
  await new Promise((resolve) => setTimeout(resolve, 1000))

  const result: Record<string, string> = {}

  // Create mock results for each selector
  Object.entries(selectors).forEach(([key, selector]) => {
    result[key] = `Content for "${key}" using selector "${selector}"`
  })

  return {
    url,
    data: result,
  }
}

async function executeCodeExecution(code: string, language: string, timeout: number) {
  console.log(`Executing ${language} code with ${timeout}s timeout`)

  if (language === "javascript") {
    // SECURITY WARNING: This is just a demonstration
    // Never execute arbitrary code in a production environment without proper sandboxing

    // Create a safe execution context
    const AsyncFunction = Object.getPrototypeOf(async () => {}).constructor

    // Set up a timeout
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error(`Execution timed out after ${timeout} seconds`)), timeout * 1000)
    })

    // Capture console output
    const output: string[] = []
    const originalConsoleLog = console.log
    console.log = (...args) => {
      output.push(args.map((arg) => String(arg)).join(" "))
    }

    try {
      // Execute the code with timeout
      const execPromise = AsyncFunction(code)()
      const result = await Promise.race([execPromise, timeoutPromise])

      return {
        success: true,
        output: output.join("\n"),
        result: result !== undefined ? String(result) : undefined,
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        output: output.join("\n"),
      }
    } finally {
      // Restore console.log
      console.log = originalConsoleLog
    }
  } else {
    return {
      success: false,
      error: `Execution of ${language} is not implemented in this demo`,
    }
  }
}

async function executeCodeAnalysis(code: string, language: string, analysis: string[]) {
  console.log(`Analyzing ${language} code for ${analysis.join(", ")}`)

  const results: Record<string, any> = {}

  if (analysis.includes("complexity")) {
    // Simple complexity metric: count lines and nesting level
    const lines = code.split("\n").length
    const nestingLevel = Math.max(
      ...code.split("\n").map((line) => {
        const indentation = line.search(/\S/)
        return indentation > 0 ? indentation / 2 : 0
      }),
    )

    results["complexity"] = {
      lines,
      nestingLevel,
      assessment: nestingLevel > 5 ? "High complexity" : "Acceptable complexity",
    }
  }

  if (analysis.includes("security")) {
    // Simple security check: look for eval, exec, etc.
    const dangerousPatterns: Record<string, string[]> = {
      javascript: ["eval(", "new Function(", "setTimeout(", "setInterval("],
      python: ["eval(", "exec(", "os.system(", "subprocess"],
    }

    const patterns = dangerousPatterns[language] || []
    const issues = patterns
      .map((pattern) => {
        const regex = new RegExp(pattern, "g")
        const matches = code.match(regex) || []
        return matches.length > 0 ? { pattern, count: matches.length } : null
      })
      .filter(Boolean)

    results["security"] = {
      issues,
      assessment: issues.length > 0 ? "Potential security issues found" : "No obvious security issues",
    }
  }

  return {
    language,
    analysisTypes: analysis,
    results,
  }
}

async function executeDataQuery(query: string, datasource: string) {
  // In production, integrate with actual databases
  console.log(`Executing query on datasource ${datasource}: ${query}`)

  // Simulate API call delay
  await new Promise((resolve) => setTimeout(resolve, 1000))

  return {
    columns: ["id", "name", "value"],
    rows: [
      { id: 1, name: "Item 1", value: 100 },
      { id: 2, name: "Item 2", value: 200 },
      { id: 3, name: "Item 3", value: 300 },
    ],
    rowCount: 3,
    executionTime: 0.05,
  }
}

async function executeDataVisualization(data: any, type: string, options: any = {}) {
  console.log(`Creating ${type} visualization with options:`, options)

  // In production, use a visualization library
  return {
    type,
    data,
    options,
    svgContent: `<svg width="200" height="100"><rect width="50" height="80" fill="blue" /><rect x="60" width="50" height="50" fill="red" /><rect x="120" width="50" height="30" fill="green" /></svg>`,
  }
}

async function executeTextGeneration(prompt: string, options: any = {}) {
  console.log(`Generating text for prompt: ${prompt}`)

  // Use Google AI for text generation
  const { text } = await generateGoogleAI({
    modelId: options.model || "gemini-pro",
    messages: [{ role: "user", content: prompt }],
    temperature: options.temperature || 0.7,
    maxTokens: options.maxTokens || 1000,
  })

  return {
    prompt,
    text,
    options,
  }
}

async function executeImageGeneration(prompt: string, options: any = {}) {
  console.log(`Generating image for prompt: ${prompt}`)

  // In production, integrate with an image generation API
  return {
    prompt,
    imageUrl: `https://placehold.co/600x400?text=${encodeURIComponent(prompt)}`,
    options,
  }
}

// Helper to convert JSON schema to Zod schema
function jsonSchemaToZod(schema: any): z.ZodTypeAny {
  if (!schema || typeof schema !== "object") {
    throw new Error("Invalid schema")
  }

  if (schema.type === "object") {
    const shape: Record<string, z.ZodTypeAny> = {}

    if (schema.properties) {
      for (const [key, prop] of Object.entries(schema.properties)) {
        let zodProp = jsonSchemaToZod(prop as any)

        // Make property optional if not in required array
        if (schema.required && !schema.required.includes(key)) {
          zodProp = zodProp.optional()
        }

        shape[key] = zodProp
      }
    }

    return z.object(shape)
  } else if (schema.type === "string") {
    let zodString = z.string()

    if (schema.enum) {
      return z.enum(schema.enum as [string, ...string[]])
    }

    if (schema.description) {
      zodString = zodString.describe(schema.description)
    }

    return zodString
  } else if (schema.type === "number" || schema.type === "integer") {
    return z.number()
  } else if (schema.type === "boolean") {
    return z.boolean()
  } else if (schema.type === "array") {
    if (schema.items) {
      return z.array(jsonSchemaToZod(schema.items))
    }
    return z.array(z.any())
  }

  return z.any()
}

================
File: app/api/tools/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"
import { revalidatePath } from "next/cache"

export async function GET(request: Request) {
  try {
    const url = new URL(request.url)
    const search = url.searchParams.get("search") || ""
    const category = url.searchParams.get("category")
    const limit = Number.parseInt(url.searchParams.get("limit") || "100")
    const offset = Number.parseInt(url.searchParams.get("offset") || "0")

    const supabase = getSupabaseClient()

    let query = supabase.from("tools").select("*", { count: "exact" })

    // Apply search filter if provided
    if (search) {
      query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%`)
    }

    // Apply category filter if provided
    if (category) {
      query = query.eq("category", category)
    }

    // Apply pagination
    query = query.order("created_at", { ascending: false }).range(offset, offset + limit - 1)

    const { data: tools, error, count } = await query

    if (error) {
      console.error("Error fetching tools:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({
      tools,
      pagination: {
        total: count || 0,
        limit,
        offset,
      },
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()

    // Validate required fields
    if (!body.name || !body.description || !body.parametersSchema) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }

    // Validate parameters schema is valid JSON
    try {
      JSON.parse(body.parametersSchema)
    } catch (e) {
      return NextResponse.json({ error: "Parameters schema must be valid JSON" }, { status: 400 })
    }

    const supabase = getSupabaseClient()

    // Check if tool with same name already exists
    const { data: existingTool } = await supabase.from("tools").select("id").eq("name", body.name).maybeSingle()

    if (existingTool) {
      return NextResponse.json({ error: "A tool with this name already exists" }, { status: 409 })
    }

    // Insert new tool
    const { data: tool, error } = await supabase
      .from("tools")
      .insert({
        name: body.name,
        description: body.description,
        parameters_schema: body.parametersSchema,
        category: body.category || "custom",
        implementation: body.implementation || null,
        is_enabled: body.isEnabled !== undefined ? body.isEnabled : true,
      })
      .select()
      .single()

    if (error) {
      console.error("Error creating tool:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Revalidate the tools page
    revalidatePath("/tools")

    return NextResponse.json(tool)
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/workflows/[id]/execute/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { workflow } from '@/lib/workflow';

// POST /api/workflows/:id/execute - Execute a workflow
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    
    // Check if workflow exists
    const existingWorkflow = await workflow.getWorkflow(id);
    if (!existingWorkflow) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }
    
    // Execute workflow
    const executedWorkflow = await workflow.executeWorkflow(id);
    
    return NextResponse.json({ workflow: executedWorkflow });
  } catch (error) {
    console.error(`Error executing workflow ${params.id}:`, error);
    return NextResponse.json(
      { error: 'Failed to execute workflow', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/workflows/[id]/pause/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { workflow } from '@/lib/workflow';

// POST /api/workflows/:id/pause - Pause a workflow
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    
    // Check if workflow exists
    const existingWorkflow = await workflow.getWorkflow(id);
    if (!existingWorkflow) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }
    
    // Check if workflow is running
    if (existingWorkflow.status !== 'running') {
      return NextResponse.json(
        { error: 'Workflow is not running' },
        { status: 400 }
      );
    }
    
    // Pause workflow
    const updatedWorkflow = await workflow.updateWorkflow(id, { status: 'paused' });
    
    return NextResponse.json({ workflow: updatedWorkflow });
  } catch (error) {
    console.error(`Error pausing workflow ${params.id}:`, error);
    return NextResponse.json(
      { error: 'Failed to pause workflow', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/workflows/[id]/resume/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { workflow } from '@/lib/workflow';

// POST /api/workflows/:id/resume - Resume a workflow
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    
    // Check if workflow exists
    const existingWorkflow = await workflow.getWorkflow(id);
    if (!existingWorkflow) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }
    
    // Check if workflow is paused
    if (existingWorkflow.status !== 'paused') {
      return NextResponse.json(
        { error: 'Workflow is not paused' },
        { status: 400 }
      );
    }
    
    // Resume workflow
    const updatedWorkflow = await workflow.updateWorkflow(id, { status: 'running' });
    
    // Execute workflow
    const executedWorkflow = await workflow.executeWorkflow(id);
    
    return NextResponse.json({ workflow: executedWorkflow });
  } catch (error) {
    console.error(`Error resuming workflow ${params.id}:`, error);
    return NextResponse.json(
      { error: 'Failed to resume workflow', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/workflows/[id]/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { workflow } from '@/lib/workflow';
import { z } from 'zod';

// Schema for updating a workflow
const updateWorkflowSchema = z.object({
  name: z.string().min(1, "Name is required").optional(),
  description: z.string().optional(),
  metadata: z.record(z.any()).optional(),
});

// GET /api/workflows/:id - Get a specific workflow
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    
    // Get workflow
    const workflowData = await workflow.getWorkflow(id);
    
    if (!workflowData) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }
    
    return NextResponse.json({ workflow: workflowData });
  } catch (error) {
    console.error(`Error getting workflow ${params.id}:`, error);
    return NextResponse.json(
      { error: 'Failed to get workflow', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

// PUT /api/workflows/:id - Update a workflow
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    
    // Parse request body
    const body = await request.json();
    
    // Validate request body
    const validationResult = updateWorkflowSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Invalid request body', details: validationResult.error.format() },
        { status: 400 }
      );
    }
    
    // Check if workflow exists
    const existingWorkflow = await workflow.getWorkflow(id);
    if (!existingWorkflow) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }
    
    // Update workflow
    const updatedWorkflow = await workflow.updateWorkflow(id, validationResult.data);
    
    return NextResponse.json({ workflow: updatedWorkflow });
  } catch (error) {
    console.error(`Error updating workflow ${params.id}:`, error);
    return NextResponse.json(
      { error: 'Failed to update workflow', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

// DELETE /api/workflows/:id - Delete a workflow
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    
    // Check if workflow exists
    const existingWorkflow = await workflow.getWorkflow(id);
    if (!existingWorkflow) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }
    
    // Delete workflow
    await workflow.deleteWorkflow(id);
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error(`Error deleting workflow ${params.id}:`, error);
    return NextResponse.json(
      { error: 'Failed to delete workflow', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/workflows/[id]/steps/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { workflow } from '@/lib/workflow';
import { z } from 'zod';

// Schema for adding a step to a workflow
const addStepSchema = z.object({
  agentId: z.string().min(1, "Agent ID is required"),
  input: z.string().optional(),
  threadId: z.string().optional(),
  metadata: z.record(z.any()).optional(),
});

// POST /api/workflows/:id/steps - Add a step to a workflow
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    
    // Parse request body
    const body = await request.json();
    
    // Validate request body
    const validationResult = addStepSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Invalid request body', details: validationResult.error.format() },
        { status: 400 }
      );
    }
    
    // Check if workflow exists
    const existingWorkflow = await workflow.getWorkflow(id);
    if (!existingWorkflow) {
      return NextResponse.json(
        { error: 'Workflow not found' },
        { status: 404 }
      );
    }
    
    // Add step to workflow
    const updatedWorkflow = await workflow.addWorkflowStep(id, validationResult.data);
    
    return NextResponse.json({ workflow: updatedWorkflow });
  } catch (error) {
    console.error(`Error adding step to workflow ${params.id}:`, error);
    return NextResponse.json(
      { error: 'Failed to add step to workflow', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/workflows/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { workflow } from '@/lib/workflow';
import { z } from 'zod';

// Schema for creating a workflow
const createWorkflowSchema = z.object({
  name: z.string().min(1, "Name is required"),
  description: z.string().optional(),
  steps: z.array(z.object({
    agentId: z.string().min(1, "Agent ID is required"),
    input: z.string().optional(),
    threadId: z.string().optional(),
    metadata: z.record(z.any()).optional(),
  })).optional(),
  metadata: z.record(z.any()).optional(),
});

// GET /api/workflows - List all workflows
export async function GET(request: NextRequest) {
  try {
    // Parse query parameters
    const searchParams = request.nextUrl.searchParams;
    const limit = parseInt(searchParams.get('limit') || '10');
    const offset = parseInt(searchParams.get('offset') || '0');
    
    // Get workflows
    const workflows = await workflow.listWorkflows(limit, offset);
    
    return NextResponse.json({ workflows });
  } catch (error) {
    console.error('Error listing workflows:', error);
    return NextResponse.json(
      { error: 'Failed to list workflows', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

// POST /api/workflows - Create a new workflow
export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const body = await request.json();
    
    // Validate request body
    const validationResult = createWorkflowSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { error: 'Invalid request body', details: validationResult.error.format() },
        { status: 400 }
      );
    }
    
    // Create workflow
    const newWorkflow = await workflow.createWorkflow(validationResult.data);
    
    return NextResponse.json({ workflow: newWorkflow }, { status: 201 });
  } catch (error) {
    console.error('Error creating workflow:', error);
    return NextResponse.json(
      { error: 'Failed to create workflow', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

================
File: app/api/agentic/agents/route.ts
================
import { NextResponse } from "next/server"
import { createAgent, initializeToolkit } from "@/lib/agentic-integration"
import { getLibSQLClient } from "@/lib/memory/db"
import { v4 as uuidv4 } from "uuid"

// GET /api/agentic/agents - Get all agents
export async function GET(request: Request) {
  try {
    const db = getLibSQLClient()

    const result = await db.execute({
      sql: `
        SELECT a.*, m.name as model_name, m.provider
        FROM agents a
        JOIN models m ON a.model_id = m.id
      `,
    })

    return NextResponse.json({ agents: result.rows })
  } catch (error) {
    console.error("Error fetching agents:", error)
    return NextResponse.json({ error: "Failed to fetch agents" }, { status: 500 })
  }
}

// POST /api/agentic/agents - Create a new agent
export async function POST(request: Request) {
  try {
    const db = getLibSQLClient()
    const body = await request.json()
    const { name, description, modelId, toolIds = [], systemPrompt = "" } = body

    if (!name || !modelId) {
      return NextResponse.json({ error: "Name and model ID are required" }, { status: 400 })
    }

    // Get model details
    const modelResult = await db.execute({
      sql: `SELECT * FROM models WHERE id = ?`,
      args: [modelId],
    })

    if (modelResult.rows.length === 0) {
      return NextResponse.json({ error: "Model not found" }, { status: 404 })
    }

    const model = modelResult.rows[0]

    // Create agent
    const id = uuidv4()
    const now = new Date().toISOString()

    await db.execute({
      sql: `
        INSERT INTO agents (id, name, description, model_id, system_prompt, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `,
      args: [id, name, description || "", modelId, systemPrompt, now, now],
    })

    // Add tools to agent
    for (const toolId of toolIds) {
      await db.execute({
        sql: `INSERT INTO agent_tools (agent_id, tool_id) VALUES (?, ?)`,
        args: [id, toolId],
      })
    }

    // Initialize toolkit and create agentic agent
    await initializeToolkit({
      googleApiKey: process.env.GOOGLE_API_KEY,
      // Add other API keys as needed
    })

    // Get tool names for the agent
    const toolsResult = await db.execute({
      sql: `
        SELECT t.name 
        FROM tools t
        JOIN agent_tools at ON t.id = at.tool_id
        WHERE at.agent_id = ?
      `,
      args: [id],
    })

    const toolNames = toolsResult.rows.map((row) => row.name as string)

    // Create agentic agent
    await createAgent({
      model: model.model_id as string,
      provider: model.provider as string,
      tools: toolNames,
      systemPrompt,
    })

    return NextResponse.json({
      id,
      name,
      description,
      modelId,
      toolIds,
      systemPrompt,
      createdAt: now,
      updatedAt: now,
    })
  } catch (error) {
    console.error("Error creating agent:", error)
    const errorMessage = error instanceof Error ? error.message : "An unknown error occurred";
    return NextResponse.json({ error: "Failed to create agent", details: errorMessage }, { status: 500 })
  }
}

================
File: app/api/agentic/tools/execute/route.ts
================
import { NextResponse } from "next/server"
import { executeTool, initializeToolkit } from "@/lib/agentic-integration"

// POST /api/agentic/tools/execute - Execute a specific tool
export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { toolName, params } = body

    if (!toolName) {
      return NextResponse.json({ error: "Tool name is required" }, { status: 400 })
    }

    // Initialize toolkit if not already initialized
    await initializeToolkit({
      googleApiKey: process.env.GOOGLE_API_KEY,
      // Add other API keys as needed
    })

    const result = await executeTool(toolName, params || {})

    return NextResponse.json({ result })
  } catch (error) {
    console.error("Error executing agentic tool:", error)
    const errorMessage = error instanceof Error ? error.message : String(error);
    return NextResponse.json({ error: "Failed to execute tool", details: errorMessage }, { status: 500 })
  }
}

================
File: app/api/ai-sdk/apps/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { getData, createItem, updateItem, deleteItem } from '@/lib/memory/supabase';

export async function GET(_req: NextRequest) {
  try {
    const apps = await getData('apps');
    return NextResponse.json({ apps });
  } catch (error) {
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    const data = await req.json();
    const now = new Date().toISOString();
    const app = await createItem('apps', {
      ...data,
      created_at: now,
      updated_at: now,
    });
    return NextResponse.json(app, { status: 201 });
  } catch (error) {
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
  }
}

export async function PUT(req: NextRequest) {
  try {
    const url = new URL(req.url);
    const id = url.pathname.split('/').pop();
    if (!id) return NextResponse.json({ error: 'Missing app id' }, { status: 400 });
    const data = await req.json();
    const updated = await updateItem('apps', id, {
      ...data,
      updated_at: new Date().toISOString(),
    });
    if (!updated) return NextResponse.json({ error: 'App not found' }, { status: 404 });
    return NextResponse.json(updated);
  } catch (error) {
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const url = new URL(req.url);
    const id = url.pathname.split('/').pop();
    if (!id) return NextResponse.json({ error: 'Missing app id' }, { status: 400 });
    const result = await deleteItem('apps', id);
    if (!result.success) return NextResponse.json({ error: 'App not found' }, { status: 404 });
    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });
  }
}
// Uses persistent DB via supabase.ts CRUD helpers for all operations.

================
File: app/api/ai-sdk/threads/[id]/messages/route.ts
================
import { NextResponse } from "next/server";
import { handleApiError } from "@/lib/api-error-handler";
import { logEvent } from "@/lib/langfuse-integration";
import { v4 as uuidv4 } from "uuid";
import { countTokens } from "@/lib/memory/memory";
import { getMemoryProvider } from "@/lib/memory/factory";
import {
  getItemById,
  getData,
  createItem,
  updateItem
} from "@/lib/memory/upstash/supabase-adapter";
import { getLibSQLClient } from "@/lib/memory/db";

/**
 * GET /api/ai-sdk/threads/[id]/messages
 * 
 * Fetch messages for a specific thread
 */
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get("limit") || "100");
    const offset = parseInt(url.searchParams.get("offset") || "0");
    const provider = getMemoryProvider();
    let messages: unknown[] = [];
    let count = 0;
    let useLibSQL = false;

    if (provider === "upstash") {
      try {
        const thread = await getItemById("memory_threads", id);
        if (!thread) {
          return NextResponse.json({ error: "Thread not found" }, { status: 404 });
        }

        messages = await getData("messages", {
          filters: [{ field: "memory_thread_id", operator: "eq", value: id }],
          orderBy: { column: "created_at", ascending: true },
          limit,
          offset
        });

        count = (await getData("messages", {
          filters: [{ field: "memory_thread_id", operator: "eq", value: id }]
        })).length;
      } catch {
        useLibSQL = true;
      }
    } else {
      useLibSQL = true;
    }

    if (useLibSQL) {
      const db = getLibSQLClient();

      const threadResult = await db.execute({
        sql: `SELECT id FROM memory_threads WHERE id = ?`,
        args: [id]
      });

      if (threadResult.rows.length === 0) {
        return NextResponse.json({ error: "Thread not found" }, { status: 404 });
      }

      const messagesResult = await db.execute({
        sql: `SELECT * FROM messages WHERE memory_thread_id = ? ORDER BY created_at ASC LIMIT ? OFFSET ?`,
        args: [id, limit, offset]
      });

      messages = messagesResult.rows.map((msg) => {
        let metadata = {};
        try {
          metadata = typeof msg.metadata === 'string' ? JSON.parse(msg.metadata) : msg.metadata || {};
        } catch {
          // ignore
        }
        return {
          id: msg.id,
          role: msg.role,
          content: msg.content,
          metadata,
          tokenCount: msg.token_count,
          createdAt: msg.created_at
        };
      });

      const countResult = await db.execute({
        sql: `SELECT COUNT(*) as count FROM messages WHERE memory_thread_id = ?`,
        args: [id]
      });

      count = Number(countResult.rows[0].count ?? 0);
    } else {
      // Format messages for Upstash
      messages = Array.isArray(messages)
        ? messages.map((msg) => {
            if (typeof msg !== 'object' || msg === null) return msg;
            const m = msg as Record<string, unknown>;
            let metadata: Record<string, unknown> = {};
            try {
              metadata = typeof m.metadata === 'string' ? JSON.parse(m.metadata as string) : m.metadata || {};
            } catch {
              // ignore
            }
            return {
              id: m.id,
              role: m.role,
              content: m.content,
              metadata,
              tokenCount: m.token_count,
              createdAt: m.created_at
            };
          })
        : [];
    }

    return NextResponse.json({
      messages,
      count,
      hasMore: messages.length === limit
    });
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * POST /api/ai-sdk/threads/[id]/messages
 * 
 * Add a message to a specific thread
 */
export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const body = await request.json();
    const { role, content, metadata = {} } = body;

    // Validate required fields
    if (!role || !content) {
      return NextResponse.json(
        { error: "Role and content are required" },
        { status: 400 }
      );
    }

    const provider = getMemoryProvider();
    let useLibSQL = false;
    const messageId = uuidv4();
    const now = new Date().toISOString();
    let tokenCount: number | null = null;

    try {
      tokenCount = countTokens(content);
    } catch {
      // ignore
    }

    const messageMetadata = {
      ...metadata,
      source: 'ai-sdk-ui',
      timestamp: now
    };

    if (provider === "upstash") {
      try {
        const thread = await getItemById("memory_threads", id);
        if (!thread) {
          return NextResponse.json({ error: "Thread not found" }, { status: 404 });
        }

        await createItem("messages", {
          id: messageId,
          memory_thread_id: id,
          role,
          content,
          token_count: tokenCount,
          metadata: JSON.stringify(messageMetadata),
          created_at: now
        });

        await updateItem("memory_threads", id, { updated_at: now });
      } catch {
        useLibSQL = true;
      }
    } else {
      useLibSQL = true;
    }

    if (useLibSQL) {
      const db = getLibSQLClient();

      const threadResult = await db.execute({
        sql: `SELECT id FROM memory_threads WHERE id = ?`,
        args: [id]
      });

      if (threadResult.rows.length === 0) {
        return NextResponse.json({ error: "Thread not found" }, { status: 404 });
      }

      await db.execute({
        sql: `INSERT INTO messages (id, memory_thread_id, role, content, token_count, metadata, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)`,
        args: [messageId, id, role, content, tokenCount, JSON.stringify(messageMetadata), now]
      });

      await db.execute({
        sql: `UPDATE memory_threads SET updated_at = ? WHERE id = ?`,
        args: [now, id]
      });
    }

    await logEvent({
      traceId: messageId,
      name: "message_created",
      metadata: {
        messageId,
        threadId: id,
        role,
        tokenCount,
        timestamp: now
      }
    });

    return NextResponse.json({
      id: messageId,
      threadId: id,
      role,
      content,
      tokenCount,
      metadata: messageMetadata,
      createdAt: now
    });
  } catch (error) {
    return handleApiError(error);
  }
}

================
File: app/api/ai-sdk/threads/[id]/route.ts
================
import { NextResponse } from "next/server";
import { getLibSQLClient } from "@/lib/memory/db";
import { handleApiError } from "@/lib/api-error-handler";
import { getMemoryProvider } from '@/lib/memory/factory';
import { getItemById, updateItem, deleteItem, getData, UpstashAdapterError } from '@/lib/memory/upstash/supabase-adapter';

/**
 * GET /api/ai-sdk/threads/[id]
 * 
 * Fetch a specific thread and optionally its messages
 */
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const url = new URL(request.url);
    const includeMessages = url.searchParams.get("messages") === "true";
    const messageLimit = parseInt(url.searchParams.get("limit") || "100");
    const provider = getMemoryProvider();
    if (provider === 'upstash') {
      try {
        const thread = await getItemById('memory_threads', id);
        if (!thread) {
          return NextResponse.json({ error: 'Thread not found' }, { status: 404 });
        }
        const formattedThread = {
          id: thread.id,
          name: thread.name,
          metadata: thread.metadata || {},
          createdAt: thread.created_at,
          updatedAt: thread.updated_at
        };
        if (includeMessages) {
          const messages = await getData('messages', {
            filters: [
              { field: 'thread_id', operator: 'eq', value: id }
            ],
            orderBy: { column: 'created_at', ascending: true },
            limit: messageLimit
          });
          // Format messages
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (formattedThread as any).messages = messages.map((msg) => ({
            id: msg.id,
            threadId: msg.thread_id,
            role: msg.role,
            content: msg.content,
            metadata: msg.metadata || {},
            createdAt: msg.created_at
          }));
        }
        return NextResponse.json(formattedThread);
      } catch (err) {
        if (!(err instanceof UpstashAdapterError)) throw err;
        // Fallback to LibSQL
      }
    }
    // LibSQL fallback
    const db = getLibSQLClient();
    const threadResult = await db.execute({
      sql: `SELECT * FROM memory_threads WHERE id = ?`,
      args: [id]
    });
    if (threadResult.rows.length === 0) {
      return NextResponse.json({ error: 'Thread not found' }, { status: 404 });
    }
    const thread = threadResult.rows[0];
    let metadata = {};
    try {
      if (typeof thread.metadata === 'string') {
        metadata = JSON.parse(thread.metadata);
      } else if (typeof thread.metadata === 'object' && thread.metadata !== null && !(thread.metadata instanceof ArrayBuffer)) {
        metadata = thread.metadata;
      }
    } catch { metadata = {}; }
    const formattedThread = {
      id: thread.id,
      name: thread.name,
      metadata,
      createdAt: thread.created_at,
      updatedAt: thread.updated_at
    };
    if (includeMessages) {
      const msgResult = await db.execute({
        sql: `SELECT * FROM messages WHERE thread_id = ? ORDER BY created_at ASC LIMIT ?`,
        args: [id, messageLimit]
      });
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (formattedThread as any).messages = msgResult.rows.map((msg) => {
        let msgMeta = {};
        try {
          if (typeof msg.metadata === 'string') {
            msgMeta = JSON.parse(msg.metadata);
          } else if (typeof msg.metadata === 'object' && msg.metadata !== null && !(msg.metadata instanceof ArrayBuffer)) {
            msgMeta = msg.metadata;
          }
        } catch { msgMeta = {}; }
        return {
          id: msg.id,
          threadId: msg.thread_id,
          role: msg.role,
          content: msg.content,
          metadata: msgMeta,
          createdAt: msg.created_at
        };
      });
    }
    return NextResponse.json(formattedThread);
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * PATCH /api/ai-sdk/threads/[id]
 * 
 * Update a specific thread
 */
export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const body = await request.json();
    const { name, metadata } = body;
    const provider = getMemoryProvider();
    if (provider === 'upstash') {
      try {
        const thread = await getItemById('memory_threads', id);
        if (!thread) {
          return NextResponse.json({ error: 'Thread not found' }, { status: 404 });
        }
        const existingMetadata = thread.metadata || {};
        const updatedMetadata = metadata ? { ...existingMetadata, ...metadata } : existingMetadata;
        const now = new Date().toISOString();
        const updated = await updateItem('memory_threads', id, {
          name: name ?? thread.name,
          metadata: updatedMetadata,
          updated_at: now
        });
        return NextResponse.json({
          id: updated.id,
          name: updated.name,
          metadata: updated.metadata || {},
          createdAt: updated.created_at,
          updatedAt: updated.updated_at
        });
      } catch (err) {
        if (!(err instanceof UpstashAdapterError)) throw err;
        // Fallback to LibSQL
      }
    }
    // LibSQL fallback
    const db = getLibSQLClient();
    const threadResult = await db.execute({
      sql: `SELECT * FROM memory_threads WHERE id = ?`,
      args: [id]
    });
    if (threadResult.rows.length === 0) {
      return NextResponse.json({ error: 'Thread not found' }, { status: 404 });
    }
    const thread = threadResult.rows[0];
    let existingMetadata = {};
    try {
      if (typeof thread.metadata === 'string') {
        existingMetadata = JSON.parse(thread.metadata);
      } else if (typeof thread.metadata === 'object' && thread.metadata !== null && !(thread.metadata instanceof ArrayBuffer)) {
        existingMetadata = thread.metadata;
      }
    } catch { existingMetadata = {}; }
    const updatedMetadata = metadata ? { ...existingMetadata, ...metadata } : existingMetadata;
    const now = new Date().toISOString();
    await db.execute({
      sql: `UPDATE memory_threads SET name = ?, metadata = ?, updated_at = ? WHERE id = ?`,
      args: [name ?? thread.name, JSON.stringify(updatedMetadata), now, id]
    });
    return NextResponse.json({
      id: thread.id,
      name: name ?? thread.name,
      metadata: updatedMetadata,
      createdAt: thread.created_at,
      updatedAt: now
    });
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * DELETE /api/ai-sdk/threads/[id]
 * 
 * Delete a specific thread and all its messages
 */
export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const provider = getMemoryProvider();
    if (provider === 'upstash') {
      try {
        const deleted = await deleteItem('memory_threads', id);
        // Optionally delete messages as well (if needed)
        // await deleteItem('messages', { thread_id: id });
        return NextResponse.json({ success: !!deleted });
      } catch (err) {
        if (!(err instanceof UpstashAdapterError)) throw err;
        // Fallback to LibSQL
      }
    }
    // LibSQL fallback
    const db = getLibSQLClient();
    await db.execute({
      sql: `DELETE FROM messages WHERE thread_id = ?`,
      args: [id]
    });
    await db.execute({
      sql: `DELETE FROM memory_threads WHERE id = ?`,
      args: [id]
    });
    return NextResponse.json({ success: true });
  } catch (error) {
    return handleApiError(error);
  }
}

================
File: app/api/ai-sdk/threads/route.ts
================
import { NextResponse } from "next/server";
import { getLibSQLClient } from "@/lib/memory/db";
import { handleApiError } from "@/lib/api-error-handler";
import { v4 as uuidv4 } from "uuid";
import { getMemoryProvider } from '@/lib/memory/factory';
import { getData, createItem, UpstashAdapterError, type TableRow, type QueryOptions, type FilterOptions } from '@/lib/memory/upstash/supabase-adapter';

/**
 * GET /api/ai-sdk/threads
 * 
 * Fetch all threads for AI SDK UI
 */
export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const search = url.searchParams.get("search") || "";
    const limit = parseInt(url.searchParams.get("limit") || "50");
    const offset = parseInt(url.searchParams.get("offset") || "0");
    const provider = getMemoryProvider();
    let threads: Array<TableRow<'memory_threads'>> = [];
    let count = 0;
    let hasMore = false;

    if (provider === 'upstash') {
      try {
        // Upstash: get threads with source 'ai-sdk-ui'
        const filters: FilterOptions[] = [
          { field: 'metadata.source', operator: 'eq', value: 'ai-sdk-ui' }
        ];
        if (search) {
          filters.push({ field: 'name', operator: 'ilike', value: `%${search}%` });
        }
        const options: QueryOptions = { filters, limit, offset, orderBy: { column: 'updated_at', ascending: false } };
        const upstashThreads = await getData('memory_threads', options);
        threads = upstashThreads.map((thread) => ({
          id: thread.id,
          name: thread.name,
          metadata: thread.metadata || {},
          createdAt: thread.created_at,
          updatedAt: thread.updated_at,
          message_count: thread.message_count || 0
        }));
        // Upstash: get total count
        const allThreads = await getData('memory_threads', { filters: [{ field: 'metadata.source', operator: 'eq', value: 'ai-sdk-ui' }] });
        count = allThreads.length;
        hasMore = threads.length === limit;
        return NextResponse.json({ threads, count, hasMore });
      } catch (err) {
        if (!(err instanceof UpstashAdapterError)) throw err;
        // Fallback to LibSQL
      }
    }

    // LibSQL fallback
    const db = getLibSQLClient();
    let sql = `
      SELECT 
        t.id, t.name, t.metadata, t.created_at, t.updated_at,
        (SELECT COUNT(*) FROM messages WHERE memory_thread_id = t.id) as message_count
      FROM memory_threads t
    `;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const args: any[] = [];
    sql += ` WHERE json_extract(t.metadata, '$.source') = 'ai-sdk-ui'`;
    if (search) {
      sql += ` AND t.name LIKE ?`;
      args.push(`%${search}%`);
    }
    sql += ` ORDER BY t.updated_at DESC LIMIT ? OFFSET ?`;
    args.push(limit, offset);
    const result = await db.execute({ sql, args });
    threads = result.rows.map((thread) => {
      let parsedMetadata: Record<string, unknown> = {};
      if (typeof thread.metadata === 'string') {
        try {
          parsedMetadata = JSON.parse(thread.metadata);
        } catch {
          parsedMetadata = {};
        }
      } else if (
        typeof thread.metadata === 'object' &&
        thread.metadata !== null &&
        !(thread.metadata instanceof ArrayBuffer)
      ) {
        parsedMetadata = thread.metadata as Record<string, unknown>;
      }
      return {
        id: thread.id,
        name: thread.name,
        metadata: parsedMetadata,
        createdAt: thread.created_at,
        updatedAt: thread.updated_at,
        message_count: thread.message_count || 0
      };
    });
    const countResult = await db.execute({
      sql: `SELECT COUNT(*) as count FROM memory_threads WHERE json_extract(metadata, '$.source') = 'ai-sdk-ui'`,
      args: []
    });
    count = Number(countResult.rows[0].count) || 0;
    hasMore = threads.length === limit;
    return NextResponse.json({ threads, count, hasMore });
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * POST /api/ai-sdk/threads
 * 
 * Create a new thread for AI SDK UI
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { name = 'New Chat', metadata = {} } = body;
    const provider = getMemoryProvider();
    const id = uuidv4();
    const now = new Date().toISOString();
    const threadMetadata = { ...metadata, source: 'ai-sdk-ui', created_at: now };

    if (provider === 'upstash') {
      try {
        await createItem('memory_threads', {
          id,
          name,
          metadata: threadMetadata,
          created_at: now,
          updated_at: now
        });
        return NextResponse.json({ id, name, metadata: threadMetadata, createdAt: now, updatedAt: now });
      } catch (err) {
        if (!(err instanceof UpstashAdapterError)) throw err;
        // Fallback to LibSQL
      }
    }

    // LibSQL fallback
    const db = getLibSQLClient();
    await db.execute({
      sql: `INSERT INTO memory_threads (id, name, metadata, created_at, updated_at) VALUES (?, ?, ?, ?, ?)` ,
      args: [id, name, JSON.stringify(threadMetadata), now, now]
    });
    return NextResponse.json({ id, name, metadata: threadMetadata, createdAt: now, updatedAt: now });
  } catch (error) {
    return handleApiError(error);
  }
}

================
File: app/api/auth/callback/admin-github/route.ts
================
import { NextResponse } from 'next/server'
import { getSupabaseClient } from '@/lib/memory/supabase'

/**
 * Admin GitHub OAuth callback handler
 * This route is called by Supabase after an admin authenticates with GitHub
 */
export async function GET(request: Request) {
  try {
    // Get the code and state from the URL
    const { searchParams, origin } = new URL(request.url)
    const code = searchParams.get('code')

    if (!code) {
      console.error('No code provided in GitHub callback')
      return NextResponse.redirect(`${origin}/admin/login?error=no_code`)
    }

    // Create a Supabase client
    const supabase = getSupabaseClient()

    // Exchange the code for a session
    const { data, error } = await supabase.auth.exchangeCodeForSession(code)

    if (error) {
      console.error('Error exchanging code for session:', error)
      return NextResponse.redirect(`${origin}/admin/login?error=auth_error`)
    }

    // TEMPORARY: Allow all authenticated users to access admin features
    // In a real app, you would check a role or a specific claim
    // For now, we'll allow any authenticated user to access admin features

    // Original admin check (commented out for now)
    // if (data.user.email !== 'owner@deanmachines.com') {
    //   console.error('User is not an admin:', data.user.email)
    //   return NextResponse.redirect(`${origin}/admin/login?error=not_admin`)
    // }

    // Handle successful authentication
    const forwardedHost = request.headers.get('x-forwarded-host') // original origin before load balancer
    const isLocalEnv = process.env.NODE_ENV === 'development'

    if (isLocalEnv) {
      // Local development environment
      return NextResponse.redirect(`${origin}/admin/dashboard`)
    } else if (forwardedHost) {
      // Production with load balancer
      return NextResponse.redirect(`https://${forwardedHost}/admin/dashboard`)
    } else {
      // Production without load balancer
      return NextResponse.redirect(`${origin}/admin/dashboard`)
    }
  } catch (error) {
    console.error('Unexpected error in GitHub callback:', error)
    return NextResponse.redirect(`${origin}/admin/login?error=unknown`)
  }
}

================
File: app/api/auth/callback/github/route.ts
================
import { NextResponse } from 'next/server'
import { getSupabaseClient } from '@/lib/memory/supabase'

/**
 * GitHub OAuth callback handler
 * This route is called by Supabase after a user authenticates with GitHub
 */
export async function GET(request: Request) {
  try {
    // Get the code and state from the URL
    const { searchParams, origin } = new URL(request.url)
    const code = searchParams.get('code')
    const next = searchParams.get('next') ?? '/'
    
    if (!code) {
      console.error('No code provided in GitHub callback')
      return NextResponse.redirect(`${origin}/auth/auth-code-error`)
    }
    
    // Create a Supabase client
    const supabase = getSupabaseClient()
    
    // Exchange the code for a session
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    
    if (error) {
      console.error('Error exchanging code for session:', error)
      return NextResponse.redirect(`${origin}/auth/auth-code-error`)
    }
    
    // Handle successful authentication
    const forwardedHost = request.headers.get('x-forwarded-host') // original origin before load balancer
    const isLocalEnv = process.env.NODE_ENV === 'development'
    
    if (isLocalEnv) {
      // Local development environment
      return NextResponse.redirect(`${origin}${next}`)
    } else if (forwardedHost) {
      // Production with load balancer
      return NextResponse.redirect(`https://${forwardedHost}${next}`)
    } else {
      // Production without load balancer
      return NextResponse.redirect(`${origin}${next}`)
    }
  } catch (error) {
    console.error('Unexpected error in GitHub callback:', error)
    return NextResponse.redirect(`${origin}/auth/auth-code-error`)
  }
}

================
File: app/api/auth/signin/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"

// POST /api/auth/signin - Sign in a user
export async function POST(request: Request) {
  try {
    const supabase = getSupabaseClient()
    const { email, password } = await request.json()

    if (!email || !password) {
      return NextResponse.json({ error: "Email and password are required" }, { status: 400 })
    }

    // Authenticate via Supabase Auth
    const { data, error } = await supabase.auth.signInWithPassword({ email, password })
    if (error) {
      return NextResponse.json({ error: error.message || "Invalid email or password" }, { status: 401 })
    }
    // Return user and session info
    return NextResponse.json({ user: data.user, session: data.session })
  } catch (error) {
    console.error("Error signing in user:", error)
    return NextResponse.json({ error: "Failed to sign in" }, { status: 500 })
  }
}

================
File: app/api/auth/signup/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { v4 as uuidv4 } from "uuid"

// POST /api/auth/signup - Register a new user
export async function POST(request: Request) {
  try {
    const supabase = getSupabaseClient ()
    const { email, password, name } = await request.json()

    if (!email || !password) {
      return NextResponse.json({ error: "Email and password are required" }, { status: 400 })
    }

    // Attempt to sign up the user with Supabase Auth
    const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          name: name || email.split("@")[0], // Optional: pass additional user metadata
        },
      },
    })

    if (signUpError) {
      // Check if the error is due to the user already existing
      if (signUpError.message.includes("User already registered")) {
        return NextResponse.json({ error: "User with this email already exists" }, { status: 409 })
      }
      console.error("Supabase sign up error:", signUpError)
      return NextResponse.json({ error: signUpError.message || "Failed to sign up user" }, { status: signUpError.status || 500 })
    }

    // Handle cases where sign up might require confirmation (email verification)
    // or if user is successfully created but session is null initially.
    if (!signUpData.user) {
        // This might happen if email confirmation is required.
        // Adjust response as needed for your application flow.
        return NextResponse.json({ message: "Sign up successful, please check your email for verification." })
    }


    // Return user information upon successful sign up
    return NextResponse.json({
      id: signUpData.user.id,
      email: signUpData.user.email,
      name: signUpData.user.user_metadata.name || email.split("@")[0],
      createdAt: signUpData.user.created_at,
    })
  } catch (error: any) {
    console.error("Error creating user:", error)
    const errorMessage = error instanceof Error ? error.message : "An unknown error occurred";
    return NextResponse.json({ error: "Failed to create user", details: errorMessage }, { status: 500 })
  }
}

================
File: app/api/chat/ai-sdk/threads/[id]/messages/route.ts
================
import { NextResponse } from "next/server";
import { createMemory } from "@/lib/memory/factory";
import { handleApiError } from "@/lib/api-error-handler";
import { z } from "zod";

// Define schemas for validation
const ThreadParamsSchema = z.object({
  id: z.string().uuid({ message: "Invalid thread ID format" })
});

const MessageQuerySchema = z.object({
  limit: z.coerce.number().int().positive().default(100)
});

const MessageRoleEnum = z.enum(["user", "assistant", "system", "tool"]);

const CreateMessageSchema = z.object({
  role: MessageRoleEnum,
  content: z.string().min(1, { message: "Message content cannot be empty" }),
  metadata: z.record(z.unknown()).optional().default({})
});

// Create memory instance using the factory
const memory = createMemory();

/**
 * GET /api/chat/ai-sdk/threads/[id]/messages
 *
 * Fetch messages for a specific AI SDK chat thread
 */
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    // Validate thread ID
    const paramsResult = ThreadParamsSchema.safeParse(params);
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid thread ID", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    const { id } = paramsResult.data;

    // Validate query parameters
    const url = new URL(request.url);
    const queryResult = MessageQuerySchema.safeParse({
      limit: url.searchParams.get("limit")
    });

    if (!queryResult.success) {
      return NextResponse.json(
        { error: "Invalid query parameters", details: queryResult.error.format() },
        { status: 400 }
      );
    }

    const { limit } = queryResult.data;

    // Load messages for the thread using memory factory
    const messages = await memory.loadMessages(id, limit);

    // Format messages for the client
    const formattedMessages = messages.map((message) => {
      let parsedMetadata: Record<string, unknown> = {};

      if (message.metadata) {
        if (typeof message.metadata === 'string') {
          try {
            parsedMetadata = JSON.parse(message.metadata);
          } catch {
            // If parsing fails, use empty object
            parsedMetadata = {};
          }
        } else {
          parsedMetadata = message.metadata;
        }
      }

      return {
        id: message.id,
        role: message.role,
        content: message.content,
        createdAt: message.created_at,
        metadata: parsedMetadata
      };
    });

    return NextResponse.json({
      messages: formattedMessages,
      count: formattedMessages.length
    });
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

/**
 * POST /api/chat/ai-sdk/threads/[id]/messages
 *
 * Add a message to a specific AI SDK chat thread
 */
export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    // Validate thread ID
    const paramsResult = ThreadParamsSchema.safeParse(params);
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid thread ID", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    const { id } = paramsResult.data;

    // Validate request body
    const body = await request.json();
    const bodyResult = CreateMessageSchema.safeParse(body);

    if (!bodyResult.success) {
      return NextResponse.json(
        { error: "Invalid message data", details: bodyResult.error.format() },
        { status: 400 }
      );
    }

    const { role, content, metadata } = bodyResult.data;

    // Save the message using memory factory
    const messageId = await memory.saveMessage(
      id,
      role as "user" | "assistant" | "system" | "tool",
      content,
      {
        count_tokens: true,
        generate_embeddings: role === "assistant", // Generate embeddings for assistant messages
        metadata: {
          ...metadata,
          source: 'ai-sdk-ui',
          timestamp: new Date().toISOString()
        }
      }
    );

    return NextResponse.json({
      id: messageId,
      role,
      content,
      createdAt: new Date().toISOString(),
      metadata: {
        ...metadata,
        source: 'ai-sdk-ui',
        timestamp: new Date().toISOString()
      }
    });
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

================
File: app/api/chat/ai-sdk/threads/[id]/route.ts
================
import { NextResponse } from "next/server";
import { createMemory } from "@/lib/memory/factory";
import { handleApiError } from "@/lib/api-error-handler";
import { z } from "zod";

// Define schemas for validation
const ThreadParamsSchema = z.object({
  id: z.string().uuid({ message: "Invalid thread ID format" })
});

const UpdateThreadSchema = z.object({
  name: z.string().min(1, { message: "Thread name cannot be empty" })
});

// Create memory instance using the factory
const memory = createMemory();

/**
 * GET /api/chat/ai-sdk/threads/[id]
 *
 * Fetch a specific AI SDK chat thread and its messages
 */
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    // Validate thread ID
    const paramsResult = ThreadParamsSchema.safeParse(params);
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid thread ID", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    const { id } = paramsResult.data;
    const url = new URL(request.url);
    const includeMessages = url.searchParams.get("messages") === "true";

    // Get thread details
    const thread = await memory.getMemoryThread(id);

    if (!thread) {
      return NextResponse.json({ error: "Thread not found" }, { status: 404 });
    }

    // Format thread for the client
    const formattedThread = {
      id: thread.id,
      name: thread.name,
      createdAt: thread.created_at,
      updatedAt: thread.updated_at,
      metadata: thread.metadata ?
        (typeof thread.metadata === 'string' ? JSON.parse(thread.metadata) : thread.metadata)
        : {}
    };

    // Include messages if requested
    if (includeMessages) {
      const messages = await memory.loadMessages(id);

      // Format messages for the client
      const formattedMessages = messages.map((message) => ({
        id: message.id || '',
        role: message.role,
        content: message.content,
        createdAt: message.created_at || new Date().toISOString(),
        metadata: message.metadata ?
          (typeof message.metadata === 'string' ? JSON.parse(message.metadata) : message.metadata)
          : {}
      }));
      return NextResponse.json({
        ...formattedThread,
        messages: formattedMessages
      });
    }

    return NextResponse.json(formattedThread);
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

/**
 * PATCH /api/chat/ai-sdk/threads/[id]
 *
 * Update a specific AI SDK chat thread
 */
export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    // Validate thread ID
    const paramsResult = ThreadParamsSchema.safeParse(params);
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid thread ID", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    const { id } = paramsResult.data;

    // Validate request body
    const body = await request.json();
    const bodyResult = UpdateThreadSchema.safeParse(body);

    if (!bodyResult.success) {
      return NextResponse.json(
        { error: "Invalid request body", details: bodyResult.error.format() },
        { status: 400 }
      );
    }

    const { name } = bodyResult.data;

    // Get thread details
    const thread = await memory.getMemoryThread(id);

    if (!thread) {
      return NextResponse.json({ error: "Thread not found" }, { status: 404 });
    }

    // Update thread using memory factory
    await memory.updateMemoryThread(id, {
      name,
      updated_at: new Date().toISOString()
    });

    return NextResponse.json({
      id,
      name,
      updatedAt: new Date().toISOString()
    });
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }

}

/**
 * DELETE /api/chat/ai-sdk/threads/[id]
 *
 * Delete a specific AI SDK chat thread
 */
export async function DELETE(
  _request: Request, // Prefix with underscore to indicate it's not used
  { params }: { params: { id: string } }
) {
  try {
    // Validate thread ID
    const paramsResult = ThreadParamsSchema.safeParse(params);
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid thread ID", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    const { id } = paramsResult.data;

    // Delete the thread using memory factory
    const success = await memory.deleteMemoryThread(id);

    if (!success) {
      return NextResponse.json({ error: "Failed to delete thread" }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

================
File: app/api/dashboard/activity/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"

export async function GET(request: Request) {
  try {
    // Get URL parameters
    const { searchParams } = new URL(request.url)
    const limit = parseInt(searchParams.get('limit') || '5')

    // Get Supabase client
    const supabase = getSupabaseClient()

    // In a real application, you would query your Supabase database
    // Here we're simulating the response for demonstration purposes

    // Check if we can connect to Supabase
    const { error: connectionError } = await supabase
      .from('models')
      .select('count')
      .limit(1)
      .single()

    if (connectionError) {
      console.error("Error connecting to Supabase:", connectionError)

      // Return mock data if we can't connect to Supabase
      return NextResponse.json({
        activities: [
          {
            id: "1",
            type: "agent_created",
            entityId: "agent-1",
            entityName: "Research Assistant",
            userId: "user-1",
            userName: "Sam Dean",
            userAvatar: "",
            timestamp: new Date(Date.now() - 1000 * 60 * 5).toISOString(), // 5 minutes ago
          },
          {
            id: "2",
            type: "model_added",
            entityId: "model-1",
            entityName: "Gemini Pro 1.5",
            userId: "user-1",
            userName: "Sam Dean",
            userAvatar: "",
            timestamp: new Date(Date.now() - 1000 * 60 * 30).toISOString(), // 30 minutes ago
          },
          {
            id: "3",
            type: "conversation_completed",
            entityId: "conv-1",
            entityName: "Project Planning",
            userId: "user-2",
            userName: "Alex Johnson",
            userAvatar: "",
            timestamp: new Date(Date.now() - 1000 * 60 * 60).toISOString(), // 1 hour ago
          },
          {
            id: "4",
            type: "tool_executed",
            entityId: "tool-1",
            entityName: "Web Search",
            userId: "user-1",
            userName: "Sam Dean",
            userAvatar: "",
            timestamp: new Date(Date.now() - 1000 * 60 * 120).toISOString(), // 2 hours ago
          },
          {
            id: "5",
            type: "agent_created",
            entityId: "agent-2",
            entityName: "Code Assistant",
            userId: "user-3",
            userName: "Taylor Smith",
            userAvatar: "",
            timestamp: new Date(Date.now() - 1000 * 60 * 180).toISOString(), // 3 hours ago
          }
        ].slice(0, limit),
        isMockData: true
      })
    }

    // If we can connect, get real activity data from the database
    const { data: activities, error } = await supabase
      .from('activity_log')
      .select('*')
      .order('timestamp', { ascending: false })
      .limit(limit)

    if (error) {
      console.error("Error fetching activity data:", error)
      throw error
    }

    return NextResponse.json({
      activities: activities || [],
      isMockData: false
    })

  } catch (error) {
    console.error("Error in dashboard activity API:", error)

    // Return mock data in case of error
    return NextResponse.json({
      activities: [
        {
          id: "1",
          type: "agent_created",
          entityId: "agent-1",
          entityName: "Research Assistant",
          userId: "user-1",
          userName: "Sam Dean",
          userAvatar: "",
          timestamp: new Date(Date.now() - 1000 * 60 * 5).toISOString(), // 5 minutes ago
        },
        {
          id: "2",
          type: "model_added",
          entityId: "model-1",
          entityName: "Gemini Pro 1.5",
          userId: "user-1",
          userName: "Sam Dean",
          userAvatar: "",
          timestamp: new Date(Date.now() - 1000 * 60 * 30).toISOString(), // 30 minutes ago
        },
        {
          id: "3",
          type: "conversation_completed",
          entityId: "conv-1",
          entityName: "Project Planning",
          userId: "user-2",
          userName: "Alex Johnson",
          userAvatar: "",
          timestamp: new Date(Date.now() - 1000 * 60 * 60).toISOString(), // 1 hour ago
        },
        {
          id: "4",
          type: "tool_executed",
          entityId: "tool-1",
          entityName: "Web Search",
          userId: "user-1",
          userName: "Sam Dean",
          userAvatar: "",
          timestamp: new Date(Date.now() - 1000 * 60 * 120).toISOString(), // 2 hours ago
        },
        {
          id: "5",
          type: "agent_created",
          entityId: "agent-2",
          entityName: "Code Assistant",
          userId: "user-3",
          userName: "Taylor Smith",
          userAvatar: "",
          timestamp: new Date(Date.now() - 1000 * 60 * 180).toISOString(), // 3 hours ago
        }
      ].slice(0, Number(searchParams.get('limit') || 10)),
      isMockData: true
    })
  }
}

================
File: app/api/models/[id]/route.ts
================
import { NextResponse } from "next/server"
import { getItemById, updateItem, deleteItem, getDrizzleClient } from "@/lib/memory/supabase"
import type { Model } from "@/types/models"
import { handleApiError } from "@/lib/api-error-handler"
import { models } from "@/db/supabase/schema"
import { eq } from "drizzle-orm"

export async function GET(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params

    // Try using Drizzle first
    if (process.env.USE_DRIZZLE === 'true') {
      try {
        const db = getDrizzleClient()
        const result = await db.select().from(models).where(eq(models.id, id)).limit(1)

        if (result.length === 0) {
          return NextResponse.json({ error: "Model not found" }, { status: 404 })
        }

        return NextResponse.json(result[0])
      } catch (drizzleError) {
        console.error("Error using Drizzle, falling back to Supabase:", drizzleError)
        // Continue to Supabase fallback
      }
    }

    // Fall back to Supabase client
    const model = await getItemById<Model>("models", id)

    if (!model) {
      return NextResponse.json({ error: "Model not found" }, { status: 404 })
    }

    return NextResponse.json(model)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const body = await request.json()

    // Format the data to match schema
    const updates: Partial<Model> = {}
    if (body.name !== undefined) updates.name = body.name
    if (body.provider !== undefined) updates.provider = body.provider
    if (body.modelId !== undefined) updates.model_id = body.modelId
    if (body.baseUrl !== undefined) updates.base_url = body.baseUrl
    if (body.apiKey !== undefined && body.apiKey !== "••••••••••••••••") updates.api_key = body.apiKey
    if (body.status !== undefined) updates.status = body.status as "active" | "inactive"

    // Try using Drizzle first
    if (process.env.USE_DRIZZLE === 'true') {
      try {
        const db = getDrizzleClient()

        // Update the model
        await db.update(models)
          .set(updates)
          .where(eq(models.id, id))

        // Get the updated model
        const result = await db.select().from(models).where(eq(models.id, id)).limit(1)

        if (result.length === 0) {
          return NextResponse.json({ error: "Model not found" }, { status: 404 })
        }

        return NextResponse.json(result[0])
      } catch (drizzleError) {
        console.error("Error using Drizzle, falling back to Supabase:", drizzleError)
        // Continue to Supabase fallback
      }
    }

    // Fall back to Supabase client
    const model = await updateItem<Model>("models", id, updates)

    return NextResponse.json(model)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params

    // Try using Drizzle first
    if (process.env.USE_DRIZZLE === 'true') {
      try {
        const db = getDrizzleClient()

        // Delete the model
        await db.delete(models).where(eq(models.id, id))

        return NextResponse.json({
          success: true,
        })
      } catch (drizzleError) {
        console.error("Error using Drizzle, falling back to Supabase:", drizzleError)
        // Continue to Supabase fallback
      }
    }

    // Fall back to Supabase client
    const success = await deleteItem("models", id)

    return NextResponse.json({
      success,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/models/route.ts
================
import { NextResponse } from "next/server"
import { getData, createItem } from "@/lib/memory/supabase"
import type { Model } from "@/types/models"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET() {
  try {
    const models = await getData<Model>("models", {
      orderBy: { column: "created_at", ascending: false },
    })

    return NextResponse.json({
      models,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()

    // Validate required fields
    if (!body.name || !body.provider || !body.modelId) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 })
    }

    // Format the data to match Supabase schema
    const modelData = {
      name: body.name,
      provider: body.provider,
      model_id: body.modelId,
      base_url: body.baseUrl || null,
      api_key: body.apiKey || "",
      status: body.status || "active",
      max_tokens: body.maxTokens || 4096,
      input_cost_per_token: body.inputCostPerToken || 0.00001,
      output_cost_per_token: body.outputCostPerToken || 0.00003,
      supports_vision: body.supportsVision || false,
      supports_functions: body.supportsFunctions || false,
      supports_streaming: body.supportsStreaming || true,
      default_temperature: body.defaultTemperature || 0.7,
      default_top_p: body.defaultTopP || 1.0,
      default_frequency_penalty: body.defaultFrequencyPenalty || 0.0,
      default_presence_penalty: body.defaultPresencePenalty || 0.0,
      context_window: body.contextWindow || 4096,
      description: body.description || null,
      category: body.category || "text",
      capabilities: body.capabilities || {
        text: true,
        vision: false,
        audio: false,
        video: false,
        functions: false,
        streaming: true,
        json_mode: false,
        fine_tuning: false,
        thinking: false,
        search_grounding: false,
        code_execution: false,
        structured_output: false,
        image_generation: false,
        video_generation: false,
        audio_generation: false
      },
      metadata: body.metadata || null,
    }

    const model = await createItem<Model>("models", modelData)

    return NextResponse.json(model)
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/observability/metrics/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { createTrace, logEvent } from "@/lib/langfuse-integration"

/**
 * API route for fetching system metrics data for observability dashboard
 * Provides system health metrics like CPU usage, memory usage, etc.
 */

export async function GET(request: Request) {
  try {
    // Get URL parameters
    const { searchParams } = new URL(request.url)
    const timeRange = searchParams.get('timeRange') || '24h'

    // Create a trace for this API call
    const trace = await createTrace({
      name: "observability_metrics_api",
      metadata: {
        timeRange,
        timestamp: new Date().toISOString()
      }
    })

    // Log API call event
    if (trace?.id) {
      await logEvent({
        traceId: trace.id,
        name: "api_call",
        metadata: {
          endpoint: "/api/observability/metrics",
          method: "GET",
          params: { timeRange },
          timestamp: new Date().toISOString()
        }
      })
    }

    // Get Supabase client
    const supabase = getSupabaseClient()

    // Convert time range to milliseconds
    let timeInMs = 24 * 60 * 60 * 1000 // Default: 24 hours
    if (timeRange === '1h') timeInMs = 60 * 60 * 1000
    if (timeRange === '6h') timeInMs = 6 * 60 * 60 * 1000
    if (timeRange === '7d') timeInMs = 7 * 24 * 60 * 60 * 1000
    if (timeRange === '30d') timeInMs = 30 * 24 * 60 * 60 * 1000

    const startTime = new Date(Date.now() - timeInMs).toISOString()

    // Check if we can connect to Supabase
    const { error: connectionError } = await supabase
      .from('system_metrics')
      .select('count')
      .limit(1)
      .single()

    if (connectionError) {
      console.error("Error connecting to Supabase:", connectionError)

      // Generate mock data points based on time range
      const dataPoints = generateTimeSeriesData(timeRange)

      // Return mock data if we can't connect to Supabase
      return NextResponse.json({
        metrics: {
          timeRange,
          dataPoints,
          summary: {
            avgCpuUsage: Math.round(dataPoints.reduce((sum, dp) => sum + dp.cpu_usage, 0) / dataPoints.length),
            avgMemoryUsage: Math.round(dataPoints.reduce((sum, dp) => sum + dp.memory_usage, 0) / dataPoints.length),
            avgResponseTime: Math.round(dataPoints.reduce((sum, dp) => sum + dp.average_response_time_ms, 0) / dataPoints.length),
            peakApiRequests: Math.max(...dataPoints.map(dp => dp.api_requests_per_minute)),
            totalRequests: dataPoints.reduce((sum, dp) => sum + dp.api_requests_per_minute, 0),
            avgActiveUsers: Math.round(dataPoints.reduce((sum, dp) => sum + dp.active_users, 0) / dataPoints.length)
          }
        },
        isMockData: true
      })
    }

    // If we can connect, get real metrics from the database
    const { data: metricsData, error } = await supabase
      .from('system_metrics')
      .select('*')
      .gte('timestamp', startTime)
      .order('timestamp', { ascending: true })

    if (error) {
      console.error("Error fetching metrics:", error)
      throw error
    }

    // Calculate summary metrics
    const summary = metricsData && metricsData.length > 0 ? {
      avgCpuUsage: Math.round(metricsData.reduce((sum, m) => sum + m.cpu_usage, 0) / metricsData.length),
      avgMemoryUsage: Math.round(metricsData.reduce((sum, m) => sum + m.memory_usage, 0) / metricsData.length),
      avgResponseTime: Math.round(metricsData.reduce((sum, m) => sum + m.average_response_time_ms, 0) / metricsData.length),
      peakApiRequests: Math.max(...metricsData.map(m => m.api_requests_per_minute)),
      totalRequests: metricsData.reduce((sum, m) => sum + m.api_requests_per_minute, 0),
      avgActiveUsers: Math.round(metricsData.reduce((sum, m) => sum + m.active_users, 0) / metricsData.length)
    } : null

    return NextResponse.json({
      metrics: {
        timeRange,
        dataPoints: metricsData || [],
        summary
      },
      isMockData: false
    })

  } catch (error) {
    console.error("Error in observability metrics API:", error)

    // Return error response
    return NextResponse.json({
      error: "Failed to fetch metrics",
      message: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 })
  }
}

// Helper function to generate time series data for mock metrics
function generateTimeSeriesData(timeRange: string) {
  let timeInMs = 24 * 60 * 60 * 1000 // Default: 24 hours
  let dataPoints = 24 // Default: hourly data points for 24 hours

  if (timeRange === '1h') {
    timeInMs = 60 * 60 * 1000
    dataPoints = 60 // Minute-by-minute for 1 hour
  } else if (timeRange === '6h') {
    timeInMs = 6 * 60 * 60 * 1000
    dataPoints = 72 // 5-minute intervals for 6 hours
  } else if (timeRange === '7d') {
    timeInMs = 7 * 24 * 60 * 60 * 1000
    dataPoints = 168 // Hourly for 7 days
  } else if (timeRange === '30d') {
    timeInMs = 30 * 24 * 60 * 60 * 1000
    dataPoints = 30 // Daily for 30 days
  }

  const now = Date.now()
  const result = []

  // Base values
  let cpuUsage = 30 + Math.random() * 20
  let memoryUsage = 40 + Math.random() * 20
  let dbConnections = 15 + Math.random() * 10
  let apiRequests = 50 + Math.random() * 30
  let responseTime = 250 + Math.random() * 100
  let activeUsers = 8 + Math.random() * 8

  // Generate data points with realistic variations
  for (let i = 0; i < dataPoints; i++) {
    // Add some randomness but maintain trends
    cpuUsage = Math.max(5, Math.min(95, cpuUsage + (Math.random() * 10 - 5)))
    memoryUsage = Math.max(10, Math.min(95, memoryUsage + (Math.random() * 8 - 4)))
    dbConnections = Math.max(1, Math.min(50, dbConnections + (Math.random() * 6 - 3)))
    apiRequests = Math.max(5, Math.min(200, apiRequests + (Math.random() * 20 - 10)))
    responseTime = Math.max(100, Math.min(1000, responseTime + (Math.random() * 50 - 25)))
    activeUsers = Math.max(1, Math.min(30, activeUsers + (Math.random() * 4 - 2)))

    // Add daily patterns for more realism
    const timeOffset = i / dataPoints
    const dailyPattern = Math.sin(timeOffset * Math.PI * 2) * 15

    result.push({
      id: `metric-${i}`,
      timestamp: new Date(now - timeInMs + (timeInMs * i / dataPoints)).toISOString(),
      cpu_usage: Math.round(cpuUsage + dailyPattern * 0.5),
      memory_usage: Math.round(memoryUsage + dailyPattern * 0.3),
      database_connections: Math.round(dbConnections + dailyPattern * 0.2),
      api_requests_per_minute: Math.round(apiRequests + dailyPattern),
      average_response_time_ms: Math.round(responseTime + dailyPattern * 2),
      active_users: Math.round(activeUsers + dailyPattern * 0.1)
    })
  }

  return result
}

================
File: app/api/observability/performance/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { createTrace, logEvent } from "@/lib/langfuse-integration"

/**
 * API route for fetching model performance data for observability dashboard
 * Provides performance metrics for different AI models like latency, tokens per second, etc.
 */

export async function GET(request: Request) {
  try {
    // Get URL parameters
    const { searchParams } = new URL(request.url)
    const timeRange = searchParams.get('timeRange') || '24h'
    const modelId = searchParams.get('modelId')

    // Create a trace for this API call
    const trace = await createTrace({
      name: "observability_performance_api",
      metadata: {
        timeRange,
        modelId,
        timestamp: new Date().toISOString()
      }
    })

    // Log API call event
    if (trace?.id) {
      await logEvent({
        traceId: trace.id,
        name: "api_call",
        metadata: {
          endpoint: "/api/observability/performance",
          method: "GET",
          params: { timeRange, modelId },
          timestamp: new Date().toISOString()
        }
      })
    }

    // Get Supabase client
    const supabase = getSupabaseClient()

    // Convert time range to milliseconds
    let timeInMs = 24 * 60 * 60 * 1000 // Default: 24 hours
    if (timeRange === '1h') timeInMs = 60 * 60 * 1000
    if (timeRange === '6h') timeInMs = 6 * 60 * 60 * 1000
    if (timeRange === '7d') timeInMs = 7 * 24 * 60 * 60 * 1000
    if (timeRange === '30d') timeInMs = 30 * 24 * 60 * 60 * 1000

    const startTime = new Date(Date.now() - timeInMs).toISOString()

    // Check if we can connect to Supabase
    const { error: connectionError } = await supabase
      .from('model_performance')
      .select('count')
      .limit(1)
      .single()

    if (connectionError) {
      console.error("Error connecting to Supabase:", connectionError)

      // Generate mock model performance data
      const models = [
        { id: "gemini-1.5-pro", provider: "google", displayName: "Gemini 1.5 Pro" },
        { id: "gpt-4o", provider: "openai", displayName: "GPT-4o" },
        { id: "claude-3-opus", provider: "anthropic", displayName: "Claude 3 Opus" },
        { id: "gemini-1.5-flash", provider: "google", displayName: "Gemini 1.5 Flash" },
        { id: "gpt-4-turbo", provider: "openai", displayName: "GPT-4 Turbo" }
      ]

      // Filter by model if specified
      const filteredModels = modelId
        ? models.filter(m => m.id === modelId)
        : models

      // Generate performance data for each model
      const modelPerformance = filteredModels.map(model => {
        // Generate time series data
        const timeSeriesData = generateModelTimeSeriesData(timeRange, model.id)

        // Calculate aggregated metrics
        const avgLatency = Math.round(timeSeriesData.reduce((sum, dp) => sum + dp.latency_ms, 0) / timeSeriesData.length)
        const avgTokensPerSecond = Math.round(timeSeriesData.reduce((sum, dp) => sum + dp.tokens_per_second, 0) / timeSeriesData.length)
        const totalRequests = timeSeriesData.reduce((sum, dp) => sum + dp.request_count, 0)
        const totalTokens = timeSeriesData.reduce((sum, dp) => sum + dp.total_tokens, 0)
        const successRate = Math.round(timeSeriesData.reduce((sum, dp) => sum + dp.success_rate, 0) / timeSeriesData.length)

        return {
          modelId: model.id,
          provider: model.provider,
          displayName: model.displayName,
          timeSeriesData,
          metrics: {
            avgLatency,
            avgTokensPerSecond,
            totalRequests,
            totalTokens,
            successRate
          }
        }
      })

      // Return mock data
      return NextResponse.json({
        performance: modelPerformance,
        isMockData: true
      })
    }

    // If we can connect, get real performance data from the database
    let query = supabase
      .from('model_performance')
      .select('*')
      .gte('timestamp', startTime)

    // Filter by model if specified
    if (modelId) {
      query = query.eq('modelId', modelId)
    }

    const { data: performanceData, error } = await query.order('timestamp', { ascending: true })

    if (error) {
      console.error("Error fetching performance data:", error)
      throw error
    }

    // Process and aggregate the data by model
    const modelMap = new Map()

    performanceData?.forEach(record => {
      if (!modelMap.has(record.modelId)) {
        modelMap.set(record.modelId, {
          modelId: record.modelId,
          provider: record.provider,
          displayName: record.displayName,
          timeSeriesData: [],
          metrics: {
            avgLatency: 0,
            avgTokensPerSecond: 0,
            totalRequests: 0,
            totalTokens: 0,
            successRate: 0
          }
        })
      }

      const modelData = modelMap.get(record.modelId)
      modelData.timeSeriesData.push(record)
    })

    // Calculate aggregated metrics for each model
    modelMap.forEach(modelData => {
      const timeSeriesData = modelData.timeSeriesData
      if (timeSeriesData.length > 0) {
        modelData.metrics = {
          avgLatency: Math.round(timeSeriesData.reduce((sum, dp) => sum + dp.latency_ms, 0) / timeSeriesData.length),
          avgTokensPerSecond: Math.round(timeSeriesData.reduce((sum, dp) => sum + dp.tokens_per_second, 0) / timeSeriesData.length),
          totalRequests: timeSeriesData.reduce((sum, dp) => sum + dp.request_count, 0),
          totalTokens: timeSeriesData.reduce((sum, dp) => sum + dp.total_tokens, 0),
          successRate: Math.round(timeSeriesData.reduce((sum, dp) => sum + dp.success_rate, 0) / timeSeriesData.length)
        }
      }
    })

    return NextResponse.json({
      performance: Array.from(modelMap.values()),
      isMockData: false
    })

  } catch (error) {
    console.error("Error in observability performance API:", error)

    // Return error response
    return NextResponse.json({
      error: "Failed to fetch performance data",
      message: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 })
  }
}

// Helper function to generate time series data for mock model performance
function generateModelTimeSeriesData(timeRange: string, modelId: string) {
  let timeInMs = 24 * 60 * 60 * 1000 // Default: 24 hours
  let dataPoints = 24 // Default: hourly data points for 24 hours

  if (timeRange === '1h') {
    timeInMs = 60 * 60 * 1000
    dataPoints = 60 // Minute-by-minute for 1 hour
  } else if (timeRange === '6h') {
    timeInMs = 6 * 60 * 60 * 1000
    dataPoints = 72 // 5-minute intervals for 6 hours
  } else if (timeRange === '7d') {
    timeInMs = 7 * 24 * 60 * 60 * 1000
    dataPoints = 168 // Hourly for 7 days
  } else if (timeRange === '30d') {
    timeInMs = 30 * 24 * 60 * 60 * 1000
    dataPoints = 30 // Daily for 30 days
  }

  const now = Date.now()
  const result = []

  // Base values - different for each model
  let baseLatency = 0
  let baseTokensPerSecond = 0
  let baseSuccessRate = 0

  // Set base values based on model
  if (modelId === "gemini-1.5-pro") {
    baseLatency = 800
    baseTokensPerSecond = 35
    baseSuccessRate = 98
  } else if (modelId === "gpt-4o") {
    baseLatency = 700
    baseTokensPerSecond = 40
    baseSuccessRate = 99
  } else if (modelId === "claude-3-opus") {
    baseLatency = 900
    baseTokensPerSecond = 30
    baseSuccessRate = 97
  } else if (modelId === "gemini-1.5-flash") {
    baseLatency = 400
    baseTokensPerSecond = 60
    baseSuccessRate = 96
  } else if (modelId === "gpt-4-turbo") {
    baseLatency = 600
    baseTokensPerSecond = 45
    baseSuccessRate = 98
  } else {
    baseLatency = 750
    baseTokensPerSecond = 38
    baseSuccessRate = 97
  }

  // Generate data points with realistic variations
  for (let i = 0; i < dataPoints; i++) {
    const timeOffset = i / dataPoints
    const dailyPattern = Math.sin(timeOffset * Math.PI * 2) * 0.2 // 20% variation based on time of day

    // Calculate values with some randomness and daily patterns
    const latency = Math.round(baseLatency * (1 + (Math.random() * 0.3 - 0.15) + dailyPattern))
    const tokensPerSecond = Math.round(baseTokensPerSecond * (1 + (Math.random() * 0.2 - 0.1) + dailyPattern))
    const successRate = Math.min(100, Math.max(90, baseSuccessRate + (Math.random() * 4 - 2)))
    const requestCount = Math.round(10 + Math.random() * 40 * (1 + dailyPattern))
    const totalTokens = requestCount * Math.round(500 + Math.random() * 1500)

    result.push({
      timestamp: new Date(now - timeInMs + (timeInMs * i / dataPoints)).toISOString(),
      modelId,
      latency_ms: latency,
      tokens_per_second: tokensPerSecond,
      request_count: requestCount,
      total_tokens: totalTokens,
      success_rate: successRate,
      error_count: Math.round(requestCount * (1 - successRate / 100))
    })
  }

  return result
}

================
File: app/api/observability/traces/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { createTrace, logEvent } from "@/lib/langfuse-integration"

/**
 * API route for fetching trace data for observability dashboard
 * Supports fetching a list of traces or a single trace by ID
 */
export async function GET(request: Request) {
  try {
    // Get URL parameters
    const { searchParams } = new URL(request.url)
    const limit = parseInt(searchParams.get('limit') || '50')
    const timeRange = searchParams.get('timeRange') || '24h'
    const traceId = searchParams.get('traceId')

    // Create a trace for this API call for meta-observability
    const trace = await createTrace({
      name: "observability_traces_api",
      metadata: {
        limit,
        timeRange,
        traceId,
        timestamp: new Date().toISOString()
      }
    })

    // Log API call event
    if (trace?.id) {
      await logEvent({
        traceId: trace.id,
        name: "api_call",
        metadata: {
          endpoint: "/api/observability/traces",
          method: "GET",
          params: { limit, timeRange, traceId },
          timestamp: new Date().toISOString()
        }
      })
    }

    // Get Supabase client
    const supabase = getSupabaseClient()

    // Convert time range to milliseconds
    const timeRangeMap: Record<string, number> = {
      '1h': 60 * 60 * 1000,
      '6h': 6 * 60 * 60 * 1000,
      '24h': 24 * 60 * 60 * 1000,
      '7d': 7 * 24 * 60 * 60 * 1000,
      '30d': 30 * 24 * 60 * 60 * 1000
    }

    const timeInMs = timeRangeMap[timeRange] || timeRangeMap['24h']
    const startTime = new Date(Date.now() - timeInMs).toISOString()

    // If traceId is provided, get specific trace details
    if (traceId) {
      try {
        // Try to connect to Supabase and get real data
        const { data: trace, error } = await supabase
          .from('traces')
          .select('*, spans(*), events(*)')
          .eq('id', traceId)
          .single()

        if (error) {
          console.warn("Falling back to mock data due to Supabase error:", error)
          return getDetailedMockTrace(traceId)
        }

        if (trace) {
          return NextResponse.json({
            trace,
            isMockData: false
          })
        }

        // If no trace found, return mock data
        return getDetailedMockTrace(traceId)
      } catch (error) {
        console.warn("Error connecting to Supabase:", error)
        return getDetailedMockTrace(traceId)
      }
    }

    // Otherwise, get list of traces
    try {
      // Try to get real traces from Supabase
      const { data: traces, error } = await supabase
        .from('traces')
        .select('*')
        .gte('startTime', startTime)
        .order('startTime', { ascending: false })
        .limit(limit)

      if (error) {
        console.warn("Falling back to mock trace list due to Supabase error:", error)
        return getMockTraceList(timeInMs)
      }

      if (traces && traces.length > 0) {
        return NextResponse.json({
          traces,
          isMockData: false
        })
      }

      // If no traces found, return mock data
      return getMockTraceList(timeInMs)
    } catch (error) {
      console.warn("Error connecting to Supabase:", error)
      return getMockTraceList(timeInMs)
    }
  } catch (error) {
    console.error("Error in observability traces API:", error)

    // Return error response
    return NextResponse.json({
      error: "Failed to fetch traces",
      message: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 })
  }
}

/**
 * Generate a detailed mock trace for a specific trace ID
 */
function getDetailedMockTrace(traceId: string) {
  const now = Date.now()
  const startTime = now - 1000 * 60 * 5 // 5 minutes ago
  const endTime = now - 1000 * 60 * 4 // 4 minutes ago

  // Generate model ID and provider
  const providers = ["google", "openai", "anthropic"]
  const models = {
    google: ["gemini-1.5-pro", "gemini-1.5-flash", "gemini-1.0-pro"],
    openai: ["gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo"],
    anthropic: ["claude-3-opus", "claude-3-sonnet", "claude-3-haiku"]
  }

  const provider = providers[Math.floor(Math.random() * providers.length)]
  const modelId = models[provider as keyof typeof models][Math.floor(Math.random() * 3)]

  // Generate spans with realistic timing
  const spanCount = Math.floor(Math.random() * 3) + 3 // 3-5 spans
  const spanDuration = (endTime - startTime) / spanCount

  const spans = []
  let currentTime = startTime

  const spanTypes = [
    "model_initialization",
    "prompt_construction",
    "model_inference",
    "tool_execution",
    "response_processing",
    "token_counting",
    "embedding_generation",
    "context_retrieval"
  ]

  for (let i = 0; i < spanCount; i++) {
    const spanType = spanTypes[Math.floor(Math.random() * spanTypes.length)]
    const spanStartTime = currentTime
    const thisSpanDuration = Math.floor(spanDuration * (0.5 + Math.random()))
    currentTime += thisSpanDuration

    spans.push({
      id: `span-${i + 1}`,
      name: spanType,
      startTime: new Date(spanStartTime).toISOString(),
      endTime: new Date(currentTime).toISOString(),
      duration: thisSpanDuration,
      status: Math.random() > 0.9 ? "error" : "success",
      metadata: getSpanMetadata(spanType, provider, modelId)
    })
  }

  // Generate events
  const events = [
    {
      id: "event-1",
      name: "trace_started",
      timestamp: new Date(startTime).toISOString(),
      metadata: { initiator: "user" }
    },
    {
      id: "event-2",
      name: "model_loaded",
      timestamp: new Date(startTime + 100).toISOString(),
      metadata: { model: modelId, provider }
    }
  ]

  // Add tool events if applicable
  if (Math.random() > 0.5) {
    const tools = ["web_search", "code_execution", "data_analysis", "image_generation"]
    const tool = tools[Math.floor(Math.random() * tools.length)]

    events.push({
      id: "event-3",
      name: "tool_called",
      timestamp: new Date(startTime + (endTime - startTime) * 0.6).toISOString(),
      metadata: { tool, params: JSON.stringify({ query: "sample query" }) }
    })

    events.push({
      id: "event-4",
      name: "tool_completed",
      timestamp: new Date(startTime + (endTime - startTime) * 0.7).toISOString(),
      metadata: { tool, status: "success" }
    })
  }

  // Add completion event
  events.push({
    id: `event-${events.length + 1}`,
    name: "trace_completed",
    timestamp: new Date(endTime).toISOString(),
    metadata: { status: "success" }
  })

  return NextResponse.json({
    trace: {
      id: traceId,
      name: ["chat_completion", "tool_execution", "model_inference", "data_processing"][Math.floor(Math.random() * 4)],
      startTime: new Date(startTime).toISOString(),
      endTime: new Date(endTime).toISOString(),
      duration: endTime - startTime,
      status: Math.random() > 0.1 ? "success" : "error",
      userId: `user-${Math.floor(Math.random() * 5) + 1}`,
      metadata: {
        modelId,
        provider,
        temperature: (Math.random() * 0.8 + 0.2).toFixed(1),
        maxTokens: [4096, 8192, 16384][Math.floor(Math.random() * 3)],
        hasTools: Math.random() > 0.5,
        messageCount: Math.floor(Math.random() * 10) + 1,
        inputTokens: Math.floor(Math.random() * 1000) + 100,
        outputTokens: Math.floor(Math.random() * 500) + 50
      },
      spans,
      events
    },
    isMockData: true
  })
}

/**
 * Generate metadata for a specific span type
 */
function getSpanMetadata(spanType: string, provider: string, modelId: string) {
  switch (spanType) {
    case "model_initialization":
      return { provider, modelId, cacheHit: Math.random() > 0.7 }
    case "prompt_construction":
      return { tokenCount: Math.floor(Math.random() * 1000) + 100, promptTemplate: "chat" }
    case "model_inference":
      return {
        outputTokens: Math.floor(Math.random() * 500) + 50,
        tokensPerSecond: Math.floor(Math.random() * 20) + 10
      }
    case "tool_execution":
      const tools = ["web_search", "code_execution", "data_analysis", "image_generation"]
      return { tool: tools[Math.floor(Math.random() * tools.length)] }
    case "response_processing":
      return { format: ["markdown", "json", "text"][Math.floor(Math.random() * 3)] }
    case "token_counting":
      return {
        inputTokens: Math.floor(Math.random() * 1000) + 100,
        outputTokens: Math.floor(Math.random() * 500) + 50,
        totalTokens: Math.floor(Math.random() * 1500) + 150
      }
    case "embedding_generation":
      return {
        model: `${provider}-embedding`,
        dimensions: [768, 1024, 1536][Math.floor(Math.random() * 3)],
        chunks: Math.floor(Math.random() * 5) + 1
      }
    case "context_retrieval":
      return {
        vectorDb: ["pinecone", "qdrant", "supabase"][Math.floor(Math.random() * 3)],
        matches: Math.floor(Math.random() * 5) + 1,
        threshold: (Math.random() * 0.3 + 0.7).toFixed(2)
      }
    default:
      return { spanType }
  }
}

/**
 * Generate a list of mock traces
 */
function getMockTraceList(timeInMs: number) {
  const traceCount = Math.floor(Math.random() * 15) + 15 // 15-30 traces

  const traces = Array.from({ length: traceCount }, (_, i) => {
    const startTime = Date.now() - Math.random() * timeInMs
    const duration = Math.floor(Math.random() * 60000) + 1000 // 1-61 seconds
    const endTime = startTime + duration

    const providers = ["google", "openai", "anthropic"]
    const models = {
      google: ["gemini-1.5-pro", "gemini-1.5-flash", "gemini-1.0-pro"],
      openai: ["gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo"],
      anthropic: ["claude-3-opus", "claude-3-sonnet", "claude-3-haiku"]
    }

    const provider = providers[Math.floor(Math.random() * providers.length)]
    const modelId = models[provider as keyof typeof models][Math.floor(Math.random() * 3)]

    return {
      id: `trace-${i + 1}`,
      name: ["chat_completion", "tool_execution", "model_inference", "data_processing"][Math.floor(Math.random() * 4)],
      startTime: new Date(startTime).toISOString(),
      endTime: new Date(endTime).toISOString(),
      duration,
      status: Math.random() > 0.1 ? "success" : "error",
      userId: `user-${Math.floor(Math.random() * 5) + 1}`,
      metadata: {
        modelId,
        provider,
        temperature: (Math.random() * 0.8 + 0.2).toFixed(1),
        maxTokens: [4096, 8192, 16384][Math.floor(Math.random() * 3)],
        hasTools: Math.random() > 0.5,
        messageCount: Math.floor(Math.random() * 10) + 1,
        inputTokens: Math.floor(Math.random() * 1000) + 100,
        outputTokens: Math.floor(Math.random() * 500) + 50
      }
    }
  })

  return NextResponse.json({
    traces,
    isMockData: true
  })
}

================
File: app/api/settings/route.ts
================
import { NextResponse } from "next/server"
import { getData, createItem, updateItem } from "@/lib/memory/supabase"
import type { Setting } from "@/types/settings"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET(request: Request) {
  try {
    const settingsArray = await getData<Setting>("settings")

    // Format settings as an object by category
    const settings: Record<string, Record<string, any>> = {}

    for (const setting of settingsArray) {
      if (!settings[setting.category]) {
        settings[setting.category] = {}
      }

      // Parse JSON values if possible
      try {
        settings[setting.category][setting.key] = JSON.parse(setting.value)
      } catch {
        settings[setting.category][setting.key] = setting.value
      }
    }

    return NextResponse.json({
      settings: [settings]
    })
  } catch (error) {
    return handleApiError(error)
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { category, settings } = body

    if (!category || !settings) {
      return NextResponse.json({ error: "Category and settings are required" }, { status: 400 })
    }

    // Get existing settings for this category
    const existingSettings = await getData<Setting>("settings", {
      filters: { category },
    })

    // Save each setting
    await Promise.all(
      Object.entries(settings).map(async ([key, value]) => {
        const stringValue = typeof value === "object" ? JSON.stringify(value) : String(value)

        // Format the data to match Supabase schema
        const settingData = {
          category,
          key,
          value: stringValue,
        }

        // Check if setting already exists
        const existingSetting = existingSettings.find((s) => s.key === key)

        if (existingSetting) {
          // Update existing setting
          await updateItem<Setting>("settings", existingSetting.id, settingData)
        } else {
          // Create new setting
          await createItem<Setting>("settings", settingData)
        }
      }),
    )

    return NextResponse.json({
      success: true,
    })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/system/status/route.ts
================
import { NextResponse } from "next/server"
import { isSupabaseAvailable } from "@/lib/memory/supabase"
import { isLibSQLAvailable } from "@/lib/memory/libsql"
import { handleApiError } from "@/lib/api-error-handler"

export async function GET() {
  try {
    // Check Supabase connection
    const supabaseAvailable = await isSupabaseAvailable()

    // Check LibSQL connection
    const libsqlAvailable = await isLibSQLAvailable()

    return NextResponse.json({
      status: [{
        status: "ok",
        timestamp: new Date().toISOString(),
        supabase: supabaseAvailable,
        libsql: libsqlAvailable,
        environment: process.env.NODE_ENV,
      }]
    })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/tools/[id]/route.ts
================
import { NextResponse } from "next/server"
import { getSupabaseClient } from "@/lib/memory/supabase"
import { handleApiError } from "@/lib/api-error-handler"
import { revalidatePath } from "next/cache"

export async function GET(_: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params

    const supabase = getSupabaseClient()

    const { data: tool, error } = await supabase.from("tools").select("*").eq("id", id).single()

    if (error) {
      if (error.code === "PGRST116") {
        return NextResponse.json({ error: "Tool not found" }, { status: 404 })
      }
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json(tool)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params
    const body = await request.json()

    // Validate parameters schema if provided
    if (body.parametersSchema) {
      try {
        JSON.parse(body.parametersSchema)
      } catch (e) {
        return NextResponse.json({ error: "Parameters schema must be valid JSON" }, { status: 400 })
      }
    }

    const supabase = getSupabaseClient()

    // Check if tool exists
    const { data: existingTool, error: checkError } = await supabase.from("tools").select("id").eq("id", id).single()

    if (checkError) {
      if (checkError.code === "PGRST116") {
        return NextResponse.json({ error: "Tool not found" }, { status: 404 })
      }
      return NextResponse.json({ error: checkError.message }, { status: 500 })
    }

    // Prepare update data
    const updateData: Record<string, any> = {}

    if (body.name !== undefined) updateData.name = body.name
    if (body.description !== undefined) updateData.description = body.description
    if (body.parametersSchema !== undefined) updateData.parameters_schema = body.parametersSchema
    if (body.category !== undefined) updateData.category = body.category
    if (body.implementation !== undefined) updateData.implementation = body.implementation
    if (body.isEnabled !== undefined) updateData.is_enabled = body.isEnabled

    // Update tool
    const { data: updatedTool, error } = await supabase.from("tools").update(updateData).eq("id", id).select().single()

    if (error) {
      console.error("Error updating tool:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Revalidate the tools page
    revalidatePath("/tools")

    return NextResponse.json(updatedTool)
  } catch (error) {
    return handleApiError(error)
  }
}

export async function DELETE(_: Request, { params }: { params: { id: string } }) {
  try {
    const { id } = params

    const supabase = getSupabaseClient()

    // Check if tool is being used by any agents
    const { data: usedByAgents, error: checkError } = await supabase
      .from("agent_tools")
      .select("agent_id")
      .eq("tool_id", id)

    if (checkError) {
      console.error("Error checking tool usage:", checkError)
      return NextResponse.json({ error: checkError.message }, { status: 500 })
    }

    if (usedByAgents && usedByAgents.length > 0) {
      return NextResponse.json(
        {
          error: "Cannot delete tool that is being used by agents",
          agentIds: usedByAgents.map((item) => item.agent_id),
        },
        { status: 409 },
      )
    }

    // Delete tool
    const { error } = await supabase.from("tools").delete().eq("id", id)

    if (error) {
      console.error("Error deleting tool:", error)
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Revalidate the tools page
    revalidatePath("/tools")

    return NextResponse.json({ success: true })
  } catch (error) {
    return handleApiError(error)
  }
}

================
File: app/api/crud/[table]/route.ts
================
/**
 * 
 * 
 * Generic CRUD API route for Supabase tables
 * @module app/api/crud/[table]/route
 */

import { NextRequest, NextResponse } from 'next/server'
import { getSupabaseClient, getDrizzleClient } from '@/lib/memory/supabase'
import { z } from 'zod'
import * as schema from '@/db/supabase/schema'
import { eq, desc, asc } from 'drizzle-orm'
import type { Database } from '@/types/supabase'

// Define allowed tables for security
const allowedTables = ['models', 'agents', 'tools', 'settings']

// Define a schema for the query parameters
const QuerySchema = z.object({
  limit: z.coerce.number().optional(),
  offset: z.coerce.number().optional(),
  orderBy: z.string().optional(),
  orderDir: z.enum(['asc', 'desc']).optional(),
})

/**
 * GET handler for retrieving items
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { table: string } }
) {
  const { table } = params

  // Security check: only allow specific tables
  if (!allowedTables.includes(table)) {
    return NextResponse.json(
      { error: 'Table not allowed' },
      { status: 403 }
    )
  }

  try {
    // Parse query parameters
    const url = new URL(request.url)
    const searchParams = Object.fromEntries(url.searchParams.entries())
    const { limit, offset, orderBy, orderDir } = QuerySchema.parse(searchParams)

    // Get ID from query params if it exists
    const id = url.searchParams.get('id')

    // Use Drizzle if enabled
    if (process.env.USE_DRIZZLE === 'true') {
      try {
        const db = getDrizzleClient()

        // Get the table schema dynamically
        const tableSchema = (schema as any)[table];

        if (!tableSchema) {
          console.error(`Table schema not found for ${table}, falling back to Supabase`);
          // Continue to Supabase fallback
        } else {
          // If ID is provided, get a single item
          if (id) {
            const result = await db.select()
              .from(tableSchema)
              .where(eq(tableSchema.id, id))
              .limit(1);

            if (result.length === 0) {
              return NextResponse.json(
                { error: 'Item not found' },
                { status: 404 }
              );
            }

            return NextResponse.json(result[0]);
          }

          // Otherwise, get all items with filters
          // For simplicity, we'll just get all items and filter in memory
          // This avoids TypeScript errors with dynamic table schemas
          const allItems = await db.select().from(tableSchema);

          // Filter and sort in memory
          let result = [...allItems];

          // Apply ordering
          if (orderBy && result.length > 0 && orderBy in result[0]) {
            result.sort((a: any, b: any) => {
              if (a[orderBy] < b[orderBy]) return orderDir === 'desc' ? 1 : -1;
              if (a[orderBy] > b[orderBy]) return orderDir === 'desc' ? -1 : 1;
              return 0;
            });
          }

          // Apply pagination
          if (offset !== undefined || limit !== undefined) {
            const start = offset || 0;
            const end = limit ? start + limit : undefined;
            result = result.slice(start, end);
          }

          return NextResponse.json(result);
        }
      } catch (drizzleError) {
        console.error("Error using Drizzle, falling back to Supabase:", drizzleError);
        // Continue to Supabase fallback
      }
    }

    // Fall back to Supabase client
    const supabase = getSupabaseClient()

    // If ID is provided, get a single item
    if (id) {
      const { data, error } = await supabase
        .from(table as keyof Database['public']['Tables'])
        .select('*')
        .eq('id', id)
        .single()

      if (error) {
        return NextResponse.json(
          { error: error.message },
          { status: error.code === '22P02' ? 400 : 500 }
        )
      }

      if (!data) {
        return NextResponse.json(
          { error: 'Item not found' },
          { status: 404 }
        )
      }

      return NextResponse.json(data)
    }

    // Otherwise, get all items with filters
    let query = supabase.from(table as keyof Database['public']['Tables']).select('*')

    // Apply ordering
    if (orderBy) {
      query = query.order(orderBy, { ascending: orderDir !== 'desc' })
    }

    // Apply pagination
    if (limit !== undefined) {
      query = query.limit(limit)

      if (offset !== undefined) {
        query = query.range(offset, offset + limit - 1)
      }
    }

    const { data, error } = await query

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json(data)
  } catch (error) {
    console.error(`Error in GET /${params.table}:`, error)

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid query parameters', details: error.errors },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * POST handler for creating items
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { table: string } }
) {
  const { table } = params

  // Security check: only allow specific tables
  if (!allowedTables.includes(table)) {
    return NextResponse.json(
      { error: 'Table not allowed' },
      { status: 403 }
    )
  }

  try {
    // Parse request body
    const body = await request.json()

    // Use Drizzle if enabled
    if (process.env.USE_DRIZZLE === 'true') {
      try {
        const db = getDrizzleClient()

        // Get the table schema dynamically
        const tableSchema = (schema as any)[table];

        if (!tableSchema) {
          console.error(`Table schema not found for ${table}, falling back to Supabase`);
          // Continue to Supabase fallback
        } else {
          // Insert the item
          const result = await db.insert(tableSchema).values(body).returning();

          if (result.length === 0) {
            return NextResponse.json(
              { error: 'Failed to create item' },
              { status: 500 }
            );
          }

          return NextResponse.json(result[0], { status: 201 });
        }
      } catch (drizzleError) {
        console.error("Error using Drizzle, falling back to Supabase:", drizzleError);
        // Continue to Supabase fallback
      }
    }

    // Fall back to Supabase client
    const supabase = getSupabaseClient()

    const { data, error } = await supabase
      .from(table as keyof Database['public']['Tables'])
      .insert(body)
      .select()
      .single()

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      )
    }

    return NextResponse.json(data, { status: 201 })
  } catch (error) {
    console.error(`Error in POST /${params.table}:`, error)

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * PATCH handler for updating items
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: { table: string } }
) {
  const { table } = params

  // Security check: only allow specific tables
  if (!allowedTables.includes(table)) {
    return NextResponse.json(
      { error: 'Table not allowed' },
      { status: 403 }
    )
  }

  try {
    // Parse request body
    const body = await request.json()

    // Get ID from query params
    const url = new URL(request.url)
    const id = url.searchParams.get('id')

    if (!id) {
      return NextResponse.json(
        { error: 'ID is required for updates' },
        { status: 400 }
      )
    }

    // Use Drizzle if enabled
    if (process.env.USE_DRIZZLE === 'true') {
      try {
        const db = getDrizzleClient()

        // Get the table schema dynamically
        const tableSchema = (schema as any)[table];

        if (!tableSchema) {
          console.error(`Table schema not found for ${table}, falling back to Supabase`);
          // Continue to Supabase fallback
        } else {
          // Update the item
          const result = await db.update(tableSchema)
            .set(body)
            .where(eq(tableSchema.id, id))
            .returning();

          if (result.length === 0) {
            return NextResponse.json(
              { error: 'Item not found' },
              { status: 404 }
            );
          }

          return NextResponse.json(result[0]);
        }
      } catch (drizzleError) {
        console.error("Error using Drizzle, falling back to Supabase:", drizzleError);
        // Continue to Supabase fallback
      }
    }

    // Fall back to Supabase client
    const supabase = getSupabaseClient()

    const { data, error } = await supabase
      .from(table as keyof Database['public']['Tables'])
      .update(body)
      .eq('id', id)
      .select()
      .single()

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      )
    }

    return NextResponse.json(data)
  } catch (error) {
    console.error(`Error in PATCH /${params.table}:`, error)

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE handler for deleting items
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { table: string } }
) {
  const { table } = params

  // Security check: only allow specific tables
  if (!allowedTables.includes(table)) {
    return NextResponse.json(
      { error: 'Table not allowed' },
      { status: 403 }
    )
  }

  try {
    // Get ID from query params
    const url = new URL(request.url)
    const id = url.searchParams.get('id')

    if (!id) {
      return NextResponse.json(
        { error: 'ID is required for deletion' },
        { status: 400 }
      )
    }

    // Use Drizzle if enabled
    if (process.env.USE_DRIZZLE === 'true') {
      try {
        const db = getDrizzleClient()

        // Get the table schema dynamically
        const tableSchema = (schema as any)[table];

        if (!tableSchema) {
          console.error(`Table schema not found for ${table}, falling back to Supabase`);
          // Continue to Supabase fallback
        } else {
          // Delete the item
          const result = await db.delete(tableSchema)
            .where(eq(tableSchema.id, id))
            .returning();

          // If no rows were affected, the item might not exist
          if (result.length === 0) {
            return NextResponse.json(
              { error: 'Item not found or already deleted' },
              { status: 404 }
            );
          }

          return NextResponse.json({ success: true });
        }
      } catch (drizzleError) {
        console.error("Error using Drizzle, falling back to Supabase:", drizzleError);
        // Continue to Supabase fallback
      }
    }

    // Fall back to Supabase client
    const supabase = getSupabaseClient()

    const { error } = await supabase
      .from(table as keyof Database['public']['Tables'])
      .delete()
      .eq('id', id)

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      )
    }

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error(`Error in DELETE /${params.table}:`, error)

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

================
File: app/api/ai-sdk/chat/route.ts
================
/**
 * AI SDK Chat API Route
 * 
 * This route handles chat requests using the AI SDK integration.
 * It supports multiple providers (Google, OpenAI, Anthropic) and
 * includes features like tool execution, middleware, and tracing.
 */

import { NextResponse } from "next/server";
import { streamWithAISDK, getAllAISDKTools } from "@/lib/ai-sdk-integration";
import { createMemory } from "@/lib/memory/factory";
import { handleApiError } from "@/lib/api-error-handler";
import { createTrace } from "@/lib/langfuse-integration";
import { personaManager } from "@/lib/agents/personas/persona-manager";
import { ModelSettings } from "@/lib/models/model-registry";
import { getModelById, getModelByModelId } from "@/lib/models/model-service";

const memory = createMemory();

/**
 * POST /api/ai-sdk/chat
 * 
 * Process a chat request using the AI SDK
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const {
      messages,
      threadId,
      model = "gemini-2.0-flash",
      temperature = 0.7,
      maxTokens = 8192,
      tools = [],
      attachments = [],
      images = [],
      provider = "google",
      systemPrompt,
      streamProtocol = "data",
      toolChoice = "auto",
      middleware = {}
    } = body;

    // Validate request
    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json(
        { error: "Invalid request: messages array is required" },
        { status: 400 }
      );
    }

    // Generate thread ID if not provided
    const chatThreadId = threadId || (await import("ai")).generateId();

    // Create trace for observability
    const trace = await createTrace({
      name: "ai_sdk_chat",
      userId: chatThreadId,
      metadata: {
        threadId: chatThreadId,
        model,
        temperature,
        maxTokens,
        toolCount: tools.length,
        messageCount: messages.length,
        hasAttachments: attachments.length > 0,
        hasImages: images.length > 0
      }
    });

    // Inline getModelConfiguration logic (Upstash/Supabase aware)
    let modelConfig: ModelSettings | undefined;
    try {
      const found = await getModelById(model) || await getModelByModelId(model);
      modelConfig = found === null ? undefined : found;
    } catch {
      modelConfig = undefined;
    }

    // Determine provider from model config or model name
    const modelProvider = modelConfig?.provider || provider || (model.startsWith("gpt") ? "openai" : model.startsWith("claude") ? "anthropic" : "google");

    // Get model settings
    const modelSettings: ModelSettings = modelConfig || {
      id: model,
      name: model,
      provider: modelProvider as "google" | "openai" | "anthropic" | "custom" | "vertex",
      model_id: model,
      max_tokens: 8192,
      input_cost_per_token: 0,
      output_cost_per_token: 0,
      supports_vision: modelProvider === "google" || (modelProvider === "openai" && model.includes("vision")),
      supports_functions: true,
      supports_streaming: true,
      default_temperature: 0.7,
      default_top_p: 1.0,
      default_frequency_penalty: 0,
      default_presence_penalty: 0,
      context_window: 1000000,
      description: undefined,
      category: "chat",
      capabilities: {},
      metadata: {},
      base_url: undefined,
      api_key: process.env[`${modelProvider.toUpperCase()}_API_KEY`],
      status: "active",
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    // Process messages and handle attachments/images
    const processedMessages = [...messages];

    // Add system prompt if provided
    let personaId: string | undefined;
    let personaSystemPrompt: string | null = null;

    if (systemPrompt) {
      // Add system prompt to the beginning of messages
      processedMessages.unshift({
        role: "system",
        content: systemPrompt
      });
    } else {
      // Try to get persona from the first message metadata
      const firstMessage = messages[0];
      if (firstMessage?.metadata?.personaId) {
        personaId = firstMessage.metadata.personaId as string;
        try {
          const persona = await personaManager.getPersonaById(personaId);
          if (persona?.systemPromptTemplate) {
            personaSystemPrompt = persona.systemPromptTemplate;
            processedMessages.unshift({
              role: "system",
              content: personaSystemPrompt
            });
          }
        } catch {}
      }
    }

    // Process images if supported
    if (images && images.length > 0 && modelSettings.supports_vision) {
      // Add images to the last user message
      const lastUserMessageIndex = processedMessages.findIndex(m => m.role === "user");
      if (lastUserMessageIndex !== -1) {
        const lastUserMessage = processedMessages[lastUserMessageIndex];
        processedMessages[lastUserMessageIndex] = {
          ...lastUserMessage,
          content: [
            { type: "text", text: lastUserMessage.content },
            ...images.map((image: string) => ({
              type: "image",
              image: Buffer.from(image.split(",")[1], "base64")
            }))
          ]
        };
      }
    }

    // Get effective max tokens
    const effectiveMaxTokens = maxTokens && maxTokens > 0
      ? Math.min(maxTokens, modelSettings.max_tokens)
      : modelSettings.max_tokens;

    // Process tools
    let toolConfigs: Record<string, unknown> = {};
    if (tools && tools.length > 0 && modelSettings.supports_functions) {
      try {
        // Get all available tools
        const allTools = await getAllAISDKTools();
        
        // Filter tools based on provided tool IDs or names
        toolConfigs = tools.reduce((acc: Record<string, unknown>, tool: string) => {
          if (Object.prototype.hasOwnProperty.call(allTools as Record<string, unknown>, tool)) acc[tool] = (allTools as Record<string, unknown>)[tool];
          return acc;
        }, {});
      } catch {}
    }

    // Create middleware
    const { createCompleteMiddleware } = await import("@/lib/middleware");
    const middlewareConfig = createCompleteMiddleware({
      ...middleware,
      languageModel: {
        ...middleware.languageModel,
        caching: {
          enabled: true,
          ttl: 1000 * 60 * 60, // 1 hour
          ...middleware.languageModel?.caching
        },
        logging: {
          enabled: true,
          ...middleware.languageModel?.logging
        }
      },
      requestResponse: {
        ...middleware.requestResponse,
        errorHandling: {
          enabled: true,
          retryOnRateLimit: true,
          maxRetries: 3,
          ...middleware.requestResponse?.errorHandling
        }
      }
    });

    // Use the AI SDK integration for enhanced capabilities
    const streamOptions = {
      provider: modelProvider as "google" | "openai" | "anthropic",
      modelId: modelSettings.model_id,
      messages: processedMessages,
      temperature: temperature || modelSettings.default_temperature,
      maxTokens: effectiveMaxTokens,
      contextWindow: modelSettings.context_window,
      tools: Object.keys(toolConfigs).length > 0 ? toolConfigs : undefined,
      apiKey: modelSettings.api_key,
      baseURL: modelSettings.base_url || undefined,
      traceName: "ai_sdk_chat_stream",
      userId: chatThreadId,
      metadata: {
        parentTraceId: trace?.id,
        threadId: chatThreadId,
        source: "ai-sdk-ui",
        modelSettings,
        personaId: personaId || undefined,
        hasSystemPrompt: !!systemPrompt || !!personaSystemPrompt,
        toolCount: Object.keys(toolConfigs).length,
        messageCount: processedMessages.length,
        hasImages: images && images.length > 0,
        hasAttachments: attachments && attachments.length > 0,
        toolChoice
      },
      middleware: middlewareConfig.languageModel // Pass only the language model middleware
    };

    // Save user message to memory
    const userMessage = messages[messages.length - 1];
    if (userMessage && userMessage.role === "user") {
      await memory.saveMessage(
        chatThreadId,
        "user",
        typeof userMessage.content === "string" ? userMessage.content : JSON.stringify(userMessage.content),
        {
          count_tokens: true,
          metadata: {
            ...userMessage.metadata,
            source: "ai-sdk-ui"
          }
        }
      );
    }

    // Stream the response
    const result = await streamWithAISDK(streamOptions);

    // Return the appropriate response based on the stream protocol
    if (streamProtocol === "text") {
      return result.toTextStreamResponse();
    } else {
      return result.toDataStreamResponse();
    }
  } catch (error) {
    return handleApiError(error);
  }
}

================
File: app/api/ai-sdk/tools/route.ts
================
import { NextResponse } from "next/server";
import { getLibSQLClient } from "@/lib/memory/db";
import { handleApiError } from "@/lib/api-error-handler";
import { getAllBuiltInTools, loadCustomTools, toolCategories } from "@/lib/tools";
import { agenticTools } from "@/lib/tools/agentic";
import { getAllAISDKTools } from "@/lib/ai-sdk-integration";
import { createTrace } from "@/lib/langfuse-integration";
import { getMemoryProvider } from "@/lib/memory/factory";
import { z } from "zod";

// Define schemas for validation
const ToolQuerySchema = z.object({
  category: z.string().optional(),
  search: z.string().optional().default(""),
  builtIn: z.enum(["true", "false"]).optional().default("true"),
  custom: z.enum(["true", "false"]).optional().default("true"),
  agentic: z.enum(["true", "false"]).optional().default("true")
});

/**
 * GET /api/ai-sdk/tools
 *
 * Fetch all available tools for use with AI SDK
 */
export async function GET(request: Request) {
  try {
    const url = new URL(request.url);

    // Parse and validate query parameters
    const queryResult = ToolQuerySchema.safeParse({
      category: url.searchParams.get("category"),
      search: url.searchParams.get("search") || "",
      builtIn: url.searchParams.get("builtIn") || "true",
      custom: url.searchParams.get("custom") || "true",
      agentic: url.searchParams.get("agentic") || "true"
    });

    if (!queryResult.success) {
      return NextResponse.json(
        { error: "Invalid query parameters", details: queryResult.error.format() },
        { status: 400 }
      );
    }

    const { category, search } = queryResult.data;
    const includeBuiltIn = queryResult.data.builtIn !== "false";
    const includeCustom = queryResult.data.custom !== "false";
    const includeAgentic = queryResult.data.agentic !== "false";

    // Get all tools using the AI SDK integration module
    const allTools = await getAllAISDKTools({
      includeBuiltIn,
      includeCustom,
      includeAgentic
    });

    // Get individual tool collections for categorization
    const builtInTools = includeBuiltIn ? getAllBuiltInTools() : {};

    // Get custom tools - try Upstash first if enabled
    let customTools: Record<string, { description: string; parameters: unknown }> = {};
    const provider = getMemoryProvider();

    if (includeCustom) {
      if (provider === 'upstash') {
        try {
          // Use a more specific type for Upstash tools table
          type UpstashToolRow = { name: string; description: string; parameters_schema: string; category?: string };
          const rawTools: Array<Record<string, unknown>> = await (await import("@/lib/memory/upstash/supabase-adapter")).getData('tools', {});
          const customToolsData: UpstashToolRow[] = rawTools.filter(
            (t): t is UpstashToolRow => typeof t.name === 'string' && typeof t.description === 'string' && typeof t.parameters_schema === 'string'
          );
          customTools = customToolsData.reduce((acc, tool) => {
            let parametersSchema: unknown = {};
            try {
              parametersSchema = JSON.parse(tool.parameters_schema);
            } catch {}
            acc[tool.name] = {
              description: tool.description || '',
              parameters: parametersSchema
            };
            return acc;
          }, {} as Record<string, { description: string; parameters: unknown }>);
        } catch {
          // fallback: normalize loadCustomTools result
          const loaded = await loadCustomTools();
          for (const [name, tool] of Object.entries(loaded)) {
            customTools[name] = {
              description: tool.description || '',
              parameters: tool.parameters || {}
            };
          }
        }
      } else {
        // fallback: normalize loadCustomTools result
        const loaded = await loadCustomTools();
        for (const [name, tool] of Object.entries(loaded)) {
          customTools[name] = {
            description: tool.description || '',
            parameters: tool.parameters || {}
          };
        }
      }
    }

    const agTools = includeAgentic ? agenticTools : {};

    // Helper to get tool category
    function getToolCategory(name: string): string {
      if (name in agTools) return "agentic";
      if (name in customTools) return "custom";
      for (const cat of toolCategories) {
        if (cat.id && name.toLowerCase().startsWith(cat.id)) {
          return cat.id;
        }
      }
      return "other";
    }

    // Format tools for response
    const formattedTools = Object.entries(allTools)
      .map(([name, tool]) => ({
        name,
        description: (tool as { description?: string }).description || '',
        category: getToolCategory(name),
        parameters: (tool as { parameters?: unknown }).parameters || {},
        isBuiltIn: name in builtInTools,
        isCustom: name in customTools,
        isAgentic: name in agTools
      }))
      .filter(tool => {
        // Apply category filter
        if (category && tool.category !== category) {
          return false;
        }

        // Apply search filter
        if (search && !tool.name.toLowerCase().includes(search.toLowerCase()) &&
            !(tool.description || "").toLowerCase().includes(search.toLowerCase())) {
          return false;
        }

        return true;
      });

    return NextResponse.json({ tools: formattedTools });
  } catch (error) {
    return handleApiError(error);
  }
}

// Define schemas for validation
const CreateToolSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }),
  description: z.string().min(1, { message: "Description is required" }),
  parametersSchema: z.union([z.string(), z.record(z.any())]),
  implementation: z.string().optional(),
  category: z.string().default("custom")
});

/**
 * POST /api/ai-sdk/tools
 *
 * Create a new custom tool
 */
export async function POST(request: Request) {
  try {
    // Parse and validate request body
    const body = await request.json();
    const validationResult = CreateToolSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        { error: "Invalid request body", details: validationResult.error.format() },
        { status: 400 }
      );
    }

    const { name, description, parametersSchema, implementation, category } = validationResult.data;

    // Validate parameters schema is valid JSON
    let parsedSchema;
    try {
      parsedSchema = typeof parametersSchema === 'string'
        ? JSON.parse(parametersSchema)
        : parametersSchema;
    } catch {
      return NextResponse.json({ error: "Parameters schema must be valid JSON" }, { status: 400 });
    }

    // Determine which provider to use
    const provider = getMemoryProvider();
    let toolId;
    let useLibSQL = false;
    const now = new Date().toISOString();

    if (provider === 'upstash') {
      try {
        // Check if tool with same name already exists
        const existingTools = await (await import("@/lib/memory/upstash/supabase-adapter")).getData('tools', {
          filters: [{ field: 'name', operator: 'eq', value: name }]
        });

        if (existingTools.length > 0) {
          return NextResponse.json({ error: "A tool with this name already exists" }, { status: 409 });
        }

        // Create new tool
        const toolData = {
          name,
          description,
          parameters_schema: JSON.stringify(parsedSchema),
          category,
          created_at: now,
          updated_at: now
        };

        const newTool = await (await import("@/lib/memory/upstash/supabase-adapter")).createItem('tools', toolData);
        toolId = newTool.id;

        // If implementation is provided, save it to the apps table
        if (implementation) {
          await (await import("@/lib/memory/upstash/supabase-adapter")).createItem('apps', {
            name,
            type: 'tool',
            code: implementation,
            created_at: now,
            updated_at: now
          });
        }

        // Create trace for tool creation
        await createTrace({
          name: "tool_created",
          metadata: {
            toolId,
            name,
            category,
            hasImplementation: !!implementation,
            provider: 'upstash'
          }
        });

        return NextResponse.json({
          id: toolId,
          name,
          description,
          parametersSchema: parsedSchema,
          category,
          createdAt: now,
          updatedAt: now
        });
      } catch {
        useLibSQL = true;
      }
    } else {
      useLibSQL = true;
    }

    // Fall back to LibSQL if needed
    if (useLibSQL) {
      const db = getLibSQLClient();

      // Check if tool with same name already exists
      const existingToolResult = await db.execute({
        sql: `SELECT id FROM tools WHERE name = ?`,
        args: [name]
      });

      if (existingToolResult.rows.length > 0) {
        return NextResponse.json({ error: "A tool with this name already exists" }, { status: 409 });
      }

      // Insert new tool
      const result = await db.execute({
        sql: `
          INSERT INTO tools (name, description, parameters_schema, category, created_at, updated_at)
          VALUES (?, ?, ?, ?, ?, ?)
          RETURNING id
        `,
        args: [
          name,
          description,
          JSON.stringify(parsedSchema),
          category,
          now,
          now
        ]
      });

      toolId = result.rows[0].id;

      // If implementation is provided, save it to the apps table
      if (implementation) {
        await db.execute({
          sql: `
            INSERT INTO apps (name, type, code, created_at, updated_at)
            VALUES (?, 'tool', ?, ?, ?)
          `,
          args: [name, implementation, now, now]
        });
      }

      // Create trace for tool creation
      await createTrace({
        name: "tool_created",
        metadata: {
          toolId,
          name,
          category,
          hasImplementation: !!implementation,
          provider: 'libsql'
        }
      });

      return NextResponse.json({
        id: toolId,
        name,
        description,
        parametersSchema: parsedSchema,
        category,
        createdAt: now,
        updatedAt: now
      });
    }
  } catch (error) {
    return handleApiError(error);
  }
}

================
File: app/api/chat/ai-sdk/threads/route.ts
================
import { NextResponse } from "next/server";
import { createMemory } from "@/lib/memory/factory";
import { handleApiError } from "@/lib/api-error-handler";
import { z } from "zod";

// Define schemas for validation
const ThreadQuerySchema = z.object({
  limit: z.coerce.number().int().positive().default(50),
  offset: z.coerce.number().int().min(0).default(0)
});

const CreateThreadSchema = z.object({
  name: z.string().optional().default('New Chat')
});

// Create memory instance using the factory
const memory = createMemory();

/**
 * GET /api/chat/ai-sdk/threads
 *
 * Fetch all AI SDK chat threads
 */
/**
 * GET /api/chat/ai-sdk/threads
 *
 * Retrieves a list of AI SDK chat threads with pagination support
 *
 * @param request - The incoming HTTP request
 * @returns A JSON response containing:
 * - threads: Formatted list of AI SDK chat threads
 * - count: Total number of threads returned
 * - hasMore: Indicates if more threads are available for pagination
 */
export async function GET(request: Request) {
  try {
    const url = new URL(request.url);

    // Validate and parse query parameters using Zod
    const queryResult = ThreadQuerySchema.safeParse({
      limit: url.searchParams.get("limit"),
      offset: url.searchParams.get("offset")
    });

    if (!queryResult.success) {
      return NextResponse.json(
        { error: "Invalid query parameters", details: queryResult.error.format() },
        { status: 400 }
      );
    }

    const { limit, offset } = queryResult.data;

    // Get threads with AI SDK UI metadata using memory factory
    const threads = await memory.listMemoryThreads({
      limit,
      offset
    });

    // Use the imported MemoryThread type

    // Filter and sort threads in code
    const filteredThreads = threads
      .filter((thread) => {
        let parsedMetadata: Record<string, unknown> = {};

        if (typeof thread.metadata === 'string') {
          try {
            parsedMetadata = JSON.parse(thread.metadata);
          } catch {
            parsedMetadata = {};
          }
        } else if (thread.metadata) {
          parsedMetadata = thread.metadata;
        }

        return parsedMetadata.source === 'ai-sdk-ui';
      })
      .sort((a, b) =>
        new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime()
      );

    // Format threads for the client
    const formattedThreads = filteredThreads.map((thread) => {
      let parsedMetadata: Record<string, unknown> = {};

      if (thread.metadata) {
        if (typeof thread.metadata === 'string') {
          try {
            parsedMetadata = JSON.parse(thread.metadata);
          } catch {
            // If parsing fails, use empty object
            parsedMetadata = {};
          }
        } else {
          parsedMetadata = thread.metadata;
        }
      }

      return {
        id: thread.id,
        name: thread.name || 'Untitled Chat',
        createdAt: thread.created_at,
        updatedAt: thread.updated_at,
        metadata: parsedMetadata
      };
    });

    return NextResponse.json({
      threads: formattedThreads,
      count: formattedThreads.length,
      hasMore: formattedThreads.length === limit
    });
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

/**
 * POST /api/chat/ai-sdk/threads
 *
 * Create a new AI SDK chat thread
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();

    // Validate request body using Zod
    const bodyResult = CreateThreadSchema.safeParse(body);

    if (!bodyResult.success) {
      return NextResponse.json(
        { error: "Invalid request body", details: bodyResult.error.format() },
        { status: 400 }
      );
    }

    const { name } = bodyResult.data;

    // Create a new thread with AI SDK UI metadata
    const threadId = await memory.createMemoryThread(name, {
      metadata: {
        source: 'ai-sdk-ui',
        created_at: new Date().toISOString()
      }
    });

    return NextResponse.json({
      id: threadId,
      name,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

================
File: app/api/ai-sdk/agents/[id]/route.ts
================
import { NextResponse } from "next/server";
import { handleApiError } from "@/lib/api-error-handler";
import { createTrace } from "@/lib/langfuse-integration";
import { agentRegistry } from "@/lib/agents/registry";
import { personaManager } from "@/lib/agents/personas/persona-manager";
import { getSupabaseClient } from "@/lib/memory/supabase";
import { getMemoryProvider } from "@/lib/memory/factory";
import { getData, getItemById, updateItem, deleteItem, createItem } from "@/lib/memory/upstash/supabase-adapter";
import { z } from "zod";

// Define a type for the agent from registry which might have different property names
interface RegistryAgent {
  id: string;
  name: string;
  description?: string;
  modelId?: string;
  model_id?: string;
  systemPrompt?: string;
  system_prompt?: string;
  tool_ids?: string[];
  persona_id?: string;
  createdAt?: string;
  created_at?: string;
  updatedAt?: string;
  updated_at?: string;
  [key: string]: string | string[] | undefined; // More specific type for additional properties
}
// Zod validation schemas
const ParamsSchema = z.object({
  id: z.string().uuid({ message: "Invalid agent ID format" })
});

const AgentUpdateSchema = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  modelId: z.string().optional(),
  toolIds: z.array(z.string()).optional(),
  systemPrompt: z.string().optional(),
  personaId: z.string().uuid().optional()
});

const AgentResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  modelId: z.string(),
  systemPrompt: z.string().optional(),
  toolIds: z.array(z.string()).default([]),
  personaId: z.string().optional(),
  persona: z.record(z.any()).optional(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional()
});

/**
 * GET /api/ai-sdk/agents/[id]
 *
 * Get details for a specific agent
 */
export async function GET(
  _request: Request,
  { params }: { params: { id: string } }
) {
  try {
    // Validate params
    const paramsResult = ParamsSchema.safeParse(params);
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid parameters", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    const { id } = paramsResult.data;

    // Initialize agent registry
    await agentRegistry.init();

    // Get agent from registry
    const agent = await agentRegistry.getAgent(id);

    if (!agent) {
      return NextResponse.json({ error: "Agent not found" }, { status: 404 });
    }

    // Cast agent to RegistryAgent type with proper type conversion
    const typedAgent = agent as unknown as RegistryAgent;

    // Get persona information if available
    let persona = null;
    const personaId = typedAgent.persona_id;

    if (personaId) {
      try {
        await personaManager.init();
        // Use getPersonaById which is the correct method
        persona = await personaManager.getPersonaById(personaId);
      } catch (error) {
        // Log error to trace instead of console
        await createTrace({
          name: "persona_fetch_error",
          userId: id,
          metadata: {
            agentId: id,
            personaId,
            error: error instanceof Error ? error.message : String(error)
          }
        });
      }
    }

    // Get tool IDs
    const toolIds = typedAgent.tool_ids || [];

    // Format response with proper type handling
    const response = {
      id: typedAgent.id,
      name: typedAgent.name,
      description: typedAgent.description || "",
      modelId: typedAgent.modelId || typedAgent.model_id || "",
      systemPrompt: typedAgent.systemPrompt || typedAgent.system_prompt || typedAgent.description || "",
      toolIds,
      personaId,
      persona,
      createdAt: typedAgent.createdAt || typedAgent.created_at || new Date().toISOString(),
      updatedAt: typedAgent.updatedAt || typedAgent.updated_at || new Date().toISOString()
    };

    // Validate response
    const validatedResponse = AgentResponseSchema.parse(response);

    return NextResponse.json(validatedResponse);
  } catch (error) {
    // Handle Upstash-specific errors with detailed error messages
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string; code?: string; status?: number };

      // Create a trace for the error
      await createTrace({
        name: "agent_error",
        userId: params?.id || 'unknown',
        metadata: {
          operation: "get_agent",
          agentId: params?.id || 'unknown',
          errorName: errorObj.name,
          errorMessage: errorObj.message || 'Unknown error',
          errorCode: errorObj.code,
          timestamp: new Date().toISOString()
        }
      });

      // Handle specific Upstash errors
      if (errorObj.name === 'UpstashAdapterError') {
        return NextResponse.json(
          {
            error: "Upstash adapter error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'ADAPTER_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'RedisStoreError') {
        return NextResponse.json(
          {
            error: "Redis store error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'REDIS_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          {
            error: "Upstash client error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'CLIENT_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'ConnectionError') {
        return NextResponse.json(
          {
            error: "Database connection error",
            message: errorObj.message || 'Failed to connect to the database',
            code: 'CONNECTION_ERROR'
          },
          { status: 503 }
        );
      } else if (errorObj.name === 'TimeoutError') {
        return NextResponse.json(
          {
            error: "Database timeout",
            message: errorObj.message || 'Database operation timed out',
            code: 'TIMEOUT_ERROR'
          },
          { status: 504 }
        );
      }
    }

    return handleApiError(error);
  }

}

/**
 * PATCH /api/ai-sdk/agents/[id]
 *
 * Update an agent
 */
export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    // Validate params
    const paramsResult = ParamsSchema.safeParse(params);
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid parameters", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    const { id } = paramsResult.data;

    // Parse and validate request body
    const body = await request.json();
    const bodyResult = AgentUpdateSchema.safeParse(body);

    if (!bodyResult.success) {
      return NextResponse.json(
        { error: "Invalid request body", details: bodyResult.error.format() },
        { status: 400 }
      );
    }

    const { name, description, modelId, toolIds, systemPrompt, personaId } = bodyResult.data;

    // Determine which provider to use
    const provider = getMemoryProvider();
    let existingAgent;
    let useLibSQL = false;

    if (provider === 'upstash') {
      try {
        // Use Upstash adapter
        existingAgent = await getItemById('agents', id);

        if (!existingAgent) {
          return NextResponse.json({ error: "Agent not found" }, { status: 404 });
        }

        // Prepare update data
        const updateData: Record<string, unknown> = {};
        if (name !== undefined) updateData.name = name;
        if (description !== undefined) updateData.description = description;
        if (modelId !== undefined) updateData.model_id = modelId;
        if (systemPrompt !== undefined) updateData.system_prompt = systemPrompt;
        if (personaId !== undefined) updateData.persona_id = personaId;
        updateData.updated_at = new Date().toISOString();

        // Update agent
        await updateItem('agents', id, updateData);

        // Handle tool associations if provided
        if (toolIds !== undefined) {
          // Get all existing tool associations
          const existingAssociations = await getData('agent_tools', {
            filters: [{ field: 'agent_id', operator: 'eq', value: id }]
          });

          // Delete existing tool associations
          for (const assoc of existingAssociations) {
            await deleteItem('agent_tools', assoc.id);
          }

          // Add new tool associations
          if (toolIds.length > 0) {
            for (const toolId of toolIds) {
              await createItem('agent_tools', {
                agent_id: id,
                tool_id: toolId,
                created_at: new Date().toISOString()
              });
            }
          }
        }
      } catch (error) {
        // Fall back to LibSQL if Upstash fails
        // Create a trace for the error
        await createTrace({
          name: "upstash_fallback",
          userId: id,
          metadata: {
            operation: "update_agent",
            agentId: id,
            error: error instanceof Error ? error.message : String(error)
          }
        });

        useLibSQL = true;
      }
    } else {
      useLibSQL = true;
    }

    // Fall back to LibSQL/Supabase if needed
    if (useLibSQL || provider === 'libsql') {
      // Get Supabase client
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const supabase: any = getSupabaseClient();
      try {
        // Check if agent exists
        const { data: agent, error: checkError } = await supabase
          .from("agents")
          .select()
          .eq("id", id)
          .single();

        if (checkError || !agent) {
          return NextResponse.json({ error: "Agent not found" }, { status: 404 });
        }

        existingAgent = agent;

        // Prepare update data
        const updateData: Record<string, unknown> = {};
        if (name !== undefined) updateData.name = name;
        if (description !== undefined) updateData.description = description;
        if (modelId !== undefined) updateData.model_id = modelId;
        if (systemPrompt !== undefined) updateData.system_prompt = systemPrompt;
        if (personaId !== undefined) updateData.persona_id = personaId;
        updateData.updated_at = new Date().toISOString();

        // Update agent
        const { error: updateError } = await supabase
          .from("agents")
          .update(updateData)
          .eq("id", id)
          .select()
          .single();

        if (updateError) {
          throw updateError;
        }

        // Update tool associations if provided
        if (toolIds !== undefined) {
          // Delete existing tool associations
          const { error: deleteError } = await supabase
            .from("agent_tools")
            .delete()
            .eq("agent_id", id);

          if (deleteError) {
            throw deleteError;
          }

          // Add new tool associations
          if (toolIds.length > 0) {
            interface ToolAssociation {
              agent_id: string;
              tool_id: string;
              created_at?: string;
            }
            const toolAssociations: ToolAssociation[] = toolIds.map((toolId: string) => ({
              agent_id: id,
              tool_id: toolId,
              created_at: new Date().toISOString()
            }));
            const { error: insertError } = await supabase
              .from("agent_tools")
              .insert(toolAssociations);
            if (insertError) {
              throw insertError;
            }
          }
        }
      } catch (error) {
        throw error;
      }
    }

    // Reload agent in registry
    await agentRegistry.reloadAgent(id);

    // Create trace for agent update
    await createTrace({
      name: "agent_updated",
      userId: id,
      metadata: {
        agentId: id,
        name: name || existingAgent.name,
        toolCount: toolIds?.length,
        provider
      }
    });

    // Prepare response
    const response = {
      id,
      name: name || existingAgent.name,
      description: description || existingAgent.description,
      modelId: modelId || existingAgent.model_id,
      systemPrompt: systemPrompt || existingAgent.system_prompt,
      toolIds: toolIds || existingAgent.tool_ids || [],
      personaId: personaId || existingAgent.persona_id,
      updatedAt: new Date().toISOString()
    };

    // Validate response
    const validatedResponse = AgentResponseSchema.parse(response);

    return NextResponse.json(validatedResponse);
  } catch (error) {
    // Handle Upstash-specific errors with detailed error messages
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string; code?: string; status?: number };

      // Create a trace for the error
      await createTrace({
        name: "agent_error",
        userId: params?.id || 'unknown',
        metadata: {
          operation: "update_agent",
          agentId: params?.id || 'unknown',
          errorName: errorObj.name,
          errorMessage: errorObj.message || 'Unknown error',
          errorCode: errorObj.code,
          timestamp: new Date().toISOString()
        }
      });

      // Handle specific Upstash errors
      if (errorObj.name === 'UpstashAdapterError') {
        return NextResponse.json(
          {
            error: "Upstash adapter error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'ADAPTER_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'RedisStoreError') {
        return NextResponse.json(
          {
            error: "Redis store error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'REDIS_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          {
            error: "Upstash client error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'CLIENT_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'ConnectionError') {
        return NextResponse.json(
          {
            error: "Database connection error",
            message: errorObj.message || 'Failed to connect to the database',
            code: 'CONNECTION_ERROR'
          },
          { status: 503 }
        );
      } else if (errorObj.name === 'TimeoutError') {
        return NextResponse.json(
          {
            error: "Database timeout",
            message: errorObj.message || 'Database operation timed out',
            code: 'TIMEOUT_ERROR'
          },
          { status: 504 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

/**
 * DELETE /api/ai-sdk/agents/[id]
 *
 * Delete an agent
 */
export async function DELETE(
  _request: Request,
  { params }: { params: { id: string } }
) {
  try {
    // Validate params
    const paramsResult = ParamsSchema.safeParse(params);
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid parameters", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    const { id } = paramsResult.data;

    // Determine which provider to use
    const provider = getMemoryProvider();
    let useLibSQL = false;
    let success = false;

    if (provider === 'upstash') {
      try {
        // Check if agent exists
        const existingAgent = await getItemById('agents', id);

        if (!existingAgent) {
          return NextResponse.json({ error: "Agent not found" }, { status: 404 });
        }

        // Get all tool associations
        const toolAssociations = await getData('agent_tools', {
          filters: [{ field: 'agent_id', operator: 'eq', value: id }]
        });

        // Delete tool associations first (foreign key constraint)
        for (const assoc of toolAssociations) {
          await deleteItem('agent_tools', assoc.id);
        }

        // Delete the agent
        success = await deleteItem('agents', id);

        if (!success) {
          return NextResponse.json({ error: "Failed to delete agent" }, { status: 500 });
        }
      } catch (error) {
        // Fall back to LibSQL if Upstash fails
        await createTrace({
          name: "upstash_fallback",
          userId: id,
          metadata: {
            operation: "delete_agent",
            agentId: id,
            error: error instanceof Error ? error.message : String(error)
          }
        });

        useLibSQL = true;
      }
    } else {
      useLibSQL = true;
    }

    // Fall back to LibSQL/Supabase if needed
    if (useLibSQL) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const supabase: any = getSupabaseClient();
      try {
        // Check if agent exists first
        const checkResult = await supabase.from("agents").select("id").eq("id", id).single();
        const existingAgent = checkResult.data;
        const checkError = checkResult.error;
        if (checkError || !existingAgent) {
          return NextResponse.json({ error: "Agent not found" }, { status: 404 });
        }
        // Delete agent tools first (foreign key constraint)
        await supabase.from("agent_tools").delete().eq("agent_id", id);
        // Delete agent
        const deleteResult = await supabase.from("agents").delete().eq("id", id);
        const error = deleteResult.error;
        if (error) {
          throw error;
        }
        success = true;
      } catch (error) {
        throw error;
      }
    }

    // Create trace for agent deletion
    await createTrace({
      name: "agent_deleted",
      userId: id,
      metadata: {
        agentId: id,
        timestamp: new Date().toISOString(),
        provider: useLibSQL ? 'libsql' : 'upstash'
      }
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    // Handle Upstash-specific errors with detailed error messages
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string; code?: string; status?: number };

      // Create a trace for the error
      await createTrace({
        name: "agent_error",
        userId: params?.id || 'unknown',
        metadata: {
          operation: "delete_agent",
          agentId: params?.id || 'unknown',
          errorName: errorObj.name,
          errorMessage: errorObj.message || 'Unknown error',
          errorCode: errorObj.code,
          timestamp: new Date().toISOString()
        }
      });

      // Handle specific Upstash errors
      if (errorObj.name === 'UpstashAdapterError') {
        return NextResponse.json(
          {
            error: "Upstash adapter error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'ADAPTER_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'RedisStoreError') {
        return NextResponse.json(
          {
            error: "Redis store error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'REDIS_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          {
            error: "Upstash client error",
            message: errorObj.message || 'Unknown error',
            code: errorObj.code || 'CLIENT_ERROR'
          },
          { status: errorObj.status || 500 }
        );
      } else if (errorObj.name === 'ConnectionError') {
        return NextResponse.json(
          {
            error: "Database connection error",
            message: errorObj.message || 'Failed to connect to the database',
            code: 'CONNECTION_ERROR'
          },
          { status: 503 }
        );
      } else if (errorObj.name === 'TimeoutError') {
        return NextResponse.json(
          {
            error: "Database timeout",
            message: errorObj.message || 'Database operation timed out',
            code: 'TIMEOUT_ERROR'
          },
          { status: 504 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

================
File: app/api/ai-sdk/agents/route.ts
================
import { NextResponse } from "next/server";
import { handleApiError } from "@/lib/api-error-handler";
import { createTrace } from "@/lib/langfuse-integration";
import { v4 as uuidv4 } from "uuid";
import { z } from "zod";
import { getMemoryProvider } from "@/lib/memory/factory";

// Import Upstash adapter functions
import {
  getData,
  getItemById,
  createItem,
  updateItem,
  deleteItem
} from "@/lib/memory/upstash/supabase-adapter";

// Helper functions for Upstash operations
/**
 * Updates an agent in Upstash
 *
 * @param id - Agent ID
 * @param updates - Updates to apply
 * @returns Updated agent
 */
async function updateAgentInUpstash(id: string, updates: Record<string, unknown>) {
  // First check if agent exists
  const existingAgent = await getItemById('agents', id);

  if (!existingAgent) {
    throw new Error(`Agent with ID ${id} not found`);
  }

  // Add updated_at timestamp
  const updatedData = {
    ...updates,
    updated_at: new Date().toISOString()
  };

  // Update the agent
  return updateItem('agents', id, updatedData);
}

/**
 * Deletes an agent from Upstash
 *
 * @param id - Agent ID
 * @returns Whether deletion was successful
 */
async function deleteAgentFromUpstash(id: string) {
  // First check if agent exists
  const existingAgent = await getItemById('agents', id);

  if (!existingAgent) {
    throw new Error(`Agent with ID ${id} not found`);
  }

  // First delete related agent_tools
  const agentTools = await getData('agent_tools', {
    filters: [{ field: 'agent_id', operator: 'eq' as const, value: id }]
  });

  for (const tool of agentTools) {
    await deleteItem('agent_tools', tool.id);
  }

  // Then delete the agent
  return deleteItem('agents', id);
}

// Import LibSQL client for fallback
import { getLibSQLClient } from "@/lib/memory/db";

// Define schemas for validation
const AgentQuerySchema = z.object({
  search: z.string().optional().default(""),
  limit: z.coerce.number().int().positive().default(50),
  offset: z.coerce.number().int().min(0).default(0)
});

const CreateAgentSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }),
  description: z.string().optional().default(""),
  modelId: z.string().min(1, { message: "Model ID is required" }),
  toolIds: z.array(z.string()).optional().default([]),
  systemPrompt: z.string().optional().default("")
});

const UpdateAgentSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }).optional(),
  description: z.string().optional(),
  modelId: z.string().optional(),
  toolIds: z.array(z.string()).optional(),
  systemPrompt: z.string().optional(),
  personaId: z.string().uuid().optional()
});

const AgentParamsSchema = z.object({
  id: z.string().uuid({ message: "Invalid agent ID format" })
});
/**
 * GET /api/ai-sdk/agents
 *
 * Fetch all available agents with their tools and models
 */
export async function GET(request: Request) {
  try {
    const url = new URL(request.url);

    // Validate and parse query parameters using Zod
    const queryResult = AgentQuerySchema.safeParse({
      search: url.searchParams.get("search"),
      limit: url.searchParams.get("limit"),
      offset: url.searchParams.get("offset")
    });

    if (!queryResult.success) {
      return NextResponse.json(
        { error: "Invalid query parameters", details: queryResult.error.format() },
        { status: 400 }
      );
    }

    const { search, limit, offset } = queryResult.data;

    // Determine which provider to use
    const provider = getMemoryProvider();

    if (provider === 'upstash') {
      try {
        // Get agents from Upstash
        const filters = search ? [
          { field: 'name', operator: 'ilike' as const, value: search },
          { field: 'description', operator: 'ilike' as const, value: search }
        ] : undefined;

        const agents = await getData('agents', {
          filters,
          limit,
          offset,
          orderBy: { column: 'created_at', ascending: false }
        });

        // Format agents with their models and tools
        const formattedAgents = await Promise.all(agents.map(async (agent) => {
          // Get model details
          const model = await getItemById('models', agent.model_id);

          // Get tools for this agent
          const agentTools = await getData('agent_tools', {
            filters: [{ field: 'agent_id', operator: 'eq', value: agent.id }]
          });

          // Get tool details
          const tools = await Promise.all(agentTools.map(async (agentTool) => {
            const tool = await getItemById('tools', agentTool.tool_id);
            return tool ? {
              id: tool.id,
              name: tool.name,
              description: tool.description,
              parametersSchema: tool.parameters_schema ?
                (typeof tool.parameters_schema === 'string' ?
                  JSON.parse(tool.parameters_schema) : tool.parameters_schema) : {}
            } : null;
          }));

          // Filter out null tools
          const validTools = tools.filter(Boolean);

          return {
            id: agent.id,
            name: agent.name,
            description: agent.description,
            systemPrompt: agent.system_prompt,
            createdAt: agent.created_at,
            updatedAt: agent.updated_at,
            model: model ? {
              id: model.id,
              name: model.name,
              provider: model.provider
            } : null,
            tools: validTools
          };
        }));

        // Get total count
        const allAgents = await getData('agents');
        const count = allAgents.length;

        return NextResponse.json({
          agents: formattedAgents,
          count,
          hasMore: formattedAgents.length === limit
        });
      } catch (error) {
        // If Upstash fails, fall back to LibSQL
        // Create trace for error with detailed logging
        await createTrace({
          name: "upstash_fallback",
          userId: "system",
          metadata: {
            operation: "list_agents",
            error: error instanceof Error ? error.message : String(error),
            timestamp: new Date().toISOString()
          }
        });

        // TODO: Add proper logging mechanism
      }
    }

    // Fall back to LibSQL if Upstash is not configured or failed
    const db = getLibSQLClient();

    // Query to get agents with their models and tools
    let sql = `
      SELECT
        a.id, a.name, a.description, a.system_prompt, a.created_at, a.updated_at,
        m.id as model_id, m.name as model_name, m.provider as model_provider
      FROM agents a
      JOIN models m ON a.model_id = m.id
    `;

    // Add search condition if provided
    if (search) {
      sql += ` WHERE a.name LIKE '%${search}%' OR a.description LIKE '%${search}%'`;
    }

    // Add pagination
    sql += ` ORDER BY a.created_at DESC LIMIT ${limit} OFFSET ${offset}`;

    const agentsResult = await db.execute({ sql, args: [] });

    // Format agents
    const agents = await Promise.all(agentsResult.rows.map(async (agent) => {
      // Get tools for this agent
      const toolsResult = await db.execute({
        sql: `
          SELECT t.id, t.name, t.description, t.parameters_schema
          FROM tools t
          JOIN agent_tools at ON t.id = at.tool_id
          WHERE at.agent_id = ?
        `,
        args: [agent.id]
      });

      return {
        id: agent.id,
        name: agent.name,
        description: agent.description,
        systemPrompt: agent.system_prompt,
        createdAt: agent.created_at,
        updatedAt: agent.updated_at,
        model: {
          id: agent.model_id,
          name: agent.model_name,
          provider: agent.model_provider
        },
        tools: toolsResult.rows.map((tool) => ({
          id: tool.id,
          name: tool.name,
          description: tool.description,
          parametersSchema: tool.parameters_schema && typeof tool.parameters_schema === 'string' ?
            JSON.parse(tool.parameters_schema) : {}
        }))
      };
    }));

    // Get total count
    const countResult = await db.execute({
      sql: `SELECT COUNT(*) as count FROM agents`,
      args: []
    });

    return NextResponse.json({
      agents,
      count: countResult.rows[0].count,
      hasMore: agents.length === limit
    });
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'UpstashAdapterError' || errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

/**
 * POST /api/ai-sdk/agents
 *
 * Create a new agent
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();

    // Validate request body using Zod
    const bodyResult = CreateAgentSchema.safeParse(body);

    if (!bodyResult.success) {
      return NextResponse.json(
        { error: "Invalid request body", details: bodyResult.error.format() },
        { status: 400 }
      );
    }

    const { name, description, modelId, toolIds, systemPrompt } = bodyResult.data;

    // Determine which provider to use
    const provider = getMemoryProvider();

    if (provider === 'upstash') {
      try {
        // Check if model exists
        const model = await getItemById('models', modelId);

        if (!model) {
          return NextResponse.json({ error: "Model not found" }, { status: 404 });
        }

        // Create agent
        const id = uuidv4();
        const now = new Date().toISOString();

        // Create the agent in Upstash
        await createItem('agents', {
          id,
          name,
          description,
          model_id: modelId,
          system_prompt: systemPrompt,
          created_at: now,
          updated_at: now
        });

        // Add tools to agent
        for (const toolId of toolIds) {
          await createItem('agent_tools', {
            agent_id: id,
            tool_id: toolId,
            created_at: now
          });
        }

        // Create trace for agent creation
        await createTrace({
          name: "agent_created",
          userId: id,
          metadata: {
            agentId: id,
            name,
            modelId,
            toolCount: toolIds.length,
            provider: 'upstash'
          }
        });

        return NextResponse.json({
          id,
          name,
          description,
          systemPrompt,
          modelId,
          toolIds,
          createdAt: now,
          updatedAt: now
        });
      } catch (error) {
        // If Upstash fails, fall back to LibSQL
        // Create trace for error with detailed logging
        await createTrace({
          name: "upstash_fallback",
          userId: "system",
          metadata: {
            operation: "create_agent",
            error: error instanceof Error ? error.message : String(error),
            timestamp: new Date().toISOString()
          }
        });

        // TODO: Add proper logging mechanism
      }
    }

    // Fall back to LibSQL if Upstash is not configured or failed
    const db = getLibSQLClient();

    // Get model details
    const modelResult = await db.execute({
      sql: `SELECT * FROM models WHERE id = ?`,
      args: [modelId]
    });

    if (modelResult.rows.length === 0) {
      return NextResponse.json({ error: "Model not found" }, { status: 404 });
    }

    // Create agent
    const id = uuidv4();
    const now = new Date().toISOString();

    await db.execute({
      sql: `
        INSERT INTO agents (id, name, description, model_id, system_prompt, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `,
      args: [id, name, description || "", modelId, systemPrompt, now, now]
    });

    // Add tools to agent
    for (const toolId of toolIds) {
      await db.execute({
        sql: `INSERT INTO agent_tools (agent_id, tool_id) VALUES (?, ?)`,
        args: [id, toolId]
      });
    }

    // Create trace for agent creation
    await createTrace({
      name: "agent_created",
      userId: id,
      metadata: {
        agentId: id,
        name,
        modelId,
        toolCount: toolIds.length,
        provider: 'libsql'
      }
    });

    return NextResponse.json({
      id,
      name,
      description,
      systemPrompt,
      modelId,
      toolIds,
      createdAt: now,
      updatedAt: now
    });
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'UpstashAdapterError' || errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

/**
 * PATCH /api/ai-sdk/agents/:id
 *
 * Update an existing agent
 */
export async function PATCH(request: Request) {
  try {
    // Extract agent ID from URL
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/');
    const id = pathParts[pathParts.length - 1];

    // Validate agent ID
    const paramsResult = AgentParamsSchema.safeParse({ id });
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid agent ID", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    // Parse and validate request body
    const body = await request.json();
    const bodyResult = UpdateAgentSchema.safeParse(body);

    if (!bodyResult.success) {
      return NextResponse.json(
        { error: "Invalid request body", details: bodyResult.error.format() },
        { status: 400 }
      );
    }

    const { name, description, modelId, toolIds, systemPrompt, personaId } = bodyResult.data;

    // Determine which provider to use
    const provider = getMemoryProvider();
    let existingAgent;
    let useLibSQL = false;

    if (provider === 'upstash') {
      try {
        // Check if agent exists
        existingAgent = await getItemById('agents', id);

        if (!existingAgent) {
          return NextResponse.json({ error: "Agent not found" }, { status: 404 });
        }

        // Prepare update data
        const updateData: Record<string, unknown> = {};
        if (name !== undefined) updateData.name = name;
        if (description !== undefined) updateData.description = description;
        if (modelId !== undefined) updateData.model_id = modelId;
        if (systemPrompt !== undefined) updateData.system_prompt = systemPrompt;
        if (personaId !== undefined) updateData.persona_id = personaId;
        updateData.updated_at = new Date().toISOString();

        // Update agent using the helper function
        await updateAgentInUpstash(id, updateData);

        // Handle tool associations if provided
        if (toolIds !== undefined) {
          // Get all existing tool associations
          const existingAssociations = await getData('agent_tools', {
            filters: [{ field: 'agent_id', operator: 'eq', value: id }]
          });

          // Delete existing tool associations
          for (const assoc of existingAssociations) {
            await deleteItem('agent_tools', assoc.id);
          }

          // Add new tool associations
          if (toolIds.length > 0) {
            for (const toolId of toolIds) {
              await createItem('agent_tools', {
                agent_id: id,
                tool_id: toolId,
                created_at: new Date().toISOString()
              });
            }
          }
        }

        // Create trace for agent update
        await createTrace({
          name: "agent_updated",
          userId: id,
          metadata: {
            agentId: id,
            name: name || existingAgent.name,
            toolCount: toolIds?.length,
            provider: 'upstash'
          }
        });

        // Get updated agent
        const updatedAgent = await getItemById('agents', id);

        if (!updatedAgent) {
          return NextResponse.json({ error: "Failed to retrieve updated agent" }, { status: 500 });
        }

        // Get tools for this agent
        const agentTools = await getData('agent_tools', {
          filters: [{ field: 'agent_id', operator: 'eq', value: id }]
        });

        const toolIdList = agentTools.map(tool => tool.tool_id);

        // Prepare response
        return NextResponse.json({
          id,
          name: updatedAgent.name,
          description: updatedAgent.description,
          modelId: updatedAgent.model_id,
          systemPrompt: updatedAgent.system_prompt,
          personaId: updatedAgent.persona_id,
          toolIds: toolIdList,
          updatedAt: updatedAgent.updated_at
        });
      } catch (error) {
        // Create trace for error with detailed logging
        await createTrace({
          name: "upstash_fallback",
          userId: id,
          metadata: {
            operation: "update_agent",
            agentId: id,
            error: error instanceof Error ? error.message : String(error),
            timestamp: new Date().toISOString()
          }
        });

        // TODO: Add proper logging mechanism instead of console.error

        // Fall back to LibSQL
        useLibSQL = true;
      }
    } else {
      useLibSQL = true;
    }

    // Fall back to LibSQL if needed
    if (useLibSQL) {
      const db = getLibSQLClient();

      try {
        // Check if agent exists
        const result = await db.execute({
          sql: `SELECT * FROM agents WHERE id = ?`,
          args: [id]
        });

        if (result.rows.length === 0) {
          return NextResponse.json({ error: "Agent not found" }, { status: 404 });
        }

        existingAgent = result.rows[0];

        // Prepare update data
        const updateFields = [];
        const updateValues = [];

        if (name !== undefined) {
          updateFields.push('name = ?');
          updateValues.push(name);
        }

        if (description !== undefined) {
          updateFields.push('description = ?');
          updateValues.push(description);
        }

        if (modelId !== undefined) {
          updateFields.push('model_id = ?');
          updateValues.push(modelId);
        }

        if (systemPrompt !== undefined) {
          updateFields.push('system_prompt = ?');
          updateValues.push(systemPrompt);
        }

        if (personaId !== undefined) {
          updateFields.push('persona_id = ?');
          updateValues.push(personaId);
        }

        const now = new Date().toISOString();
        updateFields.push('updated_at = ?');
        updateValues.push(now);

        // Add ID to values
        updateValues.push(id);

        // Update agent
        await db.execute({
          sql: `
            UPDATE agents
            SET ${updateFields.join(', ')}
            WHERE id = ?
          `,
          args: updateValues
        });

        // Update tool associations if provided
        if (toolIds !== undefined) {
          // Delete existing tool associations
          await db.execute({
            sql: `DELETE FROM agent_tools WHERE agent_id = ?`,
            args: [id]
          });

          // Add new tool associations
          if (toolIds.length > 0) {
            for (const toolId of toolIds) {
              await db.execute({
                sql: `INSERT INTO agent_tools (agent_id, tool_id) VALUES (?, ?)`,
                args: [id, toolId]
              });
            }
          }
        }

        // Get updated tool IDs
        const toolsResult = await db.execute({
          sql: `SELECT tool_id FROM agent_tools WHERE agent_id = ?`,
          args: [id]
        });

        const toolIdList = toolsResult.rows.map(row => row.tool_id);

        // Create trace for agent update
        await createTrace({
          name: "agent_updated",
          userId: id,
          metadata: {
            agentId: id,
            name: name || existingAgent.name,
            toolCount: toolIds?.length,
            provider: 'libsql'
          }
        });

        // Prepare response
        return NextResponse.json({
          id,
          name: name || existingAgent.name,
          description: description || existingAgent.description,
          modelId: modelId || existingAgent.model_id,
          systemPrompt: systemPrompt || existingAgent.system_prompt,
          personaId: personaId || existingAgent.persona_id,
          toolIds: toolIdList,
          updatedAt: now
        });
      } catch (error) {
        throw error;
      }
    }
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'UpstashAdapterError' || errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

/**
 * DELETE /api/ai-sdk/agents/:id
 *
 * Delete an agent
 */
export async function DELETE(request: Request) {
  try {
    // Extract agent ID from URL
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/');
    const id = pathParts[pathParts.length - 1];

    // Validate agent ID
    const paramsResult = AgentParamsSchema.safeParse({ id });
    if (!paramsResult.success) {
      return NextResponse.json(
        { error: "Invalid agent ID", details: paramsResult.error.format() },
        { status: 400 }
      );
    }

    // Determine which provider to use
    const provider = getMemoryProvider();
    let useLibSQL = false;
    let success = false;

    if (provider === 'upstash') {
      try {
        // Delete agent using the helper function
        success = await deleteAgentFromUpstash(id);

        if (!success) {
          return NextResponse.json({ error: "Failed to delete agent" }, { status: 500 });
        }

        // Create trace for agent deletion
        await createTrace({
          name: "agent_deleted",
          userId: id,
          metadata: {
            agentId: id,
            timestamp: new Date().toISOString(),
            provider: 'upstash'
          }
        });

        return NextResponse.json({ success: true });
      } catch (error) {
        // If error is "not found", return 404
        if (error instanceof Error && error.message.includes('not found')) {
          return NextResponse.json({ error: "Agent not found" }, { status: 404 });
        }

        // Create trace for error with detailed logging
        await createTrace({
          name: "upstash_fallback",
          userId: id,
          metadata: {
            operation: "delete_agent",
            agentId: id,
            error: error instanceof Error ? error.message : String(error),
            timestamp: new Date().toISOString()
          }
        });

        // TODO: Add proper logging mechanism instead of console.error

        // Fall back to LibSQL
        useLibSQL = true;
      }
    } else {
      useLibSQL = true;
    }

    // Fall back to LibSQL if needed
    if (useLibSQL) {
      const db = getLibSQLClient();

      try {
        // Check if agent exists
        const checkResult = await db.execute({
          sql: `SELECT id FROM agents WHERE id = ?`,
          args: [id]
        });

        if (checkResult.rows.length === 0) {
          return NextResponse.json({ error: "Agent not found" }, { status: 404 });
        }

        // Delete agent tools first (foreign key constraint)
        await db.execute({
          sql: `DELETE FROM agent_tools WHERE agent_id = ?`,
          args: [id]
        });

        // Delete agent
        await db.execute({
          sql: `DELETE FROM agents WHERE id = ?`,
          args: [id]
        });

        // Create trace for agent deletion
        await createTrace({
          name: "agent_deleted",
          userId: id,
          metadata: {
            agentId: id,
            timestamp: new Date().toISOString(),
            provider: 'libsql'
          }
        });

        return NextResponse.json({ success: true });
      } catch (error) {
        throw error;
      }
    }
  } catch (error: unknown) {
    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'UpstashAdapterError' || errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}

================
File: app/api/ai-sdk/tools/execute/route.ts
================
import { NextResponse } from "next/server";
import { handleApiError } from "@/lib/api-error-handler";
import { getAllBuiltInTools, loadCustomTools } from "@/lib/tools";
import { agenticTools } from "@/lib/tools/agentic";
import { getAllAISDKTools } from "@/lib/ai-sdk-integration";
import { getMemoryProvider } from "@/lib/memory/factory";
import { v4 as uuidv4 } from "uuid";
import { z } from "zod";

// Local type for dynamic tool execution
interface DynamicTool {
  execute: (params: Record<string, unknown>, options: { toolCallId: string }) => Promise<unknown>;
}

const ToolExecuteSchema = z.object({
  toolName: z.string().min(1, { message: "Tool name is required" }),
  parameters: z.record(z.unknown()).optional().default({}),
  traceId: z.string().optional()
});

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const validationResult = ToolExecuteSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        { error: "Invalid request body", details: validationResult.error.format() },
        { status: 400 }
      );
    }
    const { toolName, parameters } = validationResult.data;
    const builtInTools = getAllBuiltInTools();
    const customTools = await loadCustomTools();
    const agTools = agenticTools;
    const allTools = await getAllAISDKTools({
      includeBuiltIn: true,
      includeCustom: true,
      includeAgentic: true
    });
    let tool: unknown;
    if (Object.prototype.hasOwnProperty.call(builtInTools, toolName)) {
      tool = (builtInTools as Record<string, unknown>)[toolName];
    } else if (Object.prototype.hasOwnProperty.call(customTools, toolName)) {
      tool = (customTools as Record<string, unknown>)[toolName];
    } else if (Object.prototype.hasOwnProperty.call(agTools, toolName)) {
      tool = (agTools as Record<string, unknown>)[toolName];
    } else if (Object.prototype.hasOwnProperty.call(allTools, toolName)) {
      tool = (allTools as Record<string, unknown>)[toolName];
    }
    if (
      !tool ||
      typeof tool !== "object" ||
      tool === null ||
      typeof (tool as { execute?: unknown }).execute !== "function"
    ) {
      return NextResponse.json({ error: `Tool '${toolName}' not found` }, { status: 404 });
    }
    const executionId = uuidv4();
    const startTime = Date.now();
    let result;
    try {
      result = await (tool as DynamicTool).execute(parameters, { toolCallId: executionId });
    } catch (err) {
      return NextResponse.json({ error: `Tool execution failed: ${err instanceof Error ? err.message : String(err)}` }, { status: 500 });
    }
    const executionTime = Date.now() - startTime;
    const provider = getMemoryProvider();
    if (provider === 'upstash') {
      try {
        // Use explicit type for tool_executions row
        type ToolExecutionRow = {
          id: string;
          tool_name: string;
          parameters: string;
          result: string;
          status: string;
          execution_time: number;
          created_at: string;
        };
        const executionRow: ToolExecutionRow = {
          id: executionId,
          tool_name: toolName,
          parameters: JSON.stringify(parameters),
          result: JSON.stringify(result),
          status: 'success',
          execution_time: executionTime,
          created_at: new Date().toISOString()
        };
        await (await import("@/lib/memory/upstash/supabase-adapter")).createItem('tool_executions', executionRow);
      } catch {
        // fallback: do not throw, just skip logging if Upstash fails
      }
    }
    return NextResponse.json({ result, executionTime });
  } catch (error) {
    return handleApiError(error);
  }
}

================
File: app/api/chat/route.ts
================
/**
 * Handles the POST request for chat interactions, supporting both AI SDK UI and regular chat requests.
 * 
 * @param {Request} request - The incoming HTTP request containing chat parameters
 * @returns {Promise<NextResponse>} A response with chat completion or error details
 * 
 * @description
 * This route handler manages two types of chat request flows:
 * 1. AI SDK UI requests (identified by specific headers)
 * 2. Regular chat requests with messages, model configuration, and optional parameters
 * 
 * Key features:
 * - Validates request content and required parameters
 * - Retrieves model configuration from Supabase
 * - Supports dynamic model selection and configuration
 * - Handles potential errors in model retrieval
 */
import { NextResponse } from "next/server";
// Remove StreamingTextResponse, import streamText and CoreMessage
import { streamText, type CoreMessage } from 'ai';
import { streamGoogleAIWithTracing } from "@/lib/ai-sdk-tracing";
import { getSupabaseClient } from "@/lib/memory/supabase";
import { getLibSQLClient } from "@/lib/memory/libsql";
import { handleApiError } from "@/lib/api-error-handler";
import { createTrace, logEvent } from "@/lib/langfuse-integration";
import { getGoogleAI } from "@/lib/ai"; // getGoogleAI from lib/ai.ts returns a LanguageModelProvider
import type { Database } from '@/types/supabase'

export async function POST(request: Request) {
  try {
    // Check if the request is from AI SDK UI
    const contentType = request.headers.get('content-type') || '';
    const isAiSdkRequest = contentType.includes('application/json') &&
      request.headers.get('x-ai-sdk') === 'true';

    const body = await request.json();

    // Handle AI SDK UI requests
    if (isAiSdkRequest || body.api === '/api/chat') {
      return handleAiSdkRequest(body);
    }

    // Handle regular chat requests
    const {
      messages,
      modelId,
      threadId,
      temperature = 0.7,
      maxTokens,
      tools = [],
      attachments = []
    } = body;

    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json({ error: "Messages are required" }, { status: 400 });
    }

    // Get model configuration from Supabase
    const supabase = getSupabaseClient();
    const { data: modelConfig, error: modelError } = await supabase
      .from<{ id: string; model_id: string; name: string; provider?: string; api_key?: string; base_url?: string }>("models")
      .select("*")
      .eq("id", modelId || process.env.DEFAULT_MODEL_ID)
      .single();
    if (modelError || !modelConfig) {
      console.error("Error fetching model:", modelError);
      return NextResponse.json({ error: "Model not found" }, { status: 404 });
    }

    // Get tool configurations if tools are specified
    const toolConfigs: Record<string, any> = {};
    if (tools && tools.length > 0) {
      const { data: toolData, error: toolError } = await supabase.from("tools").select("*").in("id", tools);

      if (!toolError && toolData) {
        for (const tool of toolData) {
          try {
            toolConfigs[tool.name] = {
              description: tool.description,
              parameters: typeof tool.parameters_schema === 'string'
                ? JSON.parse(tool.parameters_schema)
                : tool.parameters_schema || {},
            };
          } catch (e) {
            console.error(`Error parsing tool schema for ${tool.name}:`, e);
          }
        }
      }
    }

    const processedMessages: CoreMessage[] = messages.map((msg: any) => ({
      role: msg.role === 'model' ? 'assistant' : msg.role, // Ensure 'model' maps to 'assistant'
      content: msg.content,
      // tool_calls and tool_responses would go here if applicable
    }));

    if (attachments && attachments.length > 0 && processedMessages.length > 0) {
      const lastMessage = processedMessages[processedMessages.length - 1];
      if (lastMessage.role === 'user' && typeof lastMessage.content === 'string') {
        const attachmentDescriptions = attachments
          .map((att: { type: string; name: string }) => `[${att.type === 'image' ? 'Image' : 'File'}: ${att.name}]`)
          .join('\n');
        lastMessage.content = `${lastMessage.content}\n\n${attachmentDescriptions}`;
      }
    }

    if (threadId) {
      const db = getLibSQLClient();
      const userMessage = processedMessages.find((m) => m.role === "user");
      if (userMessage && typeof userMessage.content === 'string') {
        await db.execute({
          sql: `
            INSERT INTO messages (thread_id, role, content, created_at)
            VALUES (?, ?, ?, datetime('now'))
          `,
          args: [threadId, "user", userMessage.content],
        });
      }
    }

    const trace = await createTrace({
      name: "chat_interaction",
      userId: threadId || undefined,
      metadata: {
        modelId: modelConfig.model_id,
        modelName: modelConfig.name,
        provider: modelConfig.provider || "google",
        messageCount: processedMessages.length,
        hasTools: Object.keys(toolConfigs).length > 0,
        threadId: threadId || undefined
      }
    });

    if (trace?.id) {
      const userMessageContent = processedMessages.find(m => m.role === "user")?.content;
      await logEvent({
        traceId: trace.id,
        name: "user_message",
        metadata: {
          role: "user",
          content: typeof userMessageContent === 'string' ? userMessageContent : JSON.stringify(userMessageContent),
          timestamp: new Date().toISOString()
        }
      });
    }

    const result = await streamGoogleAIWithTracing({
      modelId: modelConfig.model_id,
      messages: processedMessages,
      temperature,
      maxTokens,
      tools: Object.keys(toolConfigs).length > 0 ? toolConfigs : undefined,
      apiKey: modelConfig.api_key || process.env.GOOGLE_API_KEY,
      baseURL: modelConfig.base_url,
      traceName: "chat_completion",
      userId: threadId || undefined,
      metadata: {
        parentTraceId: trace?.id,
        threadId: threadId || undefined
      }
    });

    if (threadId) {
      result.text.then(async (text) => {
        try {
          const db = getLibSQLClient();
          await db.execute({
            sql: `
              INSERT INTO messages (thread_id, role, content, created_at)
              VALUES (?, ?, ?, datetime('now'))
            `,
            args: [threadId, "assistant", text],
          });

          if (trace?.id) {
            await logEvent({
              traceId: trace.id,
              name: "assistant_message",
              metadata: {
                role: "assistant",
                content: text,
                timestamp: new Date().toISOString(),
                threadId
              }
            });
          }
        } catch (error) {
          console.error("Error storing assistant message:", error);
        }
      }).catch(error => {
        console.error("Error processing assistant response:", error);
        if (trace?.id) {
          logEvent({
            traceId: trace.id,
            name: "assistant_message_error",
            metadata: {
              error: error instanceof Error ? error.message : String(error),
              timestamp: new Date().toISOString()
            }
          }).catch(console.error);
        }
      });
    }

    // Use toDataStreamResponse if you plan to send structured data,
    // or toTextStreamResponse for simple text.
    // Given the main flow uses streamGoogleAIWithTracing which likely returns a StreamTextResult compatible object,
    // and that it might be using data streams, toDataStreamResponse is safer.
    // If streamGoogleAIWithTracing is guaranteed to only produce text streams, toTextStreamResponse() is also fine.
    return result.toDataStreamResponse();
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * Handle requests from the AI SDK UI (Simplified flow)
 */
async function handleAiSdkRequest(body: any) {
  try {
    const { messages, model = 'gemini-1.5-pro', temperature = 0.7, maxTokens = 2048 } = body;

    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json(
        { error: 'Invalid request: messages array is required' },
        { status: 400 }
      );
    }

    // Get the Google AI provider factory from lib/ai.ts
    const googleAIProvider = getGoogleAI();
    // Get the specific model instance from the provider
    const googleModel = googleAIProvider(model); // e.g., googleAIProvider('gemini-1.5-pro')

    // Format messages to CoreMessage[]
    const formattedMessages: CoreMessage[] = messages.map((message: any) => ({
      role: message.role === 'user' ? 'user' : 'assistant', // Map 'model' or other to 'assistant'
      content: message.content,
    }));

    // Generate response using streamText
    const result = await streamText({
      model: googleModel,
      messages: formattedMessages,
      temperature,
      maxTokens,
      // generationConfig: { // This is specific to older Google SDK, use top-level params for streamText
      //   temperature,
      //   maxOutputTokens: maxTokens,
      // },
    });

    // Return the stream using toTextStreamResponse()
    return result.toTextStreamResponse();

  } catch (error) {
    console.error('Error in AI SDK chat handler:', error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    // Ensure a Response object is returned for errors too
    return NextResponse.json(
      { error: 'Failed to generate response', details: errorMessage },
      { status: 500 }
    );
  }
}

================
File: app/api/ai-sdk/agents/[id]/run/route.ts
================
import { NextResponse } from "next/server";
import { createDataStreamResponse } from 'ai';
import { handleApiError } from "@/lib/api-error-handler";
import { createTrace, logEvent } from "@/lib/langfuse-integration";
import { v4 as uuidv4 } from "uuid";
import { agentRegistry } from "@/lib/agents/registry";
import { runAgent } from "@/lib/agents/agent-service";
import { AgentRunOptions } from "@/lib/agents/agent.types";
import { personaManager } from "@/lib/agents/personas/persona-manager";
import { createMemoryThread, saveMessage, loadMessages, loadAgentState, saveAgentState } from "@/lib/memory/memory";
import { getSupabaseClient, isSupabaseClient, isUpstashClient } from "@/lib/memory/supabase";

/**
 * POST /api/ai-sdk/agents/[id]/run
 *
 * Run an agent with the AI SDK
 */
export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const body = await request.json();
    const {
      input,
      threadId: providedThreadId,
      stream = true,
      temperature,
      maxTokens,
      systemPrompt,
      toolChoice
    } = body;

    // Generate thread ID if not provided
    const threadId = providedThreadId || uuidv4();

    // Health check: ensure Supabase/Upstash is available
    const supabaseHealth = await (async () => {
      try {
        const supabase = getSupabaseClient();
        if (isSupabaseClient(supabase)) {
          const { error } = await supabase.from('agents').select('id').limit(1);
          return !error;
        } else if (isUpstashClient(supabase)) {
          // Upstash: try a simple getAll
          await supabase.from('agents').limit(1).getAll();
          return true;
        }
        return false;
      } catch {
        return false;
      }
    })();
    if (!supabaseHealth) {
      return NextResponse.json({ error: "Supabase/Upstash is not available" }, { status: 503 });
    }

    // Initialize agent registry
    await agentRegistry.init();

    // Get agent config using agentRegistry (loads from Upstash/Supabase as needed)
    const agent = await agentRegistry.getAgent(id);
    if (!agent) {
      return NextResponse.json({ error: "Agent not found" }, { status: 404 });
    }

    // Optionally, get persona if present (uses personaManager)
    let persona = null;
    // BaseAgent does not expose persona_id directly, but its config does.
    // @ts-expect-error: Accessing private property for persona_id
    const personaId = agent.config?.persona_id;
    if (personaId) {
      await personaManager.init();
      persona = await personaManager.getPersonaById(personaId);
    }

    // Create a memory thread if it doesn't exist
    let threadExists = false;
    try {
      const messages = await loadMessages(threadId);
      threadExists = messages && messages.length > 0;
    } catch {
      threadExists = false;
    }
    if (!threadExists) {
      await createMemoryThread(`Thread for agent ${id}`);
    }

    // Save user message if input is provided
    if (input) {
      await saveMessage(
        threadId,
        "user",
        input,
        {
          count_tokens: true,
          generate_embeddings: false,
          metadata: {},
          model_name: agent.modelId
        }
      );
    }

    // Load previous messages
    const previousMessages = await loadMessages(threadId);

    // Load agent state
    // (agentState is not used directly, but triggers any stateful logic)
    await loadAgentState(threadId, id);

    // Create trace for this run
    const trace = await createTrace({
      name: "agent_run",
      userId: threadId,
      metadata: {
        agentId: id,
        agentName: agent.name,
        threadId,
        modelId: agent.modelId,
        messageCount: previousMessages.length + (input ? 1 : 0),
        hasPersona: !!persona
      }
    });

    // Run options with onFinish to persist assistant message
    const options: AgentRunOptions = {
      temperature,
      maxTokens,
      systemPrompt,
      toolChoice,
      traceId: trace!.id,
      streamOutput: stream,
      onFinish: async (data) => {
        // Save assistant message to memory after completion
        if (data?.message?.content) {
          await saveMessage(
            threadId,
            "assistant",
            data.message.content,
            {
              count_tokens: true,
              generate_embeddings: false,
              metadata: {},
              model_name: agent.modelId
            }
          );
        }
        // Save agent state if needed
        if (data?.message) {
          await saveAgentState(threadId, id, { lastRun: new Date().toISOString() });
        }
        // Log event
        await logEvent({
          traceId: trace!.id,
          name: "agent_run_finish",
          metadata: {
            agentId: id,
            threadId,
            finishReason: data?.finishReason
          }
        });
      }
    };

    // Run the agent (Upstash/Supabase logic handled in runAgent)
    const response = await runAgent(id, threadId, input, options);

    // Use streamResult if available
    if (response.streamResult) {
      return response.streamResult.toDataStreamResponse({
        headers: {
          'x-thread-id': threadId,
          'x-agent-id': id
        }
      });
    } else {
      // Fallback: use createDataStreamResponse with execute function
      return createDataStreamResponse({
        execute: async (dataStream) => {
          // send only JSON-safe fields
          const { output, memoryThreadId } = response;
          dataStream.writeData({
            status: 'completed',
            output: output ?? null,
            memoryThreadId
          });
        }
      });
    }
  } catch (error) {
    return handleApiError(error);
  }
}

================
File: app/api/chat/ai-sdk/route.ts
================
import { NextResponse } from "next/server";
/**
 * Checks if a thread exists, and creates a new thread if not.
 *
 * This method is part of the chat thread management process, ensuring
 * that a valid thread ID is available for tracking conversation context.
 * If no thread ID is provided, a new unique thread will be generated.
 *
 * @remarks
 * Used in the AI SDK chat route to manage conversation state and persistence.
 */
import { createDataStreamResponse, generateId, type LanguageModelV1Middleware, type Tool } from 'ai';
import { streamWithAISDK } from "@/lib/ai-sdk-integration";
import { createMemory } from "@/lib/memory/factory";
import { v4 as uuidv4 } from "uuid";
import { handleApiError } from "@/lib/api-error-handler";
import { createTrace, logEvent } from "@/lib/langfuse-integration";
// Import model config utilities
import { getSupabaseClient } from "@/lib/memory/supabase";
import { createMiddlewareFromOptions, createCompleteMiddleware } from "@/lib/middleware";
import { personaManager } from "@/lib/agents/personas/persona-manager";
import { toolRegistry } from "@/lib/tools/toolRegistry";
import { RequestMiddleware, ResponseMiddleware } from "@/lib/middleware";
import { DataStreamWriter } from "ai";

// Create memory instance
const memory = createMemory();

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const {
      messages,
      threadId,
      model = 'models/gemini-2.0-flash',
      temperature = 0.7,
      maxTokens = 8192,
      tools = [],
      attachments = [],
      images = [],
      provider = 'google',
      systemPrompt,
      streamProtocol = 'data',
      toolChoice = 'auto',
      maxSteps = 5,
      middleware = {}
    } = body;

    // Build language model middleware from options
    const { languageModel } = createCompleteMiddleware({ languageModel: middleware });

    // Validate request
    if (!messages || !Array.isArray(messages)) {
      return NextResponse.json(
        { error: 'Invalid request: messages array is required' },
        { status: 400 }
      );
    }

    // Get or create thread ID
    const chatThreadId = threadId || generateId();

    // Check if thread exists, if not create it
    if (threadId) {
      // Verify the thread exists
      const existingThread = await memory.getMemoryThread(threadId);
      if (!existingThread) {
        return NextResponse.json(
          { error: 'Thread not found' },
          { status: 404 }
        );
      }
    } else {
      try {
        // Use the memory factory to create a new thread with the generated ID
        await memory.createMemoryThread('AI SDK Chat', {
          metadata: {
            id: chatThreadId, // Pass the generated ID to ensure consistency
            source: 'ai-sdk-ui',
            created_at: new Date().toISOString()
          }
        });
      } catch (error: unknown) {
        console.error('Error creating memory thread:', error);
        // Handle Upstash-specific errors
        if (error && typeof error === 'object' && 'name' in error) {
          const errorObj = error as { name: string; message?: string };
          if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
            throw new Error(`Failed to create memory thread in Upstash: ${errorObj.message || 'Unknown error'}`);
          }
        }
        // Default error handling
        throw new Error(`Failed to create memory thread: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    // Save user message to memory
    const lastMessage = messages[messages.length - 1];
    if (lastMessage.role === 'user') {
      try {
        // Use the memory factory to save the message with token counting and metadata
        await memory.saveMessage(
          chatThreadId,
          'user',
          typeof lastMessage.content === 'string'
            ? lastMessage.content
            : JSON.stringify(lastMessage.content),
          {
            count_tokens: true,
            metadata: {
              source: 'ai-sdk-ui',
              timestamp: new Date().toISOString()
            }
          }
        );
      } catch (error: unknown) {
        console.error('Error saving message:', error);
        // Handle Upstash-specific errors
        if (error && typeof error === 'object' && 'name' in error) {
          const errorObj = error as { name: string; message?: string };
          if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
            throw new Error(`Failed to save user message in Upstash: ${errorObj.message || 'Unknown error'}`);
          }
        }
        // Default error handling
        throw new Error(`Failed to save user message: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    // Note: This helper function is kept for future use when implementing message persistence
    // It's not currently used but will be useful for saving assistant messages after streaming
    /*
    const saveAssistantMessage = async (
      threadId: string,
      content: string,
      metadata?: Record<string, unknown>
    ) => {
      return await memory.saveMessage(
        threadId,
        'assistant',
        content,
        {
          count_tokens: true,
          metadata: {
            source: 'ai-sdk-ui',
            timestamp: new Date().toISOString(),
            ...metadata
          }
        }
      );
    };
    */

    // Set up model configuration
    let modelConfig;
    try {
      // Get model configuration from database
      // This is a simplified implementation - in a real app, you would query your database
      // For now, we'll use a mock implementation
      const data = {
        model_id: model,
        provider: provider || 'google',
        api_key: process.env.GOOGLE_API_KEY,
        temperature: temperature || 0.7,
        max_tokens: maxTokens || 8192,
        context_window: 8192,
        supports_vision: model.includes('vision') || model.includes('gemini') || model.includes('claude-3') || model.includes('gpt-4'),
        supports_functions: true,
        supports_streaming: true,
        default_temperature: 0.7,
        default_top_p: 1.0,
        default_frequency_penalty: 0,
        default_presence_penalty: 0,
        base_url: undefined
      };
      const error = null;

      if (error) throw error;

      modelConfig = data;
    } catch (error) {
      console.warn('Could not fetch model config from Supabase, using default:', error);
      // Use default model configuration
      modelConfig = {
        model_id: model,
        provider: provider || 'google',
        api_key: provider === 'openai'
          ? process.env.OPENAI_API_KEY
          : provider === 'anthropic'
            ? process.env.ANTHROPIC_API_KEY
            : process.env.GOOGLE_API_KEY,
        temperature: temperature || 0.7,
        max_tokens: maxTokens || 8192,
      };
    }

    // Determine provider from model config or model name
    const modelProvider = modelConfig.provider || provider ||
      (model.startsWith('gpt') ? 'openai' :
       model.startsWith('claude') ? 'anthropic' : 'google');

    // Create a trace for this chat interaction
    const trace = await createTrace({
      name: "ai_sdk_chat_interaction",
      userId: chatThreadId,
      metadata: {
        model: modelConfig.model_id,
        provider: modelProvider,
        temperature,
        maxTokens,
        messageCount: messages.length,
        hasTools: tools.length > 0,
        hasImages: images.length > 0,
        hasAttachments: attachments.length > 0,
        threadId: chatThreadId,
        systemPrompt: systemPrompt ? true : false,
        toolChoice,
        maxSteps
      }
    });

    // Log the user message event
    if (trace?.id) {
      await logEvent({
        traceId: trace.id,
        name: "user_message",
        metadata: {
          role: "user",
          content: lastMessage.role === 'user' ? lastMessage.content : '',
          timestamp: new Date().toISOString()
        }
      });
    }

    // Ensure tool registry is initialized
    await toolRegistry.initialize();

    // Format tools for AI SDK
    // Using Record<string, Tool> without generic parameters to avoid type constraints
    const toolConfigs: Record<string, Tool> = {};

    // Process tools requested in the body
    if (body.tools && Array.isArray(body.tools) && body.tools.length > 0) {
      for (const toolRequest of body.tools) {
        if (typeof toolRequest === 'string') {
          // If toolRequest is a string, it's a tool name. Fetch it from the registry.
          const toolInstance = await toolRegistry.getTool(toolRequest);
          if (toolInstance) {
            toolConfigs[toolRequest] = toolInstance;
          } else {
            console.warn(`[Chat API] Tool "${toolRequest}" requested by client but not found in registry.`);
            // Optionally, handle this case more strictly, e.g., by returning an error
            // or by not proceeding if a critical tool is missing.
          }
        } else if (toolRequest && typeof toolRequest === 'object') {
          // If toolRequest is an object, it's an ad-hoc tool definition.
          // For now, these are logged and not made executable on the server-side,
          // as they lack a server-side execute method from the registry.
          // The AI SDK might use these definitions for LLM awareness if passed,
          // but that's a separate concern from backend execution.
          const toolName = toolRequest.function?.name || toolRequest.name;
          if (toolName) {
            console.warn(`[Chat API] Received ad-hoc tool definition for "${toolName}". These are not automatically made executable by the backend. Only named, registered tools are used for server-side execution.`);
          } else {
            console.warn('[Chat API] Received an invalid or unnamed ad-hoc tool definition in the request body.', toolRequest);
          }
        }
      }
    }

    // Get model settings
    const modelSettings = {
      max_tokens: modelConfig.max_tokens || 4096,
      context_window: modelConfig.context_window || 8192,
      supports_vision: modelConfig.supports_vision ||
        model.includes('vision') ||
        model.includes('gemini') ||
        model.includes('claude-3') ||
        model.includes('gpt-4') ||
        false,
      supports_functions: modelConfig.supports_functions || true,
      supports_streaming: modelConfig.supports_streaming || true,
      default_temperature: modelConfig.default_temperature || 0.7,
      default_top_p: modelConfig.default_top_p || 1.0,
      default_frequency_penalty: modelConfig.default_frequency_penalty || 0,
      default_presence_penalty: modelConfig.default_presence_penalty || 0,
    };

    // Validate and adjust maxTokens if needed
    const effectiveMaxTokens = maxTokens && maxTokens > 0
      ? Math.min(maxTokens, modelSettings.max_tokens)
      : modelSettings.max_tokens;

    // Process multimodal content
    const processedMessages = [...messages];

    // Add system prompt if provided and not already in messages
    if (systemPrompt && !messages.some(msg => msg.role === 'system')) {
      processedMessages.unshift({ role: 'system', content: systemPrompt });
    }

    // Process images if any
    if (images && images.length > 0 && modelSettings.supports_vision) {
      // Find the last user message to attach images to
      const lastUserMessageIndex = processedMessages.findIndex(
        msg => msg.role === 'user'
      );

      if (lastUserMessageIndex !== -1) {
        const lastUserMessage = processedMessages[lastUserMessageIndex];
        // Convert to multimodal format if needed
        if (typeof lastUserMessage.content === 'string') {
          processedMessages[lastUserMessageIndex] = {
            role: 'user',
            content: [
              { type: 'text', text: lastUserMessage.content },
              ...images.map((img: { url?: string; data?: string } | string) => ({
                type: 'image',
                image: typeof img === 'object' ? (img.url || img.data || '') : img
              }))
            ]
          };
        }
      }
    }

    // Configure middleware
    let languageModelMiddleware: LanguageModelV1Middleware[] = [];
    let requestResponseMiddleware: (RequestMiddleware | ResponseMiddleware)[] = [];

    if (middleware) {
      // Handle language model middleware
      if (typeof middleware === 'object') {
        // Check if it's a middleware options object
        if ('caching' in middleware || 'reasoning' in middleware ||
            'simulation' in middleware || 'logging' in middleware ||
            'defaultSettings' in middleware) {
          // It's middleware options
          const middlewareOptions = {
            caching: middleware.caching || { enabled: false },
            reasoning: middleware.reasoning || { enabled: false },
            simulation: middleware.simulation || { enabled: false },
            logging: middleware.logging || { enabled: false },
            defaultSettings: middleware.defaultSettings
          };

          // Create middleware array using our middleware module
          languageModelMiddleware = createMiddlewareFromOptions(middlewareOptions);

          // Log middleware creation
          console.log(`Created ${languageModelMiddleware.length} language model middleware from options`);
        } else if (middleware.languageModel || middleware.request || middleware.response) {
          // It's a structured middleware object with separate types
          if (middleware.languageModel) {
            languageModelMiddleware = Array.isArray(middleware.languageModel)
              ? middleware.languageModel
              : [middleware.languageModel];

            console.log(`Using ${languageModelMiddleware.length} provided language model middleware`);
          }

          // Store request/response middleware for future use
          if (middleware.request || middleware.response) {
            requestResponseMiddleware = [
              ...(Array.isArray(middleware.request) ? middleware.request :
                middleware.request ? [middleware.request] : []),
              ...(Array.isArray(middleware.response) ? middleware.response :
                middleware.response ? [middleware.response] : [])
            ];

            console.log(`Using ${requestResponseMiddleware.length} provided request/response middleware`);
          }
        }
      } else if (Array.isArray(middleware)) {
        // It's an array of middleware
        languageModelMiddleware = middleware;
        console.log(`Using ${languageModelMiddleware.length} middleware from array`);
      }
    }

    // Initialize tool registry if needed
    await toolRegistry.initialize();

    // Check if any persona is specified
    const personaId = body.personaId || body.persona_id;
    let personaSystemPrompt: string | undefined;

    if (personaId) {
      try {
        // Get persona from persona manager
        // Note: This is a simplified implementation - in a real app, you would use the actual persona manager
        const persona = {
          id: personaId,
          name: 'Default Persona',
          systemPromptTemplate: 'You are a helpful AI assistant.'
        };

        if (persona && persona.systemPromptTemplate) {
          // Extract system prompt from persona
          personaSystemPrompt = persona.systemPromptTemplate;
          console.log(`Using persona ${persona.name} with system prompt template`);

          // In a real implementation, you would generate the system prompt dynamically
          // For now, we'll just use the template
        }

          // If no system prompt was provided but we have a persona, use it
          if (!systemPrompt && personaSystemPrompt) {
            // Add persona system prompt to the beginning of messages
            processedMessages.unshift({ role: 'system', content: personaSystemPrompt });
          }
      } catch (error) {
        console.warn(`Error loading persona ${personaId}:`, error);
      }
    }

    // Configuration for AI SDK integration is defined inline where used
    // This ensures we don't have unused variables and keeps the configuration close to its usage

    // Use Data Stream Protocol for enhanced features
    if (streamProtocol === 'data') {
      return createDataStreamResponse({
        execute: async (dataStream: DataStreamWriter) => {
          // Send initial status
          dataStream.writeData({
            status: 'initialized',
            threadId: chatThreadId,
            timestamp: new Date().toISOString()
          });

          try {
            // Tool registry is already initialized earlier in the POST handler.
            // We just confirm if tools were actually configured to be used for this call.
            if (Object.keys(toolConfigs).length > 0) {
              dataStream.writeData({
                status: 'tools_configured_for_stream', // Renamed for clarity
                toolCount: Object.keys(toolConfigs).length,
                timestamp: new Date().toISOString()
              });
            }

            // Generate a unique ID for the assistant message
            const assistantMessageId = uuidv4();

            const result = await streamWithAISDK({
              provider: modelProvider,
              modelId: modelConfig.model_id,
              messages: processedMessages,
              temperature,
              maxTokens: effectiveMaxTokens,
              tools: toolConfigs,
              apiKey: modelConfig.api_key,
              baseURL: modelConfig.base_url,
              traceName: 'ai_sdk_chat',
              userId: chatThreadId,
              metadata: {
                threadId: chatThreadId,
                messageId: assistantMessageId
              }
            });

            // Merge the stream into the data stream
            result.mergeIntoDataStream(dataStream);
          } catch (error: unknown) {
            console.error('Error in AI SDK chat stream:', error);

            // Send error to client
            dataStream.writeData({
              status: 'error',
              error: error instanceof Error ? error.message : String(error),
              timestamp: new Date().toISOString()
            });

            // Handle Upstash-specific errors
            if (error && typeof error === 'object' && 'name' in error) {
              const errorObj = error as { name: string; message?: string };
              if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
                dataStream.writeData({
                  status: 'upstash_error',
                  error: errorObj.message || 'Unknown Upstash error',
                  timestamp: new Date().toISOString()
                });
              }
            }
          }
        }
      });
    }

    // Default to Text Stream Protocol
    // Generate a unique ID for the assistant message
    const assistantMessageId = uuidv4();

    const result = await streamWithAISDK({
      provider: modelProvider,
      modelId: modelConfig.model_id,
      messages: processedMessages,
      temperature,
      maxTokens: effectiveMaxTokens,
      tools: toolConfigs,
      apiKey: modelConfig.api_key,
      baseURL: modelConfig.base_url,
      traceName: 'ai_sdk_chat',
      userId: chatThreadId,
      metadata: {
        threadId: chatThreadId,
        messageId: assistantMessageId
      }
    });

    return result;
  } catch (error: unknown) {
    // Log error for debugging
    console.error('Error in AI SDK chat:', error);

    // Handle Upstash-specific errors
    if (error && typeof error === 'object' && 'name' in error) {
      const errorObj = error as { name: string; message?: string };
      if (errorObj.name === 'RedisStoreError' || errorObj.name === 'UpstashClientError') {
        return NextResponse.json(
          { error: `Upstash error: ${errorObj.message || 'Unknown error'}` },
          { status: 500 }
        );
      }
    }

    // Use the generic API error handler for other errors
    return handleApiError(error);
  }
}




================================================================
End of Codebase
================================================================
